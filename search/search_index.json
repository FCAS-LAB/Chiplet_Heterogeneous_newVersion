{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the parallel LEGO simulator for heterogeneous chiplets (LegoSim).</p>"},{"location":"#overview","title":"Overview","text":"<p>The LegoSim (parallel LEGO simulator for heterogeneous chiplets) is designed to address the challenge of simulating a vast system constructed by heterogeneous chiplets.</p> <p>A cycle-accurate model is not realizable for such scale systems due to the limitation on host-machine performance and memory space. A parallel cycle-accurate model is also not attractive because the speedup cannot increase further as the parallelism rises due to frequent synchronization operations across all parallel threads or processes.</p> <p>Traditionally, integrating a new kind of IPs or chiplets has been a laborious task, requiring significant effort in coding, debugging, and correlation. However, there are open-source models of CPU, NoC, DRAM, and so on, eliminating the need to start from scratch.</p> <p>To simulate a massive chiplet-based system, the simulation speed and development speed are much more critical than whether the simulation result is cycle-coherent with a realistic system. Both the academic field and industrial field are seeking one balanced solution. The LegoSim provides a loose-couple parallel architecture to address the challenge of faster simulation, development, and reconfiguration.</p> <p>To speed up parallel simulation, the frequency of synchronization between simulation processes is reduced to the same frequency as software synchronization in the benchmark. In other words, simulation processes only synchronize when benchmarks send/read data or require shared resources. Meanwhile, the synchronization scope limits the processes related to the software operation.</p> <p>For example, if two simulation processes never communicate with each other or if they never require shared resources, these two simulation processes can run parallel all the time.</p> <p>For another example, when a CPU wants to send data to a GPU, the software in the CPU writes data to a range of memory space and writes another memory location to signal to the GPU that the data is ready. The software in the GPU enquires the memory location until it gets the signal before the GPU reads the data. In LegoSim, such a sequence of operations is abstracted as a kind of transaction (data transaction). The LegoSim focuses on the end cycle of one transaction rather than the duration of each operation within one transaction. In this way, the amount of essential synchronization operations is dropped.</p> <p>The LegoSim empowers you with the ability to speed up development and reconfiguration. Integrating various open-source simulators eliminates the high cost of developing a model for each IP or chiplet. With simple configuration files, you can simulate one benchmark on different platforms with various IPs or chiplets, giving you full control over your simulations.</p>"},{"location":"#modeling-target-architect","title":"Modeling target architect","text":"<p>The Chiplet simulator aims to model a system consisting of heterogeneous IPs and chiplets.</p> <p>The target architecture is divided into Processing Components (PComp) and Shared Components (SComp). In general, PComps are master devices that can generate requests for shared components. Optionally, but usually, PComps can execute instructions and consist of one memory system. CPUs (clusters), GPUs, and NPUs are typical PComps. SComps are shared by PComps and respond to requests from PComps, including NoC, DRAM controllers, and some kinds of accelerators.</p> <p>An example of target architecture combined with chiplets is shown below:</p> <p></p> <p>Another example of target architecture combined with IPs is shown below:</p> <p></p> <p>In view of execution time, PComps control tasks and flows in the system, which plays a significant role in regulating the simulation time. SComps impact performance by the duration of time they respond to requests from PComps. Take the DRAM controller as an example; CPU/GPUs send read/write requests to the DRAM controller. If the speed of DRAM to access external memory is slower, CPU/GPUs need a longer duration to wait for the response from the DRAM controller, and usually, it means a longer time to execute one benchmark. Hence, the simulation result will be reasonable if the time cost of SComps can be reflected by PComps reasonably.</p>"},{"location":"#legosim-architecture","title":"LegoSim Architecture","text":"<p>As shown above, the target systems combine different kinds of components, which may be described by well-used simulators. Each component in the target system corresponds to one simulation process, and these processes execute parallel to increase the simulation speed.</p>"},{"location":"#simulation-cycle-iteration","title":"Simulation cycle iteration","text":"<p>The SComp simulators need to get traces as input from PComp simulators, and PComp simulators need to get delay information from SComp simulators. Both stimulus trace and delay information control the accuracy of the simulation. Hence, the LegoSim defines an iteration flow so that the impact between PComp and SComp can converge to a realistic value.</p> <p>The figure below shows the iteration flow.</p> <p></p> <p>Each iteration consists of two phases. Phase 1 simulates PComps, and Phase 2 simulates SComps.</p> <p>In phase 1 of the first iteration, PComps are simulated parallelly. One algorithm is applied to calculate the delay of requests from PComps. Meanwhile, Interchiplet receives protocol commands from simulation processes and generates traces as a stimulus to SComps. The maximum execution cycle among all PComps is counted as the execution cycle of this benchmark in the first iteration.</p> <p>In phase 2 of the first iteration, SComps are also simulated parallelly. The traces generated in Phase 1 drive the simulation of SComps in Phase 2. The simulation generates delay information for each request.</p> <p>TODO: Support more than 2 phases if one request is handled by more than one SComps.</p> <p>In Phase 1 of the second iteration, PComps are simulated again as the first iteration. The simulation takes the delay information generated by Phase 2 of the previous iteration.</p> <p>At the end of Phase 1 of the second iteration, the execution cycle recorded from the current and previous iteration are compared. If the error ratio is lower than a specified threshold, the execution cycle is considered to be convergent, and the simulation stops. Otherwise, the simulation continues with Phase 2, the same as the previous iteration.</p> <p>In case of non-convergence, the simulation flow can stop after a specified number of iterations, called\u00a0timeout.</p>"},{"location":"#multiple-process-multi-thread-structure","title":"Multiple-process Multi-thread Structure","text":"<p>The LegoSim is a multi-process, multi-thread software. The software architecture is shown below:</p> <p></p> <p>As the main process, the Interchiplet controls the flow of the entire simulation. It will create as many threads as the simulation processes. These threads are referenced as\u00a0sub-threads. Each thread corresponds to one simulation process and handles the inter-process communication and synchronization.</p> <p>To avoid file conflict between simulation processes, one individual folder is provided for each process in each iteration, named \u00a0proc_r{iteration}_p{phase}_t{thread}. For example,\u00a0proc_r2_p1_t4\u00a0is the working directory of the 4-th thread of Phase 1 of the second iteration. These folders are referenced as\u00a0sub-directories.</p> <p>The figure below shows the data flow of the LegoSim:</p> <p></p> <p>In the above figure, dot lines present the data flow within one program through variables. Thick lines present the data flow through file descriptors, including Pipe, Named Pipe, and standard file interface. Fine lines present the control flow to create Named Pipes.</p> <p>Each sub-thread of Interchiplet connects the standard input and output of one simulation process through PIPE. The content from standard output and standard error output will be redirected to a log file.</p> <p>The data interchange between simulation processes goes through Named Pipes. One Named Pipe supports one-directional data transmission. Named Pipes are created as essential. LegoSim provides a synchronization protocol and a set of APIs to handle the communication between processes. A minor modification is necessary to apply such a protocol in integrated third-party simulators. Details can be seen in the Synchronization Protocol and Imported Simulator.</p> <p>Sub-threads in Interchiplet take responsibility for handling such protocol. One sub-thread gets one protocol command from the corresponding simulation process through standard output and issues another protocol command as a response through standard input.</p> <p>Interchiplet maintains one mutex and one shared data structure between these sub-threads. Sub-threads are parallel when they handle outputs from simulation processes, so the redirection effect can be hidden. When they receive any protocol command, one thread must lock the mutex before further handling, so all protocol commands are handled atomically.</p> <p>Before creating sub-threads, the main thread in Interchiplet will load delay information generated by Phase 2 of the previous iteration into the shared data structure. All sub-threads can get package delay information through the shared data structure. Sub-threads receive protocol commands during simulation and record traces in the shared data structure. After all sub-threads finish, the main thread in Interchiplet will dump traces recorded in the shared data structure into files as the stimulus for Phase 2.</p>"},{"location":"01-quick-start/","title":"Quick Start","text":"<p>You can learn the following topics from this page:</p> <ol> <li>Install the LegoSim.</li> <li>Execute benchmarks provided in the LegoSim.</li> </ol>"},{"location":"01-quick-start/#installation","title":"Installation","text":"<p>1. Clone the repository from GitHub and enter the downloaded repository.</p> <pre><code>git clone --single-branch --branch master_v2 https://github.com/FCAS-SCUT/Chiplet_Heterogeneous_newVersion.git\ncd Chiplet_Heterogeneous_newVersion\n</code></pre> <p>The following commands are executed under the root folder. The root folder is defined as <code>$SIMULATOR_ROOT</code> in the environment variables.</p> <p>2. Initialize and update submodules. Third-party repositories such as SniperSim and GPGPUSim will be downloaded and updated.</p> <pre><code>git submodule init\ngit submodule update\n</code></pre> <p>3. Setup environment.</p> <pre><code>source setup_env.sh\n</code></pre> <p>If the operation succeeds, <code>setup_environment succeeded</code> is printed to the terminal.</p> <p>4. Apply modifications to Imported Simulators. The simulator can still execute benchmarks if Step 4 is skipped, but no interactions between chiplets are performed.</p> <pre><code>./apply_path.sh\n</code></pre> <p>5. Compile Imported Simulators.</p> <p>The installation procedure can be skipped for unnecessary simulators.</p> <p>5.1. Compile SniperSim.</p> <pre><code>cd snipersim\nmake -j4\n</code></pre> <p>5.2. Gem5. The detailed installation guide for Gem5 can be found at https://www.gem5.org/documentation/learning_gem5/part1/building/.</p> <p>If requirements have been addressed, X86 and ARM simulators can be used in LegoSim.</p> <pre><code>cd gem5\nscons build/X86/gem5.opt -j4\n</code></pre> <p>or</p> <pre><code>cd gem5\nscons build/ARM/gem5.opt -j4\n</code></pre> <p>5.3. Compile GPGPUSim. Installation of GPGPUSim requires the following conditions:</p> <ul> <li>CUDA environment is correctly installed and configured. Imported GPGPUSim supports CUDA versions from 4.0 to 11.0. See README within gpgpu-sim for details.</li> <li>GPGPUSim has a limitation on the compiler version. According to our experiment, GCC7 is recommended.</li> </ul> <pre><code>cd gpgpu-sim\nmake -j4\n</code></pre> <p>6. Compile Popnet.</p> <pre><code>cd popnet\nmkdir build\ncd build\ncmake ..\nmake -j4\n</code></pre> <p>7. Compile the LegoSim. The compile process is managed by CMake.</p> <pre><code>cd interchiplet\nmkdir build\ncd build\ncmake ..\nmake\n</code></pre> <p>If the operation succeeds, interchiplet can be found under interchiplet/bin, while libinterchiplet_c.a and libinterchiplet_cu.a can be found under interchiplet/lib.</p>"},{"location":"01-quick-start/#execute-benchmark","title":"Execute Benchmark","text":"<p>To check whether the LegoSim is installed and configured correctly, you can execute the demo benchmark matmul.</p> <p>1. Setup environment.</p> <pre><code>source setup_env.sh\n</code></pre> <p>If the operation succeeds, <code>setup_environment succeeded</code> is printed to the terminal.</p> <p>2. Compile execution files for benchmark.</p> <pre><code>cd benchmark/matmul\nmake\n</code></pre> <p>If operation successes, matmul_c and matmul_cu can be found under benchmark/matmul/bin.</p> <p>3. Execute simulation.</p> <pre><code>$SIMULATOR_ROOT/interchiplet/bin/interchiplet ./matmul.yml\n</code></pre> <p>The matmul benchmark launches four processes, which are 1 CPU process and 3 GPGPU processes.</p> <p>If the benchmark executes correctly, you will find it experiences two rounds of simulation. Also, the following information can be found on your terminal.</p> <pre><code>[2024-06-23 14:48:59.546] [info] ==== LegoSim Chiplet Simulator ====\n[2024-06-23 14:48:59.547] [info] Load benchmark configuration from matmul.yml.\n[2024-06-23 14:48:59.547] [info] **** Round 1 Phase 1 ****\n[2024-06-23 14:48:59.547] [info] Load 0 delay records.\n[2024-06-23 14:48:59.548] [info] Start simulation process 1617365. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/benchmark/matmul/bin/matmul_cu\n[2024-06-23 14:48:59.548] [info] Start simulation process 1617366. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/benchmark/matmul/bin/matmul_cu\n[2024-06-23 14:48:59.549] [info] Start simulation process 1617368. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/benchmark/matmul/bin/matmul_cu\n[2024-06-23 14:48:59.549] [info] Start simulation process 1617370. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/snipersim/run-sniper\n[2024-06-23 14:49:14.522] [info] Simulation process 1617366 terminate with status = 0.\n[2024-06-23 14:49:14.522] [info] Simulation process 1617365 terminate with status = 0.\n[2024-06-23 14:49:15.520] [info] Simulation process 1617368 terminate with status = 0.\n[2024-06-23 14:49:16.807] [info] Simulation process 1617370 terminate with status = 0.\n[2024-06-23 14:49:16.807] [info] All process has exit.\n[2024-06-23 14:49:16.807] [info] Dump 9 bench records.\n[2024-06-23 14:49:16.807] [info] Benchmark elapses 2910097 cycle.\n[2024-06-23 14:49:16.807] [info] **** Round 1 Phase 2 ***\n[2024-06-23 14:49:16.808] [info] Start simulation process 1618141. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/popnet_chiplet/build/popnet\n[2024-06-23 14:49:16.961] [info] Simulation process 1618141 terminate with status = 0.\n[2024-06-23 14:49:16.961] [info] All process has exit.\n[2024-06-23 14:49:16.961] [info] Round 1 elapses 0d 0h 0m 17s.\n[2024-06-23 14:49:16.961] [info] **** Round 2 Phase 1 ****\n[2024-06-23 14:49:16.962] [info] Load 9 delay records.\n[2024-06-23 14:49:16.962] [info] Start simulation process 1618146. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/benchmark/matmul/bin/matmul_cu\n[2024-06-23 14:49:16.963] [info] Start simulation process 1618147. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/benchmark/matmul/bin/matmul_cu\n[2024-06-23 14:49:16.963] [info] Start simulation process 1618149. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/benchmark/matmul/bin/matmul_cu\n[2024-06-23 14:49:16.964] [info] Start simulation process 1618151. Command: /data_sda/junwan02/Chiplet_Heterogeneous_newVersion/snipersim/run-sniper\n[2024-06-23 14:49:30.816] [info] Simulation process 1618146 terminate with status = 0.\n[2024-06-23 14:49:30.816] [info] Simulation process 1618147 terminate with status = 0.\n[2024-06-23 14:49:31.811] [info] Simulation process 1618149 terminate with status = 0.\n[2024-06-23 14:49:32.219] [info] Simulation process 1618151 terminate with status = 0.\n[2024-06-23 14:49:32.219] [info] All process has exit.\n[2024-06-23 14:49:32.219] [info] Dump 9 bench records.\n[2024-06-23 14:49:32.219] [info] Benchmark elapses 2909345 cycle.\n[2024-06-23 14:49:32.219] [info] Difference related to pervious round is 0.025847742361253135%.\n[2024-06-23 14:49:32.219] [info] Quit simulation because simulation cycle has converged.\n[2024-06-23 14:49:32.219] [info] **** End of Simulation ****\n[2024-06-23 14:49:32.219] [info] Benchmark elapses 2909345 cycle.\n[2024-06-23 14:49:32.219] [info] Simulation elapseds 0d 0h 0m 33s.\n</code></pre> <p>The cycle elapsed by benchmark is about 5.77M cycles with a minor error on different platforms. The time elapsed by the simulator depends on the performance of the host machines, so it varies across different platforms. \u00a0 4. Clear executable files and output files.</p> <pre><code>make clean\n</code></pre>"},{"location":"01-quick-start/#command-line-interface-of-interchiplet","title":"Command Line Interface of interchiplet","text":"<p>The user interface of the LegoSim is interchiplet that is provided in $SIMULATOR_ROOT/interchiplet/bin. The command line format of interchiplet is shown below:</p> <pre><code>interchiplet &lt;bench&gt;.yml [--cwd &lt;string&gt;] [-t|--timeout &lt;int&gt;] [-e|--error &lt;float&gt;] [--debug] [-h]\n</code></pre> <p>Command line options:</p> <ul> <li><code>&lt;bench&gt;.yml</code> specifies the configuration file of the benchmark. This option is mandatory.</li> <li><code>--cwd &lt;string&gt;</code> specifies the execution directory of the simulation. This option is optional. If not provided, the simulation is executed in the current working directory.</li> <li><code>-t &lt;int&gt;</code> or <code>--timeout &lt;int&gt;</code> specifies the time-out threshold of simulation in units of simulation rounds. No matter whether the cycle elapsed by the benchmark has converged, the simulation will quit after a certain account of simulation rounds specified by this option. This option is optional. A default value of 5 is used if not provided.</li> <li><code>e &lt;float&gt;</code> or <code>--error &lt;float&gt;</code> specifies the convergence condition of the cycle elapsed by the benchmark. If the error of cycle elapsed by the benchmark between simulation rounds is lower than the specified value, the simulation will stop. This option is optional. A default value of 0.05 is used if not provided.</li> <li><code>--debug</code> defines the verbosity of the output log. If <code>--debug</code> appears, the details of the synchronization protocol are printed on the stand output.</li> </ul> <p>For example,</p> <pre><code>$SIMULATOR_ROOT/interchiplet/bin/interchiplet $SIMULATOR_ROOT/benchmark/matmul/matmul.yml\n</code></pre> <p>The above command starts the simulation of matmul in the current directory. The simulation will last at most five iterations and quit if the error of cycle elapsed by benchmark is lower than 0.5%.</p>"},{"location":"02-benchmarks/022-yaml/","title":"YAML Configuration File","text":"<p>You can learn the following topics from this page:</p> <ul> <li>Create the configuration file (YAML format) of a novel benchmark.</li> </ul>"},{"location":"02-benchmarks/022-yaml/#yaml-configuration-file-format","title":"YAML Configuration File Format","text":"<p>The execution process is controlled by a YAML configuration file. One benchmark must have at least one YAML configuration file. More configuration files can be created to describe different configurations of one benchmark.</p> <p>The example structure of the YAML file is as follows:</p> <pre><code># Phase 1 configuration.\nphase1:\n  # Process 0\n  - cmd: \"$BENCHMARK_ROOT/bin/matmul_cu\"\n    args: [\"0\", \"1\"]\n    log: \"gpgpusim.0.1.log\"\n    is_to_stdout: false\n    pre_copy: \"$SIMULATOR_ROOT/gpgpu-sim/configs/tested-cfgs/SM2_GTX480/*\"\n    clock_rate: 1\n  # Process 1\n  - cmd: \"$BENCHMARK_ROOT/bin/matmul_cu\"\n    args: [\"1\", \"0\"]\n    log: \"gpgpusim.1.0.log\"\n    is_to_stdout: false\n    pre_copy: \"$SIMULATOR_ROOT/gpgpu-sim/configs/tested-cfgs/SM2_GTX480/*\"\n    clock_rate: 1\n  ......\n\n# Phase 2 configuration.\nphase2:\n  # Process 0\n  - cmd: \"$SIMULATOR_ROOT/popnet_chiplet/build/popnet\"\n    args: [\"-A\", \"2\", \"-c\", \"2\", \"-V\", \"3\", \"-B\", \"12\", \"-O\", \"12\", \"-F\", \"4\", \"-L\", \"1000\", \"-T\", \"10000000\", \"-r\", \"1\", \"-I\", \"../bench.txt\", \"-R\", \"0\", \"-D\", \"../delayInfo.txt\", \"-P\"]\n    log: \"popnet_0.log\"\n    is_to_stdout: false\n    clock_rate: 1\n</code></pre> <p>In the above configuration files, the first-level tags are</p> <ul> <li><code>phase1</code> provides the configuration for processes in Phase 1.</li> <li><code>phase2</code> provides the configuration for processes in Phase 2.</li> </ul> <p>Both <code>phase1</code> and <code>phase2</code> accept a list of process configuration structures. Each structure corresponds to one parallel simulator process.</p> <p>Configuration structures provide the following tags:</p> <ul> <li><code>cmd</code> ppresents the command of the simulator. A string is accepted. The environment variables\u00a0<code>$BENCHMARK_ROOT</code>\u00a0and\u00a0<code>$SIMULATOR_ROOT</code>\u00a0are supported to describe the path of the simulator.</li> <li><code>args</code> presents the arguments of the simulator. A list of strings is accepted. The environment variables\u00a0<code>$BENCHMARK_ROOT</code>\u00a0and\u00a0<code>$SIMULATOR_ROOT</code>\u00a0are also supported to specify the path of related files.\u00a0<code>cmd</code>\u00a0and\u00a0<code>args</code>\u00a0combine the SHELL command to execute one simulator.</li> <li><code>log</code>\u00a0presents the name of the logger. A string is accepted. Neither the absolute path nor the related path is supported. The log file is stored in the sub-directory of each simulation process.</li> <li><code>is_to_stdout</code>\u00a0presents whether the standard output and standard error output of this simulator process are redirected to the standard output of the intercoupled.</li> <li><code>pre_copy</code>\u00a0provides a list of files that should be copied to the sub-directory of this simulation process before calling the simulator. A string is accepted. If there are multiple files to copy, files are separated by space.</li> <li><code>clock_rate</code> provides a floating-pointing number as the ratio between chiplet clocks (clocks of simulators) and the system clock (clock of the interchiplet).</li> </ul> <p>TODO: Change pre_copy to pre_cmd.</p> <p>The following commands are supported when writing one benchmark configuration file.</p> <ul> <li><code>$BENCHMARK_ROOT</code> presents the root path of the benchmark, specified by the location of the YAML configuration file.</li> <li><code>$SIMULATOR_ROOT</code> presents the root path of the LegoSim, set by setup_env.sh.</li> </ul>"},{"location":"02-benchmarks/021-apis/","title":"APIs","text":"<p>You can learn the following topics from this page:</p> <ul> <li>Create or modify the source code of a benchmark to execute on the LegoSim.</li> </ul>"},{"location":"02-benchmarks/021-apis/#create-source-codes-of-benchmarks","title":"Create Source Codes of Benchmarks","text":"<p>Considering the complexity of the software stack of heterogeneous systems, it should not be expected that there will be a standard software stack available for every experimental platform on LegoSim. Hence, task partitioning and task management should be done manually. Each simulator should have one individual executable file. For example, different executable files should be provided to SniperSim and GPGPUSim. Moreover, imported simulators can share the same executable file if they perform the same task on various datasets, like Same-Task-Multiple-Data (STMD).</p> <p>Take the matmul benchmark as an example. In matmul benchmark, the CPU generates source matrixes and sends data to GPGPUs, while three GPGPUs perform the matrix multiplex operation. Each GPGPU handles a part of the data. The matmul benchmark provides two executable files for SniperSim and GPGPUSim. Simulation processes of GPGPUSim share the same executable file.</p> <p>Several APIs should be added to benchmarks to communicate and synchronize processes. In reality, similar APIs are also injected by one complete software stack (like CUDA).</p>"},{"location":"02-benchmarks/021-apis/#api-lists","title":"API Lists","text":"<p>TODO: non-blocking APIs.</p>"},{"location":"02-benchmarks/021-apis/#communication","title":"Communication","text":"<p>The source sends data to the destination by <code>sendMessage</code> while the destination receives data from the source by <code>receiveMessage</code>. The source and destination addresses are the same among <code>sendMessage</code> and <code>receiveMessage</code>.</p> <p>APIs for CPU</p> <pre><code>syscall_return_t sendMessage(int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y, void* __addr, int64_t __nbyte);\nsyscall_return_t receiveMessage(int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y, void* __addr, int64_t __nbyte);\n</code></pre> <p>APIs for CUDA</p> <pre><code>cudaError_t sendMessage(int __dst_x, int __dst_y, int __src_x, int __srx_y, void* __addr, int __nbyte);\ncudaError_t receiveMessage(int __dst_x, int __dst_y, int __src_x, int __srx_y, void* __addr, int __nbyte);\n</code></pre> <p>Arguments</p> <ul> <li><code>__dst_x</code>\u00a0and\u00a0<code>__dst_y</code>\u00a0specify the destination address.</li> <li><code>__src_x</code>\u00a0and\u00a0<code>__src_y</code>\u00a0specify the source address.</li> <li><code>__addr</code>\u00a0specifies the pointer to the data array.</li> <li><code>__nbyte</code>\u00a0determines the number of bytes in the data array.</li> </ul> <p>Return value</p> <ul> <li>APIs for CPU return the result of the operation.<ul> <li>0 means the transmission operation succeeds.</li> <li>1 means the transmission operation fails.</li> </ul> </li> <li>APIs for GPU return one value of <code>cudaError_t</code>.</li> </ul>"},{"location":"02-benchmarks/021-apis/#lock-and-unlock","title":"Lock and unlock","text":"<p><code>lock</code> and <code>unlock</code> are used to manage the critical region. <code>lock</code> blocks the process until the mutex is locked by this request. <code>unlock</code> releases the mutex.</p> <p>APIs for CPU</p> <pre><code>syscall_return_t lock(int64_t __uid, int64_t __src_x, int64_t __src_y);\nsyscall_return_t unlock(int64_t __uid, int64_t __src_x, int64_t __src_y);\n</code></pre> <p>APIs for CUDA</p> <pre><code>cudaError_t lock(int __uid, int __src_x, int __src_y);\ncudaError_t unlock(int __uid, int __src_x, int __src_y);\n</code></pre> <p>Arguments</p> <ul> <li><code>__uid</code> specifies one unique ID of the mutex. <code>__uid</code> should not be the same as any one address in the system.</li> <li><code>__src_x</code> and <code>__src_y</code> specify the source address.</li> </ul> <p>Return value</p> <ul> <li>APIs for CPU return the result of the operation.<ul> <li>0 means the transmission operation succeeds.</li> <li>1 means the transmission operation fails.</li> </ul> </li> <li>APIs for GPU return one value of <code>cudaError_t</code>.</li> </ul>"},{"location":"02-benchmarks/021-apis/#barrier","title":"Barrier","text":"<p>When calling <code>barrier</code>, processes are blocked until a certain number of processes enter the barrier.</p> <p>APIs for CPU</p> <pre><code>syscall_return_t barrier(int64_t __uid, int64_t __src_x, int64_t __src_y, int64_t __count = 0);\n</code></pre> <p>APIs for CUDA</p> <pre><code>cudaError_t barrier(int __uid, int __src_x, int __src_y, int __count = 0);\n</code></pre> <p>Arguments</p> <ul> <li><code>__uid</code> specifies one unique ID of the barrier. <code>__uid</code> should not be the same as any one address in the system.</li> <li><code>__src_x</code> and <code>__src_y</code> specify the source address.</li> <li><code>__count</code> specifies the number of threads for the barrier. If <code>__count</code> is greater than 0, the number of processes is overridden when the barrier overflows.</li> </ul> <p>Return value</p> <ul> <li>APIs for CPU return the result of the operation.<ul> <li>0 means the transmission operation succeeds.</li> <li>1 means the transmission operation fails.</li> </ul> </li> <li>APIs for GPU return one value of <code>cudaError_t</code>.</li> </ul>"},{"location":"02-benchmarks/021-apis/#launch","title":"Launch","text":"<p>When several masters share a computation resource, masters should send launch requests to the shared computation resource to start tasks.</p> <p>The program on the master calls <code>launch</code> to launch one task on the shared computation resource. <code>launch</code> blocks the program on the master until the shared computation resource has been triggered by this request.</p> <p>The program on the shared computation resources calls <code>waitlaunch</code> to get the launcher. <code>waitlaunch</code> blocks the task until one master triggers the task.</p> <p>The source and destination addresses are the same among <code>launch</code> and <code>waitlaunch</code>.</p> <p>APIs for CPU</p> <pre><code>syscall_return_t launch(int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y);\nsyscall_return_t waitLaunch(int64_t __dst_x, int64_t __dst_y, int64_t* __src_x, int64_t* __src_y);\n</code></pre> <p>APIs for CUDA</p> <pre><code>cudaError_t launch(int __dst_x, int __dst_y, int __src_x, int __src_y);\ncudaError_t waitLaunch(int __dst_x, int __dst_y, int* __src_x, int* __src_y);\n</code></pre> <p>Arguments</p> <ul> <li><code>__dst_x</code>\u00a0and\u00a0<code>__dst_y</code>\u00a0specify the destination address.</li> <li><code>__src_x</code>\u00a0and\u00a0<code>__src_y</code>\u00a0specify the source address.</li> </ul> <p>Return value</p> <ul> <li> <p><code>waitLaunch</code> returns the source of the launch command through <code>__src_x</code> and <code>__src_y</code>.</p> </li> <li> <p>APIs for CPU return the result of the operation.</p> <ul> <li>0 means the transmission operation succeeds.</li> <li>1 means the transmission operation fails.</li> </ul> </li> <li>APIs for GPU return one value of <code>cudaError_t</code>.</li> </ul> <p>TODO: A more flexible way to specify the source and the destination address.</p> <p>Example</p> <pre><code>//\n// master (0,1)\n//\n...\n// Launch task on the slave.\nlaunch(0, 0, 0, 1);\n// Send data to the slave.\nsendMessage(0, 0, 0, 1, src_data, 1024);\n// Wait and receive data from the slave.\nreceiveMessage(0, 0, 0, 1, dst_data, 8);\n...\n\n//\n// slave (0, 0)\n//\n...\n// Wait launcher\nint64_t src_x = -1, src_y = -1;\nwaitlaunch(0, 0, &amp;src_x, &amp;src_y);\n// Receive data from the master.\nreceiveMessage(0, 0, 0, 1, src_data, 1024);\n// Run task.\n...\n// Send data to the master.\nsendMessage(0, 0, 0, 1, dst_data, 8);\n...\n</code></pre>"},{"location":"02-benchmarks/021-apis/#api-declaration-and-implementation","title":"API Declaration and Implementation","text":""},{"location":"02-benchmarks/021-apis/#apis-for-cpu","title":"APIs for CPU","text":"<p>The declaration of APIs for CPUs is provided in\u00a0<code>$SIMULATOR_ROOT/interchiplet/includes/apis_c.h</code>. The implementation of these APIs is compiled into a static library\u00a0<code>$SIMULATOR_ROOT/interchiplet/lib/libinterchiplet_c.a</code>,\u00a0which should be linked to the benchmark.</p> <p>APIs on CPUs are implemented by system calls. System Calls can have a number of arguments. The mapping between APIs and system calls is listed below:</p> API System Call ID <code>launch</code> <code>SYSCALL_LAUNCH</code> <code>waitLaunch</code> <code>SYSCALL_WAITLAUNCH</code> <code>lock</code> <code>SYSCALL_LOCK</code> <code>unlock</code> <code>SYSCALL_UNLOCK</code> <code>barrier</code> <code>SYSCALL_BARRIER</code> <code>sendMessage</code> <code>SYSCALL_REMOTE_WRITE</code> <code>receiveMessage</code> <code>SYSCALL_REMOTE_READ</code>"},{"location":"02-benchmarks/021-apis/#apis-for-cuda","title":"APIs for CUDA","text":"<p>APIs on CUDA platforms are implemented by built-in CUDA APIs. The declaration of these APIs is provided in\u00a0<code>$SIMULATOR_ROOT/interchiplet/includes/apis_cu.h</code>. The implementation of these APIs is provided by the CUDA simulator, like GPGPU-Sim. Hence, when compiling executable files for CUDA platforms, the specified CUDA library should be provided as below:</p> <pre><code># CUDA language target\nCUDA_target: $(CUDA_OBJS)\n    $(NVCC) -L$(SIMULATOR_ROOT)/gpgpu-sim/lib/$(GPGPUSIM_CONFIG) --cudart shared $(CUDA_OBJS) -o $(CUDA_TARGET)\n</code></pre> <p>TODO: A more flexible way to specify the source and the destination address.</p>"},{"location":"03-sync-proto/","title":"Synchronization Protocol","text":"<p>You can find the following topics on this page:</p> <ul> <li>The synchronization protocol between simulation processes.</li> </ul>"},{"location":"03-sync-proto/#list-of-protocol-commands","title":"List of Protocol Commands","text":"<p>Synchronization protocol can be categorized into functional protocol and timing protocol.</p>"},{"location":"03-sync-proto/#functional-protocol-commands","title":"Functional Protocol Commands","text":"<p>The functional protocol performs the functionality of benchmarks correctly, and commands do not care about the execution cycle. It is used in the functional model of simulators. Functional protocol commands and their syntax are listed below:</p> Command Arguments Direction Location Pair with Usage <code>BARRIER</code> <code>&lt;src_x&gt; &lt;src_y&gt; &lt;uid&gt; &lt;count&gt;</code> Up Source -- The thread at the source enters the barrier. <code>LAUNCH</code> <code>&lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt;</code> Up Source <code>WAITLAUNCH</code> The thread at the source requires to execute a task at the destination. <code>LOCK</code> <code>&lt;src_x&gt; &lt;src_y&gt; &lt;uid&gt;</code> Up Source <code>UNLOCK</code> The thread at the source requires to locking the mutex. <code>RECEIVE</code> <code>&lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt;</code> Up Destination <code>SEND</code> Receive data from the source to the destination. <code>RESULT</code> <code>&lt;res_num&gt; [&lt;res_0&gt; &lt;res_1&gt; ...]</code> Down -- -- Response to functional protocol commands with vary-number of results. <code>SEND</code> <code>&lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt;</code> Up Source <code>RECEIVE</code> Send data from the source to the destination. <code>UNLOCK</code> <code>&lt;src_x&gt; &lt;src_y&gt; &lt;uid&gt;</code> Up Source <code>LOCK</code> The thread at the source unlocks the mutex. <code>WAITLAUNCH</code> <code>&lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt;</code> Up Destination <code>LAUNCH</code> The thread at the destiantion waits to launch task. <p>\"Up\" means from simulation process to interchiplet. \"Down\" means from interchiplet to simulation process.</p> <p>Every functional protocol command needs one RESULT command as the response. RESULT commands provide a list of result fields whose number is specified by <code>res_num</code>.</p> <p>As the response to BARRIER, LOCK, UNLOCK, and LAUNCH commands, RESULT commands provide no result. As the response to SEND and RECEIVE commands, RESULT commands should provide the path of the Named Pipe. As the response to WAITLAUNCH commands, RESULT commands should provide the source of LAUNCH commands.</p> <p>TODO: More flexible format for address</p>"},{"location":"03-sync-proto/#timing-protocol-commands","title":"Timing Protocol Commands","text":"<p>The timing protocol synchronizes the execution cycles of simulators. It is used in the timing model of simulators. Timing protocol commands and their syntax are listed below:</p> Command Arguments Direction Location Pair with Usage <code>CYCLE</code> <code>&lt;cycle&gt;</code> Up Any -- Report execution time of simulation processes. <code>READ</code> <code>&lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes&gt; &lt;desc&gt;</code> Up Source <code>WRITE</code> Read transaction request from the source to the destination. <code>SYNC</code> <code>&lt;cycle&gt;</code> Down -- -- Response to timing protocol commands. <code>WRITE</code> <code>&lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes&gt; &lt;desc&gt;</code> Up Destination <code>READ</code> Write transaction request from the source to the destination. <p>As described in the Overview, the sequence to perform the communication between processes has been abstracted as the transaction. Hence, the essential read/write operations to lock flags are abstracted into READ/WRITE commands. READ/WRITE commands can be used for both communication and synchronization, such as barrier, lock, and launch. Therefore, one READ or WRITE command presents a sequence of communication rather than one single package. <code>desc</code> field defines the transaction's behavior.</p> <p>Bit [19:16] presents the category of communication.</p> Bit [19:16] Behavior flag Transaction's behavior <code>0x0</code> Controlled by the bit [15:0] of <code>desc</code>. <code>0x1</code> launch One request package and one acknowledgment package. <code>0x2</code> barrier One request package and one acknowledgment package. Bit [15:0] presents the number of processes when the barrier overflows. <code>0x4</code> lock One request package and one acknowledgment package. <code>0x8</code> unlock One request package and one acknowledgment package. <p>READ/WRITE commands need SYNC commands as the response. SYNC commands provide a cycle to specify the end cycle of transactions.</p> <p>TODO: More flexible format for address</p>"},{"location":"03-sync-proto/#apis-vs-synchronization-protocol","title":"APIs vs. Synchronization Protocol","text":"<p>Each API in benchmarks needs one command from the functional protocol and one from the timing protocol. Some trace-based simulators, like SniperSim, provide separated timing and function models. Hence, the functional protocol should not merge with the timing protocol.</p> Benchmark API Command from functional protocol Command from timing protocol <code>sendMessage</code> <code>SEND</code> <code>WRITE</code> <code>receiveMessage</code> <code>RECEIVE</code> <code>READ</code> <code>barrier</code> <code>BARRIER</code> <code>WRITE</code> with the barrier flag <code>lock</code> <code>LOCK</code> <code>WRITE</code> with the lock flag <code>unlock</code> <code>UNLOCK</code> <code>WRITE</code> with the unlock flag <code>launch</code> <code>LAUNCH</code> <code>WRITE</code> with the launch flag <code>waitLaunch</code> <code>WAITLAUNCH</code> <code>READ</code> with the launch flag <p>The basic flow for APIs is shown below:</p> <pre><code>flowchart TB\n\nA[Start]\nB[Issue one functional protocol command]\nC[Wait RESULT command]\nD[Issue one timing protocol command]\nE[Wait SYNC command]\nF[End]\n\nA--&gt;B--&gt;C--&gt;D--&gt;E--&gt;F</code></pre> <p>It is not necessary to implement the above flow in one single function. For those simulators that provide one separate function model and timing model, functional protocol commands are handled in the function model, and the timing protocol commands are handled in the timing model.</p>"},{"location":"03-sync-proto/030-net-proto/","title":"Interconnection Simulation","text":"<p>LegoSim applies Popnet as the interconnection simulator to provide the latency of each transaction. Popnet simulates the interconnection behavior according to the benchmark file provided by Phase 1. Popnet generates one latency information file, providing the latency of each package.</p> <p>The latency of packages is related to the source-destination address and the network congestion. The source-destination address does not change crossing iterations. The same degree of network congestion leads to similar latency information. Hence, the latency information generated by Phase 2 can be used in Phase 1 of the next iteration.</p> <p>Each pair of WRITE and READ commands generates one transaction in the interconnection. In particular, WRITE commands with LOCK, UNLOCK, and BARRIER descriptors generate transactions in the interconnection without pairing READ commands.</p>"},{"location":"03-sync-proto/030-net-proto/#file-format","title":"File format","text":"<p>LegoSim uses the trace file and the latency information file to communicate with Popnet.</p>"},{"location":"03-sync-proto/030-net-proto/#trace-file-format","title":"Trace file format","text":"<p>The trace file is one text file. Each line presents one transaction in the interconnection, as shown below.</p> <pre><code>&lt;src_cycle&gt; &lt;dst_cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;flit_num&gt; &lt;desc&gt;\n</code></pre> <p>Fields in the trace file are filled by the value from the WRITE and READ commands.</p> Field in trace file Field in WRITE command Field in READ command Description <code>src_cycle</code> <code>cycle</code> Start cycle of the transaction from the source's view. <code>dst_cycle</code> <code>cycle</code> Start cycle of the transaction form the destination's view. <code>src_x</code>, <code>src_y</code> <code>src_x</code>, <code>src_y</code> <code>src_x</code>, <code>src_y</code> Source address. <code>dst_x</code>, <code>dst_y</code> <code>dst_x</code>, <code>dst_y</code> <code>dst_x</code>, <code>dst_y</code> Destination address. <code>flit_num</code> Flit number. \\(\\text{ceil}(nbytes / payload\\#) + 1\\). <code>desc</code> <code>desc</code> <code>desc</code> Behavior of transaction. <p>The trace file is generated by interchiplet. interchiplet always keeps packages in the order of the package injection cycle. For example,</p> <pre><code>2846470 0 0 0 0 1 1251 0\n2847814 0 0 0 1 0 1251 0\n2849309 0 0 0 1 1 1251 0\n2850905 2847725 0 0 0 1 1251 0\n2852501 2849069 0 0 1 0 1251 0\n2854098 2850569 0 0 1 1 1251 0\n2875272 2855527 0 1 0 0 14 0\n2876868 2875644 1 0 0 0 14 0\n2878470 2877240 1 1 0 0 14 0\n</code></pre> <p>TODO: flexible format for address. Flexible format for different kinds of PComps and SComps.</p>"},{"location":"03-sync-proto/030-net-proto/#latency-information-file-format","title":"Latency information file format","text":"<p>The latency information file is also one text file. Each line provides the latency information for one transaction in the interconnection, as shown below.</p> <pre><code>&lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;desc&gt; &lt;lat_num&gt; [&lt;lat_0&gt; &lt;lat_1&gt; ...]\n</code></pre> <p><code>cycle</code> presents the start cycle of one transaction from the source's view as the <code>src_cycle</code> field in the trace file. <code>src_x</code>, <code>src_y</code>, <code>dst_x</code>, and <code>dst_y</code> present the source and destination address as the trace file. <code>desc</code> describes the behavior of the transaction as the trace file.</p> <p>For each transaction, latency information provides the latency of each package related to one transaction. For example, normal communication transactions only provide the latency of one package. BARRIER/LOCK/UNLOCK/LAUNCH transactions provide the latency of one request package and one acknowledge package.</p> <p><code>lat_num</code> presents the number of provided latency values. Each package has two latency values. <code>lat_{2i}</code> and <code>lat_{2i+1}</code> are the latency of the <code>i</code>-th package from the source's and destination's views.</p> Transaction's behavior <code>lat_num</code> <code>lat_0</code> and <code>lat_1</code> <code>lat_2</code> and <code>lat_3</code> Normal 2 Normal transfer package LAUNCH 4 Request package Acknowledge package BARRIER 4 Request package Acknowledge package LOCK 4 Request package Acknowledge package UNLOCK 4 Request package Acknowledge package <p>Popnet does not need to sort packages. interchiplet will reorder packages according to the package injection cycle when loading files. One example of latency information files is shown below:</p> <pre><code>2847106 0 0 0 1 0 2 1250 1255\n2848612 0 0 1 0 0 2 1250 1255\n2850107 0 0 1 1 0 2 1250 1260\n2851703 0 0 0 1 0 2 1250 1255\n2853299 0 0 1 0 0 2 1250 1255\n2854896 0 0 1 1 0 2 1250 1260\n2876066 0 1 0 0 0 2 13 18\n2877662 1 0 0 0 0 2 13 18\n2879259 1 1 0 0 0 2 13 23\n</code></pre> <p>TODO: flexible format for address. Flexible format for different kinds of PComps and SComps.</p>"},{"location":"03-sync-proto/030-net-proto/#sorting-latency-information","title":"Sorting Latency Information","text":"<p>interchiplet needs to rebuild the order of transactions according to the latency information file.</p> <p>Transactions are organized by a two-level structure. The first level is a map of addresses and ordered queues of latency information. The second level is one queue of latency information ordered by cycles.</p> Ordered content Key of map Key for ordering Order of Transaction All latency informations Source addresses Transaction start cycle Order of Launch Latency information of Launch transactions Destination addresses Cycle when the request package arrives the destination Order of Lock and unlock Latency information of Lock/unlock transactions Destination addresses Cycle when the request package arrives the destination"},{"location":"03-sync-proto/030-net-proto/#todo","title":"TODO","text":"<p>The network latency is provided by Phase 2 of the previous iteration. interchiplet will load all delay information before starting the simulation processes in Phase 1. When it receives the paired READ and WRITE commands, it will search for the first delay information message with the same source and destination. The matched delay information message will be dropped after use.</p> <p>There is no implicit guarantee that the number and the order of transactions do not change crossing the iteration. Because the simulation flow is based on iteration, the difference crossing iteration should reduce as the simulation continues.</p> <p>If the network delay from SComps is missing, the network delay only considers the propagation delay, which equals the data amount divided by network bandwidth. In the first iteration, the network delay is determined in the same way.</p>"},{"location":"03-sync-proto/031-communication/","title":"Communication","text":"<p>You can find the following topics on this page:</p> <ul> <li>The sequences of synchronization protocol to handle communication transactions between processes.</li> <li>The algorithm to handle synchronization protocol within interchiplet.</li> <li>The algorithm to calculate the end cycle of one communication transaction.</li> </ul>"},{"location":"03-sync-proto/031-communication/#command-syntax","title":"Command syntax","text":"<pre><code># sendMessage\nSEND &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt;\nWRITE &lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes&gt; &lt;desc&gt;\n\n# receiveMessage\nRECEIVE &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt;\nREAD &lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes&gt; &lt;desc&gt;\n</code></pre> <p><code>src_x</code> and <code>src_y</code> present the source address and <code>dst_x</code> and <code>dst_y</code> present the destination address.</p> <p>The\u00a0<code>cycle</code>\u00a0field in the WRITE command presents the time when the source component starts. The\u00a0<code>cycle</code>\u00a0field in the READ command presents the time when the destination component starts to wait for data to be ready for reading.</p> <p>The <code>nbytes</code> field presents the total byte number of communication. <code>desc</code> describes the transaction behavior.</p> <p>The figure below shows the relationship between arguments of APIs and commands.</p> <pre><code>flowchart TB\n\nsubgraph sendMessage\nA1[__src_x]\nA2[__src_y]\nA3[__dst_x]\nA4[__dst_y]\nA5[__addr]\nA6[__nbyte]\nend\n\nsubgraph SEND command\nB1[src_x]\nB2[src_y]\nB3[dst_x]\nB4[dst_y]\nend\n\nsubgraph WRITE command\nC0[cycle]\nC1[src_x]\nC2[src_y]\nC3[dst_x]\nC4[dst_y]\nC6[nbytes]\nC7[desc]\nend\n\nA1 -.-&gt; B1 -.-&gt; C1\nA2 -.-&gt; B2 -.-&gt; C2\nA3 -.-&gt; B3 -.-&gt; C3\nA4 -.-&gt; B4 -.-&gt; C4\nA6 -.-&gt; C6\n</code></pre> <pre><code>flowchart TB\n\nsubgraph receiveMessage\nD1[__src_x]\nD2[__src_y]\nD3[__dst_x]\nD4[__dst_y]\nD5[__addr]\nD6[__nbyte]\nend\n\nsubgraph RECEIVE command\nE1[src_x]\nE2[src_y]\nE3[dst_x]\nE4[dst_y]\nend\n\nsubgraph READ command\nF0[cycle]\nF1[src_x]\nF2[src_y]\nF3[dst_x]\nF4[dst_y]\nF6[nbytes]\nF7[desc]\nend\n\nD1 -.-&gt; E1 -.-&gt; F1\nD2 -.-&gt; E2 -.-&gt; F2\nD3 -.-&gt; E3 -.-&gt; F3\nD4 -.-&gt; E4 -.-&gt; F4\nD6 -.-&gt; F6\n</code></pre>"},{"location":"03-sync-proto/031-communication/#command-sequence","title":"Command Sequence","text":"<p>One example of the command sequence is shown below:</p> <pre><code>sequenceDiagram\nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant interchiplet\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\n\nactivate SP0\nactivate SP1\n\nNote over SP0,SP1: Example starts\n\nSP0-&gt;&gt;interchiplet: SEND 0 0 0 1\ndeactivate SP0\nactivate interchiplet\nNote over interchiplet: Create Pipe name buffer0_0_0_1.\ninterchiplet-&gt;&gt;SP0: RESULT 1 ../buffer0_0_0_1\ndeactivate interchiplet\n\nSP1-&gt;&gt;interchiplet: RECEIVE 0 0 0 0 1\ndeactivate SP1\nactivate interchiplet\nNote over interchiplet: Reuse Pipe name buffer0_0_0_1.\ninterchiplet-&gt;&gt;SP1: RESULT 1 ../buffer0_0_0_1\ndeactivate interchiplet\n\nSP0-&gt;&gt;SP1: Send data from (0,0) to (0,1) through Named Pipe ../buffer0_0_0_1\n\nSP0-&gt;&gt;interchiplet: WRITE 2578659 0 0 0 1 80000 0\nactivate interchiplet\nNote over interchiplet: Register WRITE command.\ndeactivate interchiplet\n\nSP1-&gt;&gt;interchiplet: READ 2276672 0 0 0 1 80000 0\nactivate interchiplet\nNote over interchiplet: Pair with pending WRITE command.\ninterchiplet-&gt;&gt;SP0: SYNC 2579909\nactivate SP0\ninterchiplet-&gt;&gt;SP1: SYNC 2579914\nactivate SP1\ndeactivate interchiplet\n\nNote over SP0,SP1: Example ends\n\ndeactivate SP0\ndeactivate SP1</code></pre> <p>interchiplet does not pair SEND and RECEIVE commands because the communication is handled by Named Pipes. Named Pipes already provide the functionality to synchronize the source and destination. As shown in the above example, the actual data transfer (5) operates after the RESULT command to Simulator Process 1 (4).</p>"},{"location":"03-sync-proto/031-communication/#handle-send-and-receive-command","title":"Handle SEND and RECEIVE command","text":"<p>The SEND and RECEIVE commands are used to create a Named Pipe for each pair of communication. The SEND command is used at the source, while the RECEIVE command is used at the destination. The name of the Named Pipe is specified by the source and destination address, which is\u00a0<code>buffer{src_x}_{src_y}_{dst_x}_{dst_y}</code>. For example,\u00a0<code>buffer0_0_0_1</code>\u00a0means the Pipe to send data from node (0,0) to node (0,1). If the request pipe does not exist, interchiplet creates one.</p> <p>In the above example, Simulator Process 0 wants to send data to Simulator Process 1. interchiplet receives the SEND command (1) from Simulator Process 0 and creates the Pipe file. Then, interchiplet sends a RESULT command (2) to Simulator Process 0 with the name of the Pipe file. interchiplet directly issues the RESULT command (4) to Simulator Process 1 after receiving the RECEIVE command (3) from Simulation Process 1 because the required Pipe file already exists.</p>"},{"location":"03-sync-proto/031-communication/#handle-read-and-write-command","title":"Handle READ and WRITE command","text":"<p>The\u00a0<code>cycle</code>\u00a0field in the WRITE command presents the time when the source component starts to send data, referenced as <code>src_cycle</code>. The\u00a0<code>cycle</code>\u00a0field in the READ command presents the time when the destination component starts to wait for data to be ready for reading, referenced as <code>dst_cycle</code>.</p> <p>The SYNC command after one WRITE command means the source has finished sending data. The SYNC command after one READ command means the destination has finished reading data. The task or flow in the source and destination can continue after receiving the SYNC command. The execution cycle of the source and destination should be adjusted to the value specified in the\u00a0cycle\u00a0field of SYNC commands.</p> <p>In the above example, Simulator Process 0 sends the WRITE command (6) to interchiplet with <code>src_cycle</code>, and Simulator Process 1 sends the READ command (7) to interchiplet with <code>dst_cycle</code>. After pairing the WRITE and READ commands with the same source address, the same destination address, and the same number of bytes, interchiplet sends SYNC commands to Simulator Process 0 (8) and Simulator Process 1 (9) with the end cycle of the transaction.</p> <p>Latency information provides two latency values (<code>lat_0</code> and <code>lat_1</code>) for one communication transaction:</p> <ul> <li><code>lat_0</code> means the package latency from the source's view, including propagate latency.</li> <li><code>lat_1</code> means the package latency from the destination's view, including the propagate latency and the transmission latency.</li> </ul> <p>The package is injected at <code>src_cycle</code>. Hence, the package arrives at the destination at <code>src_cycle + lat_1</code>.</p> <p>The timing sequence is shown below:</p> <pre><code>sequenceDiagram \nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\n\nnote left of SP0: src_cycle\nSP0-&gt;&gt;SP1: \nnote right of SP1: src_cycle + lat_1</code></pre> <p>The destination does not need further blocking if <code>dst_cycle</code> is later than <code>src_cycle + lat_1</code>. Otherwise, the destination needs to block till <code>src_cycle + lat_1</code>.</p> <p>In summary,</p> <ul> <li>The <code>cycle</code> of the SYNC command to the WRITE command is <code>src_cycle + lat_0</code>.</li> <li>The <code>cycle</code> of the SYNC command to the READ command is <code>max(src_cycle + lat_1, dst_cycle)</code>.</li> </ul> <p>TODO: Complex descriptor of communication transactions.</p>"},{"location":"03-sync-proto/032-barrier/","title":"Barrier","text":"<p>You can find the following topics on this page:</p> <ul> <li>The sequences of synchronization protocol to handle barrier transactions between processes.</li> <li>The algorithm to handle synchronization protocol within interchiplet.</li> <li>The algorithm to calculate the end cycle of one barrier transaction.</li> </ul>"},{"location":"03-sync-proto/032-barrier/#command-syntax","title":"Command syntax","text":"<pre><code># barrier\nBARRIER &lt;src_x&gt; &lt;src_y&gt; &lt;uid&gt; &lt;count&gt;\nWRITE &lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes=1&gt; &lt;desc=0x20000+count&gt;\n</code></pre> <p><code>src_x</code> and <code>src_y</code> present the source address of the process that enters the barrier. <code>uid</code> specifies the unique ID of the barrier. <code>count</code> specifies the number of processes that enter the barrier when the barrier overflows. Non-zero <code>count</code> always overrides the number of the barrier.</p> <p>The\u00a0<code>cycle</code>\u00a0field in the WRITE command presents the time when the process enters the barrier.</p> <p>The figure below shows the relationship between arguments of APIs and commands.</p> <pre><code>flowchart TB\n\nsubgraph barrier\nA1[__src_x]\nA2[__src_y]\nA3[__uid]\nA4[__count]\nend\n\nsubgraph BARRIER command\nB1[src_x]\nB2[src_y]\nB3[uid]\nB4[count]\nend\n\nsubgraph WRITE command\nC0[cycle]\nC1[src_x]\nC2[src_y]\nC3[dst_x]\nC4[dst_y=0]\nC5[nbytes=1]\nC6[desc=0x20000+count]\nend\n\nA1 -.-&gt; B1 -.-&gt; C1\nA2 -.-&gt; B2 -.-&gt; C2\nA3 -.-&gt; B3 -.-&gt; C3\nA4 -.-&gt; B4 -.-&gt; C6\n</code></pre>"},{"location":"03-sync-proto/032-barrier/#command-sequence","title":"Command Sequence","text":"<p>One example of the command sequence is shown below:</p> <pre><code>sequenceDiagram\nautonumber\n\nparticipant interchiplet\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\nparticipant SP2 as Simulator&lt;br/&gt;Process 2\nparticipant SP3 as Simulator&lt;br/&gt;Process 3\n\nactivate SP0\nactivate SP1\nactivate SP2\nactivate SP3\n\nNote over SP0,SP3: Example starts\n\nSP1-&gt;&gt;interchiplet: BARRIER 0 1 255 4\ndeactivate SP1\nactivate interchiplet\nNote over interchiplet: Register BARRIER command.\ndeactivate interchiplet\n\nSP0-&gt;&gt;interchiplet: BARRIER 0 0 255 4\ndeactivate SP0\nactivate interchiplet\nNote over interchiplet: Register BARRIER command.\ndeactivate interchiplet\n\nSP3-&gt;&gt;interchiplet: BARRIER 1 1 255 4\ndeactivate SP3\nactivate interchiplet\nNote over interchiplet: Register BARRIER command.\ndeactivate interchiplet\n\nSP2-&gt;&gt;interchiplet: BARRIER 1 0 255 4\ndeactivate SP2\nactivate interchiplet\nNote over interchiplet: 1. Register BARRIER command.&lt;br/&gt;2. Barrier overflows.&lt;br/&gt;3. Send RESULT command to&lt;br/&gt;each Simulator Process.\ninterchiplet-&gt;&gt;SP1: RESULT 0\ninterchiplet-&gt;&gt;SP0: RESULT 0\ninterchiplet-&gt;&gt;SP3: RESULT 0\ninterchiplet-&gt;&gt;SP2: RESULT 0\ndeactivate interchiplet\n\nSP1-&gt;&gt;interchiplet: WRITE 2305339 0 1 255 0 1 131076\nactivate interchiplet\nNote over interchiplet: Register WRITE command&lt;br&gt;with the barrier flag.\ndeactivate interchiplet\n\nSP0-&gt;&gt;interchiplet: WRITE 2410745 0 0 255 0 1 131076\nactivate interchiplet\nNote over interchiplet: Register WRITE command&lt;br&gt;with the barrier flag.\ndeactivate interchiplet\n\nSP3-&gt;&gt;interchiplet: WRITE 2330513 1 1 255 0 1 131076\nactivate interchiplet\nNote over interchiplet: Register WRITE command&lt;br&gt;with the barrier flag.\ndeactivate interchiplet\n\nSP2-&gt;&gt;interchiplet: WRITE 2331564 1 0 255 0 1 131076\nactivate interchiplet\nNote over interchiplet: 1. Register BARRIER command&lt;br/&gt;with the barrier flag.&lt;br/&gt;2. Barrier overflows and&lt;br&gt;calculate barrier overflow time.&lt;br/&gt;3. Send SYNC command to&lt;br/&gt;each Simulator Process.\ninterchiplet-&gt;&gt;SP1: SYNC 2411664\nactivate SP1\ninterchiplet-&gt;&gt;SP0: SYNC 2411659\nactivate SP0\ninterchiplet-&gt;&gt;SP3: SYNC 2411669\nactivate SP3\ninterchiplet-&gt;&gt;SP2: SYNC 2411664\nactivate SP2\ndeactivate interchiplet\n\nNote over SP0,SP3: Example ends\n\ndeactivate SP0\ndeactivate SP1\ndeactivate SP2\ndeactivate SP3</code></pre>"},{"location":"03-sync-proto/032-barrier/#handle-barrier-command","title":"Handle BARRIER Command","text":"<p>interchiplet emulates the function of the barrier. The following diagram shows the flow to handle one BARRIER command.</p> <pre><code>flowchart TB\n\nA(Start)\nB[Register BARRIER command]\nC{Check whether&lt;br/&gt;barrier overflows}\nE[Send RESULT commands&lt;br/&gt;to each pending&lt;br/&gt;BARRIER command]\nZ(End)\n\nA--&gt;B--&gt;C--\"Yes\"--&gt;E--&gt;Z\nC--\"No\"--&gt;Z</code></pre> <p>interchiplet response one RESULT command without any result for each process that enters the barrier when the barrier overflows.</p> <p>The order of BARRIER does not change by the timing information.</p>"},{"location":"03-sync-proto/032-barrier/#handle-write-command-with-the-barrier-flag","title":"Handle WRITE Command with the Barrier Flag","text":"<p>In a realistic system, when a process enters a barrier, the process sends one request to a controller, like a mailbox. Then, the process blocks till it receives the acknowledgment from the controller. The location of the controller is configured in Popnet.</p> <p>The\u00a0<code>cycle</code>\u00a0field in the WRITE command with the barrier flag presents the time when the source component sends the barrier requirement to the controller in the system, referenced as <code>src_cycle</code>. WRITE commands with the barrier flag do not need to pair with READ commands.</p> <p>The SYNC command after one WRITE command with the barrier flag means the source has received acknowledgment. The task or flow in the source can continue after receiving the SYNC command. The execution cycle of the source should be adjusted to the value specified in the\u00a0cycle\u00a0field of SYNC commands.</p> <p>Latency information provides four latency values (<code>lat_0</code>, <code>lat_1</code>, <code>lat_2</code>, and <code>lat_3</code>) for one barrier transaction:</p> From the source's view From the destination's view Request package <code>lat_0</code> <code>lat_1</code> Acknowledgement package <code>lat_2</code> <code>lat_3</code> <p>The request package is injected at <code>src_cycle</code>. Hence, the request package arrives at the controller at <code>src_cycle + lat_1</code>. Then, when the barrier overflows, the controller sends one acknowledgment package to each source component.</p> <p>The timing sequence is shown below:</p> <pre><code>sequenceDiagram \nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\nparticipant SP2 as Simulator&lt;br/&gt;Process 2\n\nnote right of SP2: src_cycle[2]\nSP2-&gt;&gt;SP0: \nnote left of SP0: src_cycle[2] + lat_1[2]\n\nnote right of SP1: src_cycle[1]\nSP1-&gt;&gt;SP0: \nnote left of SP0: src_cycle[1] + lat_1[1]\n\nSP0-&gt;&gt;SP2: \nnote right of SP2: src_cycle[1] + lat_1[1] + lat_3[2]\n\nSP0-&gt;&gt;SP1: \nnote right of SP1: src_cycle[1] + lat_1[1] + lat_3[1]</code></pre> <p>In summary,</p> <ul> <li>The barrier overflow time is  <code>max(src_cycle[i] + lat_1[i])</code>.</li> <li>The <code>cycle</code> of the SYNC command to the WRITE command with the barrier flag is <code>barrier overflow time + lat_3</code>.</li> </ul>"},{"location":"03-sync-proto/033-lock/","title":"Lock and Unlock","text":"<p>You can find the following topics on this page:</p> <ul> <li>The sequences of synchronization protocol to handle lock/unlock transactions between processes.</li> <li>The algorithm to handle synchronization protocol within interchiplet.</li> <li>The algorithm to calculate the end cycle of one lock/unlock transaction.</li> </ul>"},{"location":"03-sync-proto/033-lock/#command-syntax","title":"Command syntax","text":"<pre><code># lock\nLOCK &lt;src_x&gt; &lt;src_y&gt; &lt;uid&gt;\nWRITE &lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes=1&gt; &lt;desc=0x40000&gt;\n\n# unlock\nUNLOCK &lt;src_x&gt; &lt;src_y&gt; &lt;uid&gt;\nWRITE &lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes=1&gt; &lt;desc=0x80000&gt;\n</code></pre> <p><code>src_x</code> and <code>src_y</code> present the source address of the process that locks or unlocks the mutex. <code>uid</code> specifies the unique ID of the mutex.</p> <p>The\u00a0<code>cycle</code>\u00a0field in the WRITE command presents the time when the process locks or unlocks the mutex.</p> <pre><code>flowchart TB\n\nsubgraph lock\nA1[__src_x]\nA2[__src_y]\nA3[__uid]\nend\n\nsubgraph LOCK command\nB1[src_x]\nB2[src_y]\nB3[dst_x]\nB4[dst_y=0]\nend\n\nsubgraph WRITE command\nC0[cycle]\nC1[src_x]\nC2[src_y]\nC3[dst_x]\nC4[dst_y=0]\nC6[nbytes=1]\nC7[desc=0x80000]\nend\n\nA1 -.-&gt; B1 -.-&gt; C1\nA2 -.-&gt; B2 -.-&gt; C2\nA3 -.-&gt; B3 -.-&gt; C3\n</code></pre> <pre><code>flowchart TB\n\nsubgraph unlock\nD1[__src_x]\nD2[__src_y]\nD3[__uid]\nend\n\nsubgraph UNLOCK command\nE1[src_x]\nE2[src_y]\nE3[dst_x]\nE4[dst_y=0]\nend\n\nsubgraph READ command\nF0[cycle]\nF1[src_x]\nF2[src_y]\nF3[dst_x]\nF4[dst_y=0]\nF6[nbytes=1]\nF7[desc=0x40000]\nend\n\nD1 -.-&gt; E1 -.-&gt; F1\nD2 -.-&gt; E2 -.-&gt; F2\nD3 -.-&gt; E3 -.-&gt; F3\n</code></pre>"},{"location":"03-sync-proto/033-lock/#command-sequence","title":"Command Sequence","text":""},{"location":"03-sync-proto/033-lock/#handle-lock-and-unlock-command","title":"Handle LOCK and UNLOCK Command","text":"<p>The LOCK and UNLOCK commands are used to lock one specified mutex. When one mutex is locked by one process, other processes cannot lock the mutex until the mutex is released. <code>uid</code> specifies the unique ID of the mutex.</p> <p>The rules to handle LOCK and UNLOCK commands are listed below:</p> <ul> <li>When interchiplet receives one LOCK command,<ul> <li>If the specified mutex is locked, check the source of the LOCK command and the source that locked the specified mutex.</li> <li>If the source of the LOCK command is the same as the source that locked the mutex, ignore the LOCK command. interchiplet returns one RESULT command without any result.</li> <li>Otherwise, interchiplet registers the LOCK command.</li> <li>Otherwise, interchiplet locks the mutex and returns one RESULT command without any result.</li> </ul> </li> <li>When interchiplet receives one UNLOCK command,<ul> <li>If the specified mutex is locked, interchiplet unlocks the mutex and returns one RESULT command without any result.<ul> <li>If there are pending LOCK commands, select the first LOCK pending command to lock the mutex. interchiplet returns one RESULT command without any result to the selected LOCK command.</li> </ul> </li> <li>Otherwise, ignore the UNLOCK command. interchiplet returns one RESULT command without any result.</li> </ul> </li> </ul> <p>One example of the LOCK and UNLOCK commands is shown below.</p> <pre><code>sequenceDiagram\nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant interchiplet\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\n\nactivate SP0\nactivate SP1\n\nNote over SP0,SP1: Example starts\n\nSP1-&gt;&gt;interchiplet: LOCK 0 1 255\ndeactivate SP1\nactivate interchiplet\n\nNote over interchiplet: Lock the mutex.\n\ninterchiplet-&gt;&gt;SP1: RESULT 0\ndeactivate interchiplet\nactivate SP1\n\nSP0-&gt;&gt;interchiplet: LOCK 0 0 255\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Register LOCK command.\n\ndeactivate interchiplet\n\nSP1-&gt;&gt;interchiplet: UNLOCK 0 1 255\ndeactivate SP1\nactivate interchiplet\n\nNote over interchiplet: Unlock the mutex.\n\ninterchiplet-&gt;&gt;SP1: RESULT 0\nactivate SP1\n\nNote over interchiplet: Lock the mutex by one pending LOCK command.\n\ninterchiplet-&gt;&gt;SP0: RESULT 0\ndeactivate interchiplet\nactivate SP0\n\nSP0-&gt;&gt;interchiplet: UNLOCK 0 0 255\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Unlock the mutex.\n\ninterchiplet-&gt;&gt;SP0: RESULT 0\ndeactivate interchiplet\nactivate SP0\n\nSP0-&gt;&gt;interchiplet: LOCK 0 0 255\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Lock the mutex.\n\ninterchiplet-&gt;&gt;SP0: RESULT 0\nactivate SP0\ndeactivate interchiplet\n\nSP0-&gt;&gt;interchiplet: UNLOCK 0 0 255\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Unlock the mutex.\n\ninterchiplet-&gt;&gt;SP0: RESULT 0\nactivate SP0\ndeactivate interchiplet\n\nNote over SP0,SP1: Example ends\n\ndeactivate SP0\ndeactivate SP1</code></pre> <p>Simulator Process 0 and Simulator Process 1 require the mutex 255. Simulator Process 1 locks the mutex first when interchiplet receives the LOCK command (1). Then, Simulator Process 0 requires the mutex by the LOCK command (3). Simulator Process 0 blocks until Simulator Process 1 releases the mutex by the UNLOCK command (4). Then, Simulator Process 0 blocks the mutex 255 twice.</p> <p>With valid timing information, the order to lock the mutex is specified by the timing information, as bold sentences below.</p> <ul> <li>When interchiplet receives one LOCK command,<ul> <li>If the specified mutex is locked, check the source of the LOCK command and the source that locked the specified mutex.<ul> <li>If the source of the LOCK command is the same as the source that locked the mutex, ignore the LOCK command. interchiplet returns one RESULT command without any result.</li> <li>Otherwise, interchiplet registers the LOCK command.</li> </ul> </li> <li>Otherwise, check the source of the LOCK command with the order specified by timing information.<ul> <li>If the source of the LOCK command matches the order specified by timing information, interchiplet locks the mutex and returns one RESULT command without any result.</li> <li>Otherwise, interchiplet registers the LOCK command.</li> </ul> </li> </ul> </li> <li>When interchiplet receives one UNLOCK command,<ul> <li>If the specified mutex is locked, interchiplet unlocks the mutex and returns one RESULT command without any result.<ul> <li>If there are pending LOCK commands, check whether the next source that lock the mutex exists in the pending LOCK commands, according to the timing information.<ul> <li>If the command exists, select the matched LOCK pending command to lock the mutex. interchiplet returns one RESULT command without any result to the selected LOCK command.</li> <li>Otherwise, do nothing.</li> </ul> </li> </ul> </li> <li>Otherwise, ignore the UNLOCK command. interchiplet returns one RESULT command without any result.</li> </ul> </li> </ul> <p>As shown in the figure below, Simulator Process 0 locks the mutex first. Then Simulator Process 1 locks the mutex after Simulator Process 0 unlocks the mutex. At last, Simulator Process 0 locks the mutex again.</p> <pre><code>sequenceDiagram\nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant interchiplet\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\n\nactivate SP0\nactivate SP1\n\nNote over SP0,SP1: Example starts\n\nSP1-&gt;&gt;interchiplet: LOCK 0 1 255\ndeactivate SP1\nactivate interchiplet\n\nNote over interchiplet: Register LOCK command because order mismatches.\n\ndeactivate interchiplet\n\nSP0-&gt;&gt;interchiplet: LOCK 0 0 255\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Lock the mutex.\n\ninterchiplet-&gt;&gt;SP0: RESULT 0\ndeactivate interchiplet\nactivate SP0\n\nSP0-&gt;&gt;interchiplet: UNLOCK 0 0 255\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Unlock the mutex.\n\ninterchiplet-&gt;&gt;SP0: RESULT 0\nactivate SP0\n\nNote over interchiplet: Lock the mutex by one pending LOCK command&lt;br&gt;matching the order.\n\ninterchiplet-&gt;&gt;SP1: RESULT 0\ndeactivate interchiplet\nactivate SP1\n\nSP0-&gt;&gt;interchiplet: LOCK 0 0 255\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Register LOCK command.\n\ndeactivate interchiplet\n\nSP1-&gt;&gt;interchiplet: UNLOCK 0 1 255\ndeactivate SP1\nactivate interchiplet\n\nNote over interchiplet: Unlock the mutex.\n\ninterchiplet-&gt;&gt;SP1: RESULT 0\nactivate SP1\n\nNote over interchiplet: Lock the mutex by one pending LOCK command&lt;br&gt;matching the order.\n\ninterchiplet-&gt;&gt;SP0: RESULT 0\nactivate SP0\ndeactivate interchiplet\n\nSP0-&gt;&gt;interchiplet: UNLOCK 0 0 255\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Unlock the mutex.\n\ninterchiplet-&gt;&gt;SP0: RESULT 0\nactivate SP0\ndeactivate interchiplet\n\nNote over SP0,SP1: Example ends\n\ndeactivate SP0\ndeactivate SP1</code></pre>"},{"location":"03-sync-proto/033-lock/#handle-write-command-with-the-lock-and-unlock-flag","title":"Handle WRITE Command with the Lock and Unlock Flag","text":"<p>Similar to barrier transactions, when a process requires/releases one mutex, the process sends one request to a controller, like a mailbox. The location of the controller is configured in Popnet.</p> <p>The\u00a0<code>cycle</code>\u00a0field in the WRITE command with the lock/unlock flag presents the time when the source component sends the lock/unlock requirement to the destination, referenced as <code>src_cycle</code>. WRITE commands with the lock/unlock flag do not need to pair with READ commands.</p> <p>The SYNC command after one WRITE command with the lock/unlock flag means the source has received the acknowledgment. The task or flow in the source can continue after receiving the SYNC command. The execution cycle of the source should be adjusted to the value specified in the\u00a0cycle\u00a0field of SYNC commands.</p> <p>Latency information provides four latency values (<code>lat_0</code>, <code>lat_1</code>, <code>lat_2</code>, and <code>lat_3</code>) for one lock/unlock transaction as one barrier transaction.</p> <p>The request package is injected at <code>src_cycle</code>. Hence, the request package arrives at the controller at <code>src_cycle + lat_1</code>. If the mutex is not locked by <code>src_cycle + lat_1</code>, the controller sends the acknowledgment to the source. <code>dst_cycle</code> presents the cycle when the mutex is released.</p> <p>The timing sequence of lock and unlock transactions is similar to the timing sequence of launch transactions. In summary,</p> <ul> <li>The <code>cycle</code> of the SYNC command to the WRITE command is <code>max(src_cycle + lat_1, dst_cycle) + lat_3</code>.</li> <li>The <code>cycle</code> of the SYNC command to the READ command is <code>max(src_cycle + lat_1, dst_cycle) + lat_2</code>.</li> </ul>"},{"location":"03-sync-proto/034-launch/","title":"Launch","text":"<p>You can find the following topics on this page:</p> <ul> <li>The sequences of synchronization protocol to handle launch transactions between processes.</li> <li>The algorithm to handle synchronization protocol within interchiplet.</li> <li>The algorithm to calculate the end cycle of one launch transaction.</li> </ul>"},{"location":"03-sync-proto/034-launch/#launch-and-waitlaunch-command","title":"LAUNCH and WAITLAUNCH command","text":"<p>In the general program modeling for a heterogeneous system, CPUs take the role as the master and send LAUNCH commands to other computing resources, like GPUs and NPUs, to execute tasks. Computing resources remain idle until they receive LAUNCH commands.</p> <p>Masters send LAUNCH commands with specified sources and destinations. Meanwhile, computing resources send WAITLAUNCH commands with the specified destinations but unknown sources (presented by -1,-1). interchiplet pairs one LAUNCH command and one WAITLAUNCH command with the same destination. Then, interchiplet sends one RESULT command without any result field to the master and one RESULT command with the source address to the computing resources.</p> <pre><code># launch\nLAUNCH &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt;\nWRITE &lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes=1&gt; &lt;desc=0x10000&gt;\n\n# waitLaunch\nWAITLAUNCH &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt;\nWRITE &lt;cycle&gt; &lt;src_x&gt; &lt;src_y&gt; &lt;dst_x&gt; &lt;dst_y&gt; &lt;nbytes=1&gt; &lt;desc=0x10000&gt;\n</code></pre> <p><code>src_x</code> and <code>src_y</code> present the master address and <code>dst_x</code> and <code>dst_y</code> present the slave address.</p> <p>The\u00a0<code>cycle</code>\u00a0field in the WRITE command presents the time when the master component starts the launch request. The\u00a0<code>cycle</code>\u00a0field in the READ command presents the time when the destination component starts to wait for any launch request.</p> <p>The figure below shows the relationship between arguments of APIs and commands.</p> <pre><code>flowchart TB\n\nsubgraph launch\nA1[__src_x]\nA2[__src_y]\nA3[__dst_x]\nA4[__dst_y]\nend\n\nsubgraph LAUNCH command\nB1[src_x]\nB2[src_y]\nB3[dst_x]\nB4[dst_y]\nend\n\nsubgraph WRITE command\nC0[cycle]\nC1[src_x]\nC2[src_y]\nC3[dst_x]\nC4[dst_y]\nC6[nbytes]\nC7[desc]\nend\n\nA1 -.-&gt; B1 -.-&gt; C1\nA2 -.-&gt; B2 -.-&gt; C2\nA3 -.-&gt; B3 -.-&gt; C3\nA4 -.-&gt; B4 -.-&gt; C4\n</code></pre> <pre><code>flowchart TB\n\nsubgraph waitLaunch\nD1[__src_x]\nD2[__src_y]\nD3[__dst_x]\nD4[__dst_y]\nend\n\nsubgraph WAITLAUNCH command\nE1[src_x]\nE2[src_y]\nE3[dst_x]\nE4[dst_y]\nend\n\nsubgraph RESULT command\nG1[src_x]\nG2[src_y]\nend\n\nsubgraph READ command\nF0[cycle]\nF1[src_x]\nF2[src_y]\nF3[dst_x]\nF4[dst_y]\nF6[nbytes]\nF7[desc]\nend\n\nG1 -.-&gt; D1 -.-&gt; E1 -.-&gt; F1\nG2 -.-&gt; D2 -.-&gt; E2 -.-&gt; F2\nD3 -.-&gt; E3 -.-&gt; F3\nD4 -.-&gt; E4 -.-&gt; F4\n</code></pre>"},{"location":"03-sync-proto/034-launch/#command-sequence","title":"Command Sequence","text":"<p>One example of the command sequence is shown below:</p> <pre><code>sequenceDiagram\nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant interchiplet\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\n\nactivate SP0\nactivate SP1\n\nNote over SP0,SP1: Example starts\nNote over SP0: Execute task\n\nSP0-&gt;&gt;interchiplet: WAITLAUNCH -1 -1 0 0\ndeactivate SP0\nactivate interchiplet\nNote over interchiplet: Register WAITLAUNCH command.\ndeactivate interchiplet\n\nSP1-&gt;&gt;interchiplet: LAUNCH 0 1 0 0\ndeactivate SP1\nactivate interchiplet\nNote over interchiplet: Pair with pending WAITLAUNCH command.\ninterchiplet-&gt;&gt;SP0: RESULT 2 0 1\ninterchiplet-&gt;&gt;SP1: RESULT 0\ndeactivate interchiplet\n\nSP0-&gt;&gt;interchiplet: READ 2276710 0 1 0 0 1 65536\nactivate interchiplet\nNote over interchiplet: Register READ command with the launch flag.\ndeactivate interchiplet\n\nSP1-&gt;&gt;interchiplet: WRITE 2305144 0 1 0 0 1 65536\nactivate interchiplet\nNote over interchiplet: Pair with pending READ command with the launch flag.\ninterchiplet-&gt;&gt;SP0: SYNC 2305146\nactivate SP0\ninterchiplet-&gt;&gt;SP1: SYNC 2305146\nactivate SP1\ndeactivate interchiplet\n\nNote over SP0: Execute task\nNote over SP0,SP1: Example ends\n\ndeactivate SP0\ndeactivate SP1</code></pre>"},{"location":"03-sync-proto/034-launch/#handle-launch-and-waitlaunch-command","title":"Handle LAUNCH and WAITLAUNCH Command","text":"<p>interchiplet pairs LAUNCH and WAITLAUNCH commands. If there is no latency information to reference, one WAITLAUNCH command should be paired with the first LAUNCH command with the same destination. Otherwise, the WAITLAUNCH command should be paired with the LAUNCH command specified by the latency information.</p> <p>The RESULT command to the WAITLAUNCH command also provides the source address of the paired LAUNCH command.</p> <pre><code>RESULT 2 &lt;src_x&gt; &lt;src_y&gt;\n</code></pre> <p>In the above example, Simulator Process 0 is the computing resources controlled by Simulator Process 1. interchiplet pairs the WAITLAUNCH command (1) with the LAUNCH command (2) and sends RESULT commands to Simulator Process 0 (3) and Simulator Process 1 (4).</p> <p>With valid timing information, the WAITLAUNCH command should pair with the specified LAUNCH command. The same scenario results in different timing sequences, as shown below.</p> <pre><code>sequenceDiagram\nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant interchiplet\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\nparticipant SP2 as Simulator&lt;br/&gt;Process 2\n\nactivate SP0\nactivate SP1\nactivate SP2\n\nNote over SP0,SP2: Example starts\nNote over SP0: Execute task\n\nSP0-&gt;&gt;interchiplet: WAITLAUNCH -1 -1 0 0\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Register WAITLAUNCH command.\n\ndeactivate interchiplet\n\nSP1-&gt;&gt;interchiplet: LAUNCH 0 1 0 0\ndeactivate SP1\nactivate interchiplet\n\nNote over interchiplet: Register LAUNCH command because order mismatches.\n\ndeactivate interchiplet\n\nSP2-&gt;&gt;interchiplet: LAUNCH 1 0 0 0\ndeactivate SP2\nactivate interchiplet\n\nNote over interchiplet: Pair with pending WAITLAUNCH command.\n\ninterchiplet-&gt;&gt;SP0: RESULT 2 1 0\nactivate SP0\ninterchiplet-&gt;&gt;SP2: RESULT 0\nactivate SP2\ndeactivate interchiplet\n\nNote over SP0: Execute task\n\nSP0-&gt;&gt;interchiplet: WAITLAUNCH -1 -1 0 0\ndeactivate SP0\nactivate interchiplet\n\nNote over interchiplet: Pair with pending LAUNCH command.\n\ninterchiplet-&gt;&gt;SP0: RESULT 2 0 1\nactivate SP0\ninterchiplet-&gt;&gt;SP1: RESULT 0\nactivate SP1\ndeactivate interchiplet\n\nNote over SP0: Execute task\nNote over SP0,SP2: Example ends\n\ndeactivate SP0\ndeactivate SP1\ndeactivate SP2</code></pre> <p>According to the timing information, the WAITLAUNCH command (1) pairs with the LAUNCH command (3) from Simulator Process 2. Then, the second WAITLAUNCH command (6) pairs with the LAUNCH command (2).</p>"},{"location":"03-sync-proto/034-launch/#handle-read-and-write-command","title":"Handle READ and WRITE command","text":"<p>The\u00a0<code>cycle</code>\u00a0field in the WRITE command with the launch flag presents the time when the source component sends the launch requirement to the destination, referenced as <code>src_cycle</code>. The\u00a0<code>cycle</code>\u00a0field in the READ command presents the time when the destination component starts to wait for launch, referenced as <code>dst_cycle</code>.</p> <p>The SYNC command after one WRITE command with the barrier flag means the source has received the acknowledgment. The SYNC command after one READ command means the destination has sent the acknowledgment. The task or flow in the source and destination can continue after receiving the SYNC command. The execution cycle of the source and destination should be adjusted to the value specified in the\u00a0cycle\u00a0field of SYNC commands.</p> <p>Latency information provides four latency values (<code>lat_0</code>, <code>lat_1</code>, <code>lat_2</code>, and <code>lat_3</code>) for one launch transaction as one barrier transaction.</p> <p>The request package is injected at <code>src_cycle</code>. Hence, the request package arrives at the controller at <code>src_cycle + lat_1</code>. Then, when the destination is waiting to launch (<code>dst_cycle</code>), the destination sends back the acknowledgment to the source.</p> <p>If <code>dst_cycle</code> is earlier than <code>src_cycle</code>, the timing sequence is shown below:</p> <pre><code>sequenceDiagram\nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\n\nnote left of SP0: src_cycle\nSP0-&gt;&gt;SP1: \nnote right of SP1: src_cycle + lat_1\n\nSP1-&gt;&gt;SP0: \nnote left of SP0: src_cycle + lat_1 + lat_3</code></pre> <p>If <code>dst_cycle</code> is later than <code>src_cycle</code>, the timing sequence is shown below:</p> <pre><code>sequenceDiagram\nautonumber\n\nparticipant SP0 as Simulator&lt;br/&gt;Process 0\nparticipant SP1 as Simulator&lt;br/&gt;Process 1\n\nnote left of SP0: src_cycle\nSP0-&gt;&gt;SP1: \nnote right of SP1: src_cycle + lat_1\n\nnote right of SP1: dst_cycle\nSP1-&gt;&gt;SP0: \nnote left of SP0: dst_cycle + lat_3</code></pre> <p>In summary,</p> <ul> <li>The <code>cycle</code> of the SYNC command to the WRITE command is <code>max(src_cycle + lat_1, dst_cycle) + lat_3</code>.</li> <li>The <code>cycle</code> of the SYNC command to the READ command is <code>max(src_cycle + lat_1, dst_cycle) + lat_2</code>.</li> </ul>"},{"location":"03-sync-proto/035-cycle/","title":"Cycle","text":"<pre><code>CYCLE &lt;cycle&gt;\n</code></pre> <p>CYCLE command reports the execution cycle of one simulator process to interchiplet. This command does not need any response at this time.</p> <p>After receiving a CYCLE command, one sub-thread updates the execution cycle with the value provided by the CYCLE command if the new execution cycle is greater than the recorded execution cycle. At last, the maximum execution cycles recorded by all CYCLE commands are reported as the total execution cycle.</p> <p>TODO: Use the cycle command to build up period synchronization.</p>"},{"location":"04-import-sim/","title":"Importing Simulators","text":"<p>You can learn the following topics from this page:</p> <ul> <li>How to import a new simulator?</li> <li>Function and APIs provided for imported simulators.</li> </ul>"},{"location":"04-import-sim/#the-tasks-to-import-a-new-simulator","title":"The tasks to import a new simulator","text":"<ol> <li>Provide an implementation of APIs in benchmarks. See\u00a0Benchmark\u00a0for the API list.</li> </ol> <p>For example, APIs may implemented by system calls in one CPU simulator. Meanwhile, APIs may implemented by CUDA APIs or CUDA kernals in one GPGPU simulator.</p> <p>See apis_c.hpp and apis_cu.hpp as examples.</p> <ol> <li> <p>Find out one method to change the simulation cycle of the new simulator.</p> <p>For example, there is one global simulation cycle in GPGPUSim and GM5, which can be changed directly. However, in SniperSim, one sleep pseudo-instruction should be injected into the trace to delay the simulation cycle.</p> </li> <li> <p>Implement synchronization protocol.</p> <p>The way to send and receive protocol commands in one simulator depends on how the simulator is implemented. Please check below for details.</p> </li> </ol>"},{"location":"04-import-sim/#cycle-driven-simulator","title":"Cycle-driven Simulator","text":"<p>Cycle-driven simulators are driven by a loop in the simulation cycle. In each iteration, the behavior of hardware in one cycle is emulated. In every iteration, both the functional and timing models are executed.</p> <p>The figure below shows the abstracted model for one iteration in cycle-driven simulators.</p> <pre><code>flowchart TB\n\nA(Start)\nB[Simulator execution]\nC[Issue functional command]\nD[Wait for RESULT command]\nE[Issue timing command]\nF[Wait for SYNC command]\nG[Adjust simulation cycle]\nH[Simulator execution]\nZ(End)\n\nA--&gt;B--&gt;C--&gt;D--&gt;E--&gt;F--&gt;H--&gt;G--&gt;Z</code></pre> <p>Commands are issued somewhere in the simulator, such as the commit stage of the CPU pipeline. The functional and timing commands are issued continuously. The SYNC command returns the end cycle of the transaction. However, the simulation cycle must be updated at the end of this iteration to avoid program crush.</p>"},{"location":"04-import-sim/#trace-driven-simulator","title":"Trace-driven Simulator","text":"<p>Trace-driven simulators provide separate function models and timing models. Function models generate traces, and traces drive timing models. The timing model can be driven by one trace generated by one function model running simultaneously. Otherwise, the trace can be generated before executing the timing model.</p> <p>In trace-driven simulators that execute functional and timing models simultaneously, functional commands are issued in the function model, and timing commands are issued in the timing model. The order to issue commands should be carefully controlled:</p> <pre><code>sequenceDiagram\n\nparticipant FM as Function Model\nparticipant TM as Timing Model\nparticipant interchiplet\n\nNote over FM,TM: Simulator execution.\nFM -&gt;&gt; interchiplet: Functional command.\nNote over FM: Wait for RESULT command.\ninterchiplet -&gt;&gt; FM: RESULT command.\n\nFM --&gt; TM: Synchronization between&lt;br/&gt;function model and timing model.\n\nTM -&gt;&gt; interchiplet: Issue timing command.\nNote over TM: Wait for SYNC command.\ninterchiplet -&gt;&gt; TM: SYNC command.\nNote over TM: Adjust simulation cycle.\n\nFM --&gt; TM: Synchronization between&lt;br/&gt;function model and timing model.\n\nNote over FM,TM: Simulator execution.</code></pre> <p>In trace-driven simulators driven by offline traces, timing models should issue both functional and timing commands, similar to cycle-driven simulators. Moreover, the timing models should be able to provide transmission data to other simulators because other simulators may need these data for their functional model.</p> <p>See SniperSim as an example.</p>"},{"location":"04-import-sim/#data-driven-simulator","title":"Data-driven Simulator","text":"<p>Data-driven simulators are usually used to emulate application-specific IPs, such as ISPs, NN accelerators, and in-memory accelerators. These simulators usually accept input data, emulate the IP's functionality, and return output data and the elapsed cycle.</p> <p>It is not necessary to add APIs in the data-driven simulators. Instead, wrappers can be used to adapt data-driven simulators to LegoSim. One task on data-driven simulators is shown below:</p> <pre><code>flowchart TB\n\nA(Start)\nB[Get launcher by WAITLAUNCH command]\nC[Synchronize with the master by RECEIVE command]\nD[Read data from the master]\nE[Synchronize timing with the master by READ command]\nF[Call the data-driven simulator]\nG[Adjust cycle to the sum of the end cycle of the READ&lt;br/&gt;command and return value of the simulator]\nH[Synchronize with the master by SEND command]\nI[Send data to the master]\nJ[Synchronize timing with the master by WRITE command]\nZ(End)\n\nA--&gt;B--&gt;C--&gt;D--&gt;E--&gt;F--&gt;G--&gt;H--&gt;I--&gt;J--&gt;Z</code></pre> <p>The SYNC command after the READ command returns the end cycle of input data transmission. It is also the start cycle of the data-driven simulator. The elapsed cycle of the data-driven simulator is added to the start cycle. Then, the WRITE command sends the result as the start cycle of output data transmission.</p>"},{"location":"04-import-sim/#utility-apis","title":"Utility APIs","text":"<p>$SIMULATOR_ROOT/interchiplet/includes/pipe_comm.h provides utility APIs to handle synchronization protocol.</p> <p>The following APIs exist in <code>pipe_comm</code> to issue commands:</p> <ul> <li><code>InterChiplet::sendSync</code> sends a SEND command and waits for a RESULT command. This function returns the name of the generated Named Pipe.</li> <li><code>InterChiplet::receiveSync</code> sends a RECEIVE command and waits for a RESULT command. This function returns the name of the generated Named Pipe.</li> <li><code>InterChiplet::launchSync</code> sends a LAUNCH command and waits for a RESULT command. This function has no return value.</li> <li><code>InterChiplet::waitlaunchSync</code> sends a WAITLAUNCH command and waits for a RESULT command. This function returns the address of the source through data pointers.</li> <li><code>InterChiplet::barrierSync</code> sends a BARRIER command and waits for a RESULT command. This function has no return value.</li> <li><code>InterChiplet::lockSync</code> sends a LOCK command and waits for a RESULT command. This function has no return value.</li> <li> <p><code>InterChiplet::unlockSync</code> sends a UNLOCK command and waits for a RESULT command. This function has no return value.</p> </li> <li> <p><code>InterChiplet::sendCycleCmd</code> sends CYCLE command.</p> </li> <li><code>InterChiplet::readSync</code> sends a READ command and waits for a SYNC command. The function returns the cycle specified by the SYNC command.</li> <li><code>InterChiplet::writeSync</code> sends a WRITE command and waits for a SYNC command. The function returns the cycle specified by the SYNC command.</li> </ul> <p>To reduce the overhead of opening, closing, reading, and writing Pipes, pipe_comm.h abstracts operations into the interface class <code>InterChiplet::PipeComm</code>.\u00a0<code>PipeComm</code>\u00a0holds a list of opened pipes and one data buffer for each. So that one pipe is opened only once during one simulator process. Meanwhile, many reads with small sizes are regulated to less read with the data buffer's size.</p> <p>The usage of\u00a0<code>InterChiplet::PipeComm</code>\u00a0is as follows:</p> <pre><code>InterChiplet::PipeComm global_pipe_comm;    // It is suggested that the global entity of PipeComm be declared.\n\nchar * fileName = InterChiplet::SyncProtocol::pipeName(src_x, src_y, dst_x, dst_y);    // It is suggested to use APIs to get the file name of pipes.\nglobal_pipe_comm.write_data(fileName, interdata, nbytes);    // Write data to Pipe\nglobal_pipe_comm.read_data(fileName, interdata, nbytes);     // Read data to Pipe\n</code></pre> <p>::: doxy.Class     name: InterChiplet::PipeComm</p>"},{"location":"04-import-sim/#generate-patch-and-apply-patch","title":"Generate Patch and Apply Patch","text":"<p>Although imported simulators need a minor change to support the synchronization protocol, third-party simulators are still suggested to be imported as git submodules. The purpose behind such suggestions is to keep the repository clean and respect the spirit of open-source. The minor modifications should be stored in a dedicated diff file for each simulator.</p> <p>patch.sh is used to create .diff patches for all simulators. It will also copy modified files to .cache. It is forbidden to copy files in .cache to the directory of simulators because the copy operation cannot be redrawn. However, the file in .cache can be used as a reference when recovering from git confliction.</p> <p>apply_patch.sh will apply .diff patches to all simulators.\u00a0<code>git reset</code>\u00a0is necessary for each simulator before apply_patch.sh to avoid git confliction.</p> <p>When adding new simulators, it is necessary to add the path of the new simulators to patch.sh and apply_patch.sh.</p>"},{"location":"04-import-sim/041-snipersim/","title":"Importing SniperSim","text":"<p>SniperSim is a trace-based CPU simulator that can achieve high speed and reasonable accuracy.</p>"},{"location":"04-import-sim/041-snipersim/#apis","title":"APIs","text":"<p>APIs are implemented by System Calls. The following system call numbers are assigned to these APIs.</p> <pre><code>SYSCALL_LAUNCH = 501,        // Launch request.\nSYSCALL_WAITLAUNCH = 502,    // Waiit launch request.\nSYSCALL_BARRIER = 503,       // Enter barrier.\nSYSCALL_LOCK = 504,          // Lock mutex.\nSYSCALL_UNLOCK = 505,        // Unlock mutex.\nSYSCALL_REMOTE_READ = 506,   // Read cross chiplet\nSYSCALL_REMOTE_WRITE = 507,  // Write cross chiplet\n</code></pre> <p>Each benchmark API corresponds to one system call. All arguments of the benchmark APIs are also the arguments for system calls.</p>"},{"location":"04-import-sim/041-snipersim/#handle-syscalls","title":"Handle Syscalls","text":"<p>SniperSim provides separate functional and timing models. Hence, syscalls are handled separately in functional and timing models.</p> <p>In the functional model, system calls are handled in file $SIMULATOR_ROOT/snipersim/sift/recorder/syscall_modeling.cc. In the timing model, system calls are handled in file $SIMULATOR_ROOT/snipersim/common/core/syscall_model.cc.</p>"},{"location":"04-import-sim/041-snipersim/#handle-syscall_remote_writesyscall_remote_read","title":"Handle SYSCALL_REMOTE_WRITE/SYSCALL_REMOTE_READ","text":"<p>The flow chart of the function model is as follows:</p> <pre><code>flowchart TD\n\nsubgraph Write Syscall\nA1[Issue SEND command]\nB1[Wait for RESULT command]\nC1[Open PIPE]\nD1[Write data to PIPE]\nend\n\nA1--&gt;B1--&gt;C1--&gt;D1\nB1--&gt;B1\n\nsubgraph Read Syscall\nA2[Issue RECEIVE command]\nB2[Wait for RESULT command]\nC2[Open PIPE]\nD2[Read data from PIPE]\nend\n\nA2--&gt;B2--&gt;C2--&gt;D2\nB2--&gt;B2</code></pre> <p>The flow chart of the timing model is as follows:</p> <pre><code>flowchart TD\n\nsubgraph Write Syscall\nA1[Get current execution cycle]\nB1[Issue WRITE command]\nC1[Wait for SYNC command]\nD1[Sleep core until cycle specified by SYNC command]\nend\n\nA1--&gt;B1--&gt;C1--&gt;D1\nC1--&gt;C1\n\nsubgraph Read Syscall\nA2[Get current execution cycle]\nB2[Issue READ command]\nC2[Wait for SYNC command]\nD2[Sleep core until cycle specified by SYNC command]\nend\n\nA2--&gt;B2--&gt;C2--&gt;D2\nC2--&gt;C2</code></pre> <p>SniperSim is not a cycle-driven simulator. Hence, the execution cycle cannot be changed by modifying the value of some variables. Instead, one Sleep instruction is injected into the timing model, and the duration of the Sleep instruction equals the gap from the cycle issue one READ/WRITE command to the cycle receiving the corresponding SYNC command.</p> <pre><code>// Update simulator time.\nComponentPeriod time_wake_period = *(Sim()-&gt;getDvfsManager()-&gt;getGlobalDomain()) * end_time;\nSubsecondTime time_wake = time_wake_period.getPeriod();\nSubsecondTime sleep_end_time;\nSim()-&gt;getSyscallServer()-&gt;handleSleepCall(m_thread-&gt;getId(), time_wake, start_time, sleep_end_time);\n\n// Sleep core until specified time.\nif (m_thread-&gt;reschedule(sleep_end_time, core))\n    core = m_thread-&gt;getCore();\n\ncore-&gt;getPerformanceModel()-&gt;queuePseudoInstruction(new SyncInstruction(sleep_end_time, SyncInstruction::SLEEP));\n</code></pre>"},{"location":"04-import-sim/041-snipersim/#handle-other-system-calls","title":"Handle Other System Calls","text":"<p>Different from SYSCALL_REMOTE_READ and SYSCALL_REMOTE_WRITE, except functional and timing commands, it is not necessary to handle other functionality.</p> <p>The flow chart is as follows:</p> <pre><code>flowchart TD\n\nsubgraph Functional model\nA1[Issue functional command]\nB1[Wait for READ command]\nend\n\nA1--&gt;B1\nB1--&gt;B1\n\nsubgraph Timing model\nA2[Issue timing command]\nB2[Wait for SYNC command]\nC2[Sleep core until cycle specified by SYNC command]\nend\n\nA2--&gt;B2--&gt;C2\nB2--&gt;B2</code></pre> <p>The mapping between system calls and commands is shown below:</p> System call Functional command Timing command SYSCALL_LAUNCH <code>LAUNCH</code> <code>WRITE</code> SYSCALL_WAITLAUNCH <code>WAITLAUNCH</code> <code>READ</code> SYSCALL_BARRIER <code>BARRIER</code> <code>WRITE</code> SYSCALL_LOCK <code>LOCK</code> <code>WRITE</code> SYSCALL_UNLOCK <code>UNLOCK</code> <code>WRITE</code> SYSCALL_REMOTE_READ <code>READ</code> <code>READ</code> SYSCALL_REMOTE_WRITE <code>WRITE</code> <code>WRITE</code>"},{"location":"04-import-sim/041-snipersim/#issue-cycle-command","title":"Issue CYCLE command","text":"<p>Because the CPU always controls the flow of benchmarks, the CPU's execution cycle plays a vital role in the execution cycle of the entire simulation. CYCLE command is issued in file $SIMULATOR_ROOT/snipersim/common/core/core.cc.</p>"},{"location":"04-import-sim/042-gpgpusim/","title":"Importing GPGPUSim","text":"<p>GPGPUSim is a cycle-accurate model that simulates the micro-architecture of Nvidia GPGPU.</p>"},{"location":"04-import-sim/042-gpgpusim/#apis","title":"APIs","text":"<p>In real GPGPU systems, benchmark APIs will be scheduled to particular APIs. For example, DMA units handle communication. The mailbox handles the barrier and lock. Therefore, benchmark APIs should be implemented by CUDA runtime APIs rather than kernels.</p> <p>CUDA runtime APIs are declared and implemented in the CUDA kit. GPGPUSim provides a different runtime library libcudart.so rather than the standard runtime library from the CUDA kit. When compiling CUDA executable files, nvcc will link the standard runtime library.</p> <p>Benchmark APIs are added to the runtime library provided by GPGPUSim. APIs are implemented in file $SIMULATOR_ROOT/gpgpu-sim/libcuda/cuda_runtime_api.cc. Hence, when compiling CUDA executable files, the path to search libraries must be redirected to GPGPUSim:</p> <pre><code>nvcc -L$(SIMULATOR_ROOT)/gpgpu-sim/lib/$(GPGPUSIM_CONFIG) --cudart shared $(CUDA_OBJS) -o $(CUDA_TARGET)\n</code></pre>"},{"location":"04-import-sim/042-gpgpusim/#sendmessage-and-receivemessage","title":"sendMessage and receiveMessage","text":"<p>The flow chart of <code>sendMessage</code> and <code>receiveMessage</code> is as follows:</p> <pre><code>flowchart TD\n\nsubgraph Write Syscall\nO1(Start)\nA1[Copy data from device to host]\nB1[Issue SEND command]\nC1[Wait for RESULT command]\nD1[Open Pipe]\nE1[Write data to Pipe]\nF1[Get current simulation cycle]\nG1[Send WRITE command]\nH1[Wait for SYNC command]\nI1[Adjust simulation cycle]\nZ1(End)\nend\n\nO1--&gt;A1--&gt;B1--&gt;C1--&gt;D1--&gt;E1--&gt;F1--&gt;G1--&gt;H1----&gt;I1--&gt;Z1\nC1--&gt;C1\nH1--&gt;H1\n\nsubgraph Read Syscall\nO2(Start)\nA2[Issue RECEIVE command]\nB2[Wait for RESULT command]\nC2[Open Pipe]\nD2[Read data from Pipe]\nE2[Get current simulation cycle]\nF2[Send READ command]\nG2[Wait for SYNC command]\nH2[Write data from host to device]\nI2[Adjust simulation cycle]\nZ2(End)\nend\n\nO2----&gt;A2--&gt;B2--&gt;C2--&gt;D2--&gt;E2--&gt;F2--&gt;G2--&gt;H2--&gt;I2--&gt;Z2\nB2--&gt;B2\nG2--&gt;G2</code></pre> <p>CUDA provides memory copy APIs to transfer data between the host and the device.</p> <pre><code>// From the device to the host, used by sendMessage\ncudaMemcpy(interdata, __addr, __nbyte, cudaMemcpyDeviceToHost);\n\n// From the host to the device, used by receiveMessage\ncudaMemcpy(__addr, interdata, __nbyte, cudaMemcpyHostToDevice);\n</code></pre> <p>GPGPUSim is a cycle-driven simulator whose cycle loop can be found in file $SIMULATOR_ROOT/gpgpu-sim/src/gpgpu-sim/gpu-sim.h and $SIMULATOR_ROOT/gpgpu-sim/src/gpgpu-sim/gpu-sim.cc.</p> <p>GPGPUSim applies two variables to record the execution cycles: <code>gpgpu_sim::gpu_sim_cycle</code> and <code>gpgpu_sim::gpu_tot_sim_cycle</code>. The sum of these two variables presents the real consumed cycle, which should be replaced by the cycle value in the SYNC command.</p> <p>When GPGPUSim handles CUDA APIs, the cycle loop has not started. Hence, <code>gpgpu_sim::gpu_sim_cycle</code>\u00a0can be directly modified:</p> <pre><code>// Get the current cycle.\ngpgpu_sim *gpu = GPGPU_Context()-&gt;the_gpgpusim-&gt;the_context-&gt;get_device()-&gt;get_gpgpu();\nlong long unsigned int timeNow = gpu-&gt;gpu_sim_cycle + gpu-&gt;gpu_tot_sim_cycle;\n\nlong long int timeEnd = ...\n\n// Update the current cycle.\ngpu-&gt;gpu_tot_sim_cycle = timeEnd - gpu-&gt;gpu_sim_cycle;\n</code></pre>"},{"location":"04-import-sim/042-gpgpusim/#other-apis","title":"Other APIs","text":"<p>Different from <code>sendMessage</code> and <code>receiveMessage</code>, except for functional and timing commands, it is not necessary to handle other functionality.</p> <p>The flow chart is as follows:</p> <pre><code>flowchart TD\n\nA1[Issue functional command]\nB1[Wait for RESULT command]\n\nA2[Issue timing command]\nB2[Wait for SYNC command]\nC2[Change the simulator cycle]\n\nA1--&gt;B1--&gt;A2--&gt;B2--&gt;C2\nB1--&gt;B1\nB2--&gt;B2</code></pre> <p>The mapping between APIs and commands is shown below:</p> System call Functional command Timing command <code>launch</code> <code>LAUNCH</code> <code>WRITE</code> <code>waitlaunch</code> <code>WAITLAUNCH</code> <code>READ</code> <code>barrier</code> <code>BARRIER</code> <code>WRITE</code> <code>lock</code> <code>LOCK</code> <code>WRITE</code> <code>unlock</code> <code>UNLOCK</code> <code>WRITE</code> <code>receiveMessage</code> <code>READ</code> <code>READ</code> <code>sendMessage</code> <code>WRITE</code> <code>WRITE</code>"},{"location":"04-import-sim/042-gpgpusim/#issue-cycle-command","title":"Issue CYCLE command","text":"<p>The task on the GPU is triggered by CPUs in the system. CPUs prepare the data required by tasks and accept the generated result. The execution cycle of CPUs reflects the execution cycle of GPUs through the synchronization performed by data transmission. Therefore, GPGPUSim does not issue CYCLE commands.</p>"},{"location":"04-import-sim/043-gem5/","title":"Importing GEM5","text":"<p>GEM5 provides a powerful platform to study the architecture and micro-architecture of computer systems. It is widely used in both academic and industrial fields.</p> <p>Currently, supported ISAs include X86 and ARM. Supported timing models include AtomicSimpleCPU, TimingSimpleCPU, and O3CPU.</p>"},{"location":"04-import-sim/043-gem5/#apis","title":"APIs","text":"<p>APIs are implemented by System Calls. The following system call numbers are assigned to these APIs.</p> <pre><code>SYSCALL_LAUNCH = 501,        // Launch request.\nSYSCALL_WAITLAUNCH = 502,    // Waiit launch request.\nSYSCALL_BARRIER = 503,       // Enter barrier.\nSYSCALL_LOCK = 504,          // Lock mutex.\nSYSCALL_UNLOCK = 505,        // Unlock mutex.\nSYSCALL_REMOTE_READ = 506,   // Read cross chiplet\nSYSCALL_REMOTE_WRITE = 507,  // Write cross chiplet\n</code></pre> <p>Each benchmark API corresponds to one system call. All arguments of the benchmark APIs are also the arguments for system calls.</p>"},{"location":"04-import-sim/043-gem5/#handle-syscalls","title":"Handle Syscalls","text":"<p>Gem5 is categorized as an execution-driven simulation. The timing model will call the function model at the right time one instruction by one instruction. Hence, the functional commands and the timing commands can be handled in the same place.</p> <p>Gem5 provides unified function models for all timing models. The function models for all ISAs are implemented in folder <code>src/arch</code>. Each ISA has different syscall lists.</p> <ul> <li>$SIMULATOR_ROOT/gem5/src/arch/x86/linux/syscall_tbl32.cc and $SIMULATOR_ROOT/gem5/src/arch/x86/linux/syscall_tbl64.cc define the syscall list for x86.</li> <li>$SIMULATOR_ROOT/gem5/src/arch/arm/linux/se_workload.cc defines the syscall list for ARMv8 ISA.</li> </ul> <p>Different ISAs apply the same emulator of syscalls. You can find the handler for all syscalls in $SIMULATOR_ROOT/gem5/src/sim/syscall_emul.hh and $SIMULATOR_ROOT/gem5/src/sim/syscall_emul.cc. </p>"},{"location":"04-import-sim/043-gem5/#handle-syscall_remote_writesyscall_remote_read","title":"Handle SYSCALL_REMOTE_WRITE/SYSCALL_REMOTE_READ","text":"<p>The flow chart of <code>SYSCALL_REMOTE_WRITE</code> and <code>SYSCALL_REMOTE_READ</code> is as follows:</p> <pre><code>flowchart TD\n\nsubgraph Write Syscall\nO1(Start)\nA1[Copy data out of simulation space]\nB1[Issue SEND command]\nC1[Wait for RESULT command]\nD1[Open Pipe]\nE1[Write data to Pipe]\nF1[Get current simulation cycle]\nG1[Send WRITE command]\nH1[Wait for SYNC command]\nI1[Adjust simulation cycle]\nZ1(End)\nend\n\nO1--&gt;A1--&gt;B1--&gt;C1--&gt;D1--&gt;E1--&gt;F1--&gt;G1--&gt;H1----&gt;I1--&gt;Z1\nC1--&gt;C1\nH1--&gt;H1\n\nsubgraph Read Syscall\nO2(Start)\nA2[Issue RECEIVE command]\nB2[Wait for RESULT command]\nC2[Open Pipe]\nD2[Read data from Pipe]\nE2[Get current simulation cycle]\nF2[Send READ command]\nG2[Wait for SYNC command]\nH2[Copy data into simulation space]\nI2[Adjust simulation tick]\nZ2(End)\nend\n\nO2----&gt;A2--&gt;B2--&gt;C2--&gt;D2--&gt;E2--&gt;F2--&gt;G2--&gt;H2--&gt;I2--&gt;Z2\nB2--&gt;B2\nG2--&gt;G2</code></pre>"},{"location":"04-import-sim/043-gem5/#other-syscalls","title":"Other Syscalls","text":"<p>Different from <code>SYSCALL_REMOTE_WRITE</code> and <code>SYSCALL_REMOTE_READ</code>, except for functional and timing commands, it is not necessary to handle other functionality.</p> <p>The flow chart is as follows:</p> <pre><code>flowchart TD\n\nA1[Issue functional command]\nB1[Wait for RESULT command]\n\nA2[Issue timing command]\nB2[Wait for SYNC command]\nC2[Change the simulator tick]\n\nA1--&gt;B1--&gt;A2--&gt;B2--&gt;C2\nB1--&gt;B1\nB2--&gt;B2</code></pre> <p>The mapping between APIs and commands is shown below:</p> System call Functional command Timing command <code>launch</code> <code>LAUNCH</code> <code>WRITE</code> <code>waitlaunch</code> <code>WAITLAUNCH</code> <code>READ</code> <code>barrier</code> <code>BARRIER</code> <code>WRITE</code> <code>lock</code> <code>LOCK</code> <code>WRITE</code> <code>unlock</code> <code>UNLOCK</code> <code>WRITE</code> <code>receiveMessage</code> <code>READ</code> <code>READ</code> <code>sendMessage</code> <code>WRITE</code> <code>WRITE</code>"},{"location":"04-import-sim/043-gem5/#adjust-simulator-tick","title":"Adjust Simulator Tick","text":"<p>In order to deal with multiple clock domains in computer systems, the basic timing unit in Gem5 is called <code>Tick</code> instead of the cycle. Considering one chiplet with multiple clock domains, we prefer to handle the unit transaction by benchmark configuration files (.yaml). </p> <p>For example,</p> <pre><code>  - cmd: \"$SIMULATOR_ROOT/gem5/build/X86/gem5.opt\"\n    args: [\"$SIMULATOR_ROOT/gem5/configs/deprecated/example/se.py\", \"--cmd\", \"$BENCHMARK_ROOT/bin/test_c\", \"-o\", \"0 0\"]\n    log: \"gem5.0.0.log\"\n    is_to_stdout: false\n    clock_rate: 500\n</code></pre> <p>The kernel simulation loop of Gem5 is one event queue. Timing models handle the first event in the queue and inject for events if necessary.</p> <pre><code>flowchart LR\n\nA1[Event queue]\nB1[Timing model]\n\nA1--\"The first event in queue\"--&gt;B1--\"More events\"--&gt;A1</code></pre> <p>Two global variables are added in $SIMULATOR_ROOT/gem5/src/sim/eventq.hh and $SIMULATOR_ROOT/gem5/src/sim/eventq.cc so that all components can access them.</p> <ul> <li><code>gem5::interchiplet_end_tick_valid</code> means whether it is necessary to change the simulator tick.</li> <li><code>gem5::interchiplet_end_tick</code> means the target to change the simulator tick.</li> </ul> <p>In AtomicSimpleCPU, the timing model injects one tick event into the event queue every cycle. When the simulator tick needs changing, the latency is added to the next tick event so the simulator can move forward to the target time. See $SIMULATOR_ROOT/gem5/src/cpu/simple/atomic.cc for details.</p> <p>In TimingSimpleCPU, the timing model injects one fetch event into the event queue for each bubble. When the simulator tick needs changing, the next fetch event is injected into the event queue at the target time. See $SIMULATOR_ROOT/gem5/src/cpu/simple/timing.cc for details.</p> <p>In O3CPU, the timing model also injects one tick event into the event queue every cycle. Hence, the next tick event is injected at the target time when the tick needs changing. See $SIMULATOR_ROOT/gem5/src/cpu/o3/cpu.cc for details.</p>"},{"location":"04-import-sim/043-gem5/#issue-cycle-command","title":"Issue CYCLE command","text":"<p>Because the CPU always controls the flow of benchmarks, the CPU's execution cycle plays a vital role in the execution cycle of the entire simulation. CYCLE command is issued in file $SIMULATOR_ROOT/gem5/src/sim/sim_event.cc when the simulator quits the simulation loop.</p>"},{"location":"04-import-sim/043-gem5/#cross-compile-for-arm-isa","title":"Cross-compile for ARM ISA","text":"<p>As a universal simulation platform, Gem5 supports multiple ISAs. Syscalls required to handle benchmark APIs have been added to x86 and ARM ISA. Hence, Gem5 in LegoSim can also execute ARM benchmarks.</p> <p>The following command installs the cross-compiler for ARM.</p> <pre><code>sudo apt install gcc-aarch64-linux-gnu\n</code></pre> <p>Then, you can use <code>aarch64-linux-gnu-gcc</code> and <code>aarch64-linux-gnu-g++</code> to compile benchmarks just like <code>gcc</code> and <code>g++</code>.</p> <p>Wnen apply ARM cross compile, <code>interchiplet_c</code> cannot be used. <code>apis_c.cpp</code> should be compiled to one object file and linked to the target.</p> <p>For example,</p> <pre><code># C language target\nC_target: $(C_OBJS) obj/interchiplet.o\n    $(CC) $(C_OBJS) obj/interchiplet.o -o $(C_TARGET)\n\n# Interchiplet library\nobj/interchiplet.o: ../../../../interchiplet/srcs/apis_c.cpp\n    $(CC) $(CFLAGS) -c $&lt; -o $@\n\n# Rule for C object\nobj/%.o: ../../snipersim/barrier/%.cpp\n    $(CC) $(CFLAGS) -c $&lt; -o $@\n</code></pre>"},{"location":"apiProject1/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>class BenchmarkConfig Benchmark configuration structure. </li> <li>class CmdLineOptions Options from command line. </li> <li>namespace InterChiplet </li> <li>class PipeComm Pipe communication structure. </li> <li>class PipeCommUnit Structure for Single Pipe communication. </li> <li>class SyncCommand Structure of synchronization command. </li> <li>class NetworkBenchItem Structure of one package in network. </li> <li>class NetworkBenchList List of network benchmark item. </li> <li>class NetworkDelayItem Structure presents delay of one package in network. </li> <li>class NetworkDelayMap Map for network delay information. </li> <li>class NetworkDelayStruct List of network delay item. </li> <li>class ProcessConfig Data structure to configure one simulation process. </li> <li>class ProcessStruct Data structure of process configuration. </li> <li>class SyncBarrierStruct Structure for Barrier synchronization. </li> <li>class SyncClockStruct Structure for Clock synchronization. </li> <li>class SyncCommStruct Structure for Communication synchronization. </li> <li>class SyncLaunchStruct Structure for Launch and Wait-launch synchronization. </li> <li>class SyncLockStruct Structure for Lock and Unlock synchronization. </li> <li>class SyncPipeStruct Structure for Pipe synchronization. </li> <li>class SyncStruct Data structure of synchronize operation. </li> </ul>"},{"location":"apiProject1/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir interchiplet </li> <li>dir includes <ul> <li>file apis_c.h </li> <li>file apis_cu.h </li> <li>file benchmark_yaml.h </li> <li>file cmd_handler.h </li> <li>file cmdline_options.h </li> <li>file global_define.h </li> <li>file net_bench.h </li> <li>file net_delay.h </li> <li>file pipe_comm.h </li> <li>file sync_protocol.h </li> </ul> </li> <li>dir srcs <ul> <li>file apis_c.cpp </li> <li>file cmd_handler.cpp </li> <li>file interchiplet.cpp </li> </ul> </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/","title":"Namespace InterChiplet","text":"<p>Namespace List &gt; InterChiplet</p>"},{"location":"apiProject1/namespaceInterChiplet/#classes","title":"Classes","text":"Type Name class PipeComm Pipe communication structure. class PipeCommUnit Structure for Single Pipe communication. class SyncCommand Structure of synchronization command."},{"location":"apiProject1/namespaceInterChiplet/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; long &gt; AddrType Address type;. typedef double InnerTimeType Time type used by interchiplet module. enum SyncCommType Type of synchronization command between simulators. enum SyncProtocolDesc Behavior descriptor of synchronization protocol. enum SysCallID Syscall ID used in CPU/GPU. typedef unsigned long long TimeType Time type used between simulators."},{"location":"apiProject1/namespaceInterChiplet/#public-attributes","title":"Public Attributes","text":"Type Name decltype(syscall(0)) typedef syscall_return_t"},{"location":"apiProject1/namespaceInterChiplet/#public-functions","title":"Public Functions","text":"Type Name syscall_return_t barrier (int64_t __uid, int64_t __src_x, int64_t __src_y, int64_t __count=0) Barrier. void barrierSync (int __src_x, int __src_y, int __uid, int __count) Send BARRIER command and wait for SYNC command. TimeType cycleSync (TimeType __cycle) Send CYCLE command and wait for SYNC command. std::string dumpCmd (const SyncCommand &amp; __cmd) Dump command to a string for debugging. syscall_return_t launch (int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y) Launch application to remote chiplet. void launchSync (int __src_x, int __src_y, int __dst_x, int __dst_y) Send LAUNCH command and wait for SYNC command. syscall_return_t lock (int64_t __uid, int64_t __src_x, int64_t __src_y) Lock mutex. void lockSync (int __src_x, int __src_y, int __uid) Send UNLOCK command and wait for SYNC command. SyncCommand parseCmd (const std::string &amp; __message) Parse command from string. SyncCommand parseCmd (int __fd_in=STDIN_FILENO) Receive command from stdin and parse the message. Used by simulator only. std::string pipeName (const AddrType &amp; __src, const AddrType &amp; __dst) Return name of file name in a std::string. Return directory related to the directory of main process. TimeType readSync (TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y, int __nbyte, long __desc) Send READ command and wait for SYNC command. syscall_return_t receiveMessage (int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y, void * __addr, int64_t __nbyte) Read data from remote chiplet. std::string receiveSync (int __src_x, int __src_y, int __dst_x, int __dst_y) Send RECEIVE command and wait for SYNC command. void sendBarrierCmd (int __src_x, int __src_y, int __uid, int __count) Send BARRIER command. void sendCycleCmd (TimeType __cycle) Send CYCLE command. void sendLaunchCmd (int __src_x, int __src_y, int __dst_x, int __dst_y) Send LAUNCH command. void sendLockCmd (int __src_x, int __src_y, int __uid) Send LOCK command. syscall_return_t sendMessage (int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y, void * __addr, int64_t __nbyte) Send data to remote chiplet. void sendReadCmd (TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y, int __nbyte, long __desc) Send READ command. void sendReceiveCmd (int __src_x, int __src_y, int __dst_x, int __dst_y) Send RECEIVE command. void sendResultCmd () Send RESULT command. void sendResultCmd (const std::vector&lt; std::string &gt; &amp; __res_list) Send RESULT command. void sendResultCmd (const std::vector&lt; long &gt; &amp; __res_list) Send RESULT command. void sendResultCmd (int __fd) Send RESULT command. void sendResultCmd (int __fd, const std::vector&lt; std::string &gt; &amp; __res_list) Send RESULT command. void sendResultCmd (int __fd, const std::vector&lt; long &gt; &amp; __res_list) Send RESULT command. void sendSendCmd (int __src_x, int __src_y, int __dst_x, int __dst_y) Send SEND command. std::string sendSync (int __src_x, int __src_y, int __dst_x, int __dst_y) Send SEND command and wait for SYNC command. void sendSyncCmd (TimeType __cycle) Send SYNC command. void sendSyncCmd (int __fd, TimeType __cycle) Send SYNC command to specified file descriptor. void sendUnlockCmd (int __src_x, int __src_y, int __uid) Send UNLOCK command. void sendWaitlaunchCmd (int __src_x, int __src_y, int __dst_x, int __dst_y) Send WAITLAUNCH command. void sendWriteCmd (TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y, int __nbyte, long __desc) Send WRITE command. syscall_return_t unlock (int64_t __uid, int64_t __src_x, int64_t __src_y) Unlock mutex. void unlockSync (int __src_x, int __src_y, int __uid) Send UNLOCK command and wait for SYNC command. syscall_return_t waitLaunch (int64_t __dst_x, int64_t __dst_y, int64_t * __src_x, int64_t * __src_y) Wait launch from remote chiplet. void waitlaunchSync (int * __src_x, int * __src_y, int __dst_x, int __dst_y) Send WAITLAUNCH command and wait for LAUNCH command. TimeType writeSync (TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y, int __nbyte, long __desc) Send WRITE command and wait for SYNC command."},{"location":"apiProject1/namespaceInterChiplet/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiProject1/namespaceInterChiplet/#typedef-addrtype","title":"typedef AddrType","text":"<pre><code>typedef std::vector&lt;long&gt; InterChiplet::AddrType;\n</code></pre>"},{"location":"apiProject1/namespaceInterChiplet/#typedef-innertimetype","title":"typedef InnerTimeType","text":"<pre><code>typedef double InterChiplet::InnerTimeType;\n</code></pre>"},{"location":"apiProject1/namespaceInterChiplet/#enum-synccommtype","title":"enum SyncCommType","text":"<pre><code>enum InterChiplet::SyncCommType {\n    SC_CYCLE,\n    SC_SEND,\n    SC_RECEIVE,\n    SC_BARRIER,\n    SC_LOCK,\n    SC_UNLOCK,\n    SC_LAUNCH,\n    SC_WAITLAUNCH,\n    SC_READ,\n    SC_WRITE,\n    SC_SYNC,\n    SC_RESULT\n};\n</code></pre>"},{"location":"apiProject1/namespaceInterChiplet/#enum-syncprotocoldesc","title":"enum SyncProtocolDesc","text":"<pre><code>enum InterChiplet::SyncProtocolDesc {\n    SPD_ACK = 0x01,\n    SPD_PRE_SYNC = 0x02,\n    SPD_POST_SYNC = 0x04,\n    SPD_LAUNCH = 0x10000,\n    SPD_BARRIER = 0x20000,\n    SPD_LOCK = 0x40000,\n    SPD_UNLOCK = 0x80000\n};\n</code></pre>"},{"location":"apiProject1/namespaceInterChiplet/#enum-syscallid","title":"enum SysCallID","text":"<pre><code>enum InterChiplet::SysCallID {\n    SYSCALL_LAUNCH = 501,\n    SYSCALL_WAITLAUNCH = 502,\n    SYSCALL_BARRIER = 503,\n    SYSCALL_LOCK = 504,\n    SYSCALL_UNLOCK = 505,\n    SYSCALL_REMOTE_READ = 506,\n    SYSCALL_REMOTE_WRITE = 507\n};\n</code></pre>"},{"location":"apiProject1/namespaceInterChiplet/#typedef-timetype","title":"typedef TimeType","text":"<pre><code>typedef unsigned long long InterChiplet::TimeType;\n</code></pre>"},{"location":"apiProject1/namespaceInterChiplet/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/namespaceInterChiplet/#variable-syscall_return_t","title":"variable syscall_return_t","text":"<pre><code>decltype(syscall(0)) typedef InterChiplet::syscall_return_t;\n</code></pre>"},{"location":"apiProject1/namespaceInterChiplet/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/namespaceInterChiplet/#function-barrier","title":"function barrier","text":"<p>Barrier. <pre><code>syscall_return_t InterChiplet::barrier (\n    int64_t __uid,\n    int64_t __src_x,\n    int64_t __src_y,\n    int64_t __count=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Barrier ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__count</code> Number of threads to barrier. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-barriersync","title":"function barrierSync","text":"<p>Send BARRIER command and wait for SYNC command. <pre><code>inline void InterChiplet::barrierSync (\n    int __src_x,\n    int __src_y,\n    int __uid,\n    int __count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Barrier ID. </li> <li><code>__count</code> Number of items in barrier. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-cyclesync","title":"function cycleSync","text":"<p>Send CYCLE command and wait for SYNC command. <pre><code>inline TimeType InterChiplet::cycleSync (\n    TimeType __cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send CYCLE command. </li> </ul> <p>Returns:</p> <p>Cycle to receive SYNC command. </p>"},{"location":"apiProject1/namespaceInterChiplet/#function-dumpcmd","title":"function dumpCmd","text":"<p>Dump command to a string for debugging. <pre><code>inline std::string InterChiplet::dumpCmd (\n    const SyncCommand &amp; __cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Structure of synchronization command. </li> </ul> <p>Returns:</p> <p>String of message. </p>"},{"location":"apiProject1/namespaceInterChiplet/#function-launch","title":"function launch","text":"<p>Launch application to remote chiplet. <pre><code>syscall_return_t InterChiplet::launch (\n    int64_t __dst_x,\n    int64_t __dst_y,\n    int64_t __src_x,\n    int64_t __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-launchsync","title":"function launchSync","text":"<p>Send LAUNCH command and wait for SYNC command. <pre><code>inline void InterChiplet::launchSync (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-lock","title":"function lock","text":"<p>Lock mutex. <pre><code>syscall_return_t InterChiplet::lock (\n    int64_t __uid,\n    int64_t __src_x,\n    int64_t __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Mutex ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-locksync","title":"function lockSync","text":"<p>Send UNLOCK command and wait for SYNC command. <pre><code>inline void InterChiplet::lockSync (\n    int __src_x,\n    int __src_y,\n    int __uid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Mutex ID. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-parsecmd","title":"function parseCmd","text":"<p>Parse command from string. <pre><code>inline SyncCommand InterChiplet::parseCmd (\n    const std::string &amp; __message\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__message</code> String of message. </li> </ul> <p>Returns:</p> <p>Structure of synchronization command. </p>"},{"location":"apiProject1/namespaceInterChiplet/#function-parsecmd_1","title":"function parseCmd","text":"<p>Receive command from stdin and parse the message. Used by simulator only. <pre><code>inline SyncCommand InterChiplet::parseCmd (\n    int __fd_in=STDIN_FILENO\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd_in</code> Input file descriptor. </li> </ul> <p>Returns:</p> <p>Structure of synchronization command. </p>"},{"location":"apiProject1/namespaceInterChiplet/#function-pipename","title":"function pipeName","text":"<p>Return name of file name in a std::string. Return directory related to the directory of main process. <pre><code>inline std::string InterChiplet::pipeName (\n    const AddrType &amp; __src,\n    const AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src</code> Source address. </li> <li><code>__dst</code> Destiantion address. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-readsync","title":"function readSync","text":"<p>Send READ command and wait for SYNC command. <pre><code>inline TimeType InterChiplet::readSync (\n    TimeType __cycle,\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y,\n    int __nbyte,\n    long __desc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send READ command. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__nbyte</code> Number of bytes to read. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> </ul> <p>Returns:</p> <p>Cycle to receive SYNC command. </p>"},{"location":"apiProject1/namespaceInterChiplet/#function-receivemessage","title":"function receiveMessage","text":"<p>Read data from remote chiplet. <pre><code>syscall_return_t InterChiplet::receiveMessage (\n    int64_t __dst_x,\n    int64_t __dst_y,\n    int64_t __src_x,\n    int64_t __src_y,\n    void * __addr,\n    int64_t __nbyte\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__addr</code> Data address. </li> <li><code>__nbyte</code> Number of bytes. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-receivesync","title":"function receiveSync","text":"<p>Send RECEIVE command and wait for SYNC command. <pre><code>inline std::string InterChiplet::receiveSync (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul> <p>Returns:</p> <p>Pipe name. </p>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendbarriercmd","title":"function sendBarrierCmd","text":"<p>Send BARRIER command. <pre><code>inline void InterChiplet::sendBarrierCmd (\n    int __src_x,\n    int __src_y,\n    int __uid,\n    int __count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Barrier ID. </li> <li><code>__count</code> Number of items in barrier. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendcyclecmd","title":"function sendCycleCmd","text":"<p>Send CYCLE command. <pre><code>inline void InterChiplet::sendCycleCmd (\n    TimeType __cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send CYCLE command. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendlaunchcmd","title":"function sendLaunchCmd","text":"<p>Send LAUNCH command. <pre><code>inline void InterChiplet::sendLaunchCmd (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendlockcmd","title":"function sendLockCmd","text":"<p>Send LOCK command. <pre><code>inline void InterChiplet::sendLockCmd (\n    int __src_x,\n    int __src_y,\n    int __uid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Barrier ID. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendmessage","title":"function sendMessage","text":"<p>Send data to remote chiplet. <pre><code>syscall_return_t InterChiplet::sendMessage (\n    int64_t __dst_x,\n    int64_t __dst_y,\n    int64_t __src_x,\n    int64_t __src_y,\n    void * __addr,\n    int64_t __nbyte\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__addr</code> Data address. </li> <li><code>__nbyte</code> Number of bytes. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendreadcmd","title":"function sendReadCmd","text":"<p>Send READ command. <pre><code>inline void InterChiplet::sendReadCmd (\n    TimeType __cycle,\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y,\n    int __nbyte,\n    long __desc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send READ command. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__nbyte</code> Number of bytes to read. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendreceivecmd","title":"function sendReceiveCmd","text":"<p>Send RECEIVE command. <pre><code>inline void InterChiplet::sendReceiveCmd (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendresultcmd","title":"function sendResultCmd","text":"<pre><code>inline void InterChiplet::sendResultCmd () \n</code></pre>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendresultcmd_1","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    const std::vector&lt; std::string &gt; &amp; __res_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__res_list</code> Result list. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendresultcmd_2","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    const std::vector&lt; long &gt; &amp; __res_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__res_list</code> Result list. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendresultcmd_3","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    int __fd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd</code> File descriptor. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendresultcmd_4","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    int __fd,\n    const std::vector&lt; std::string &gt; &amp; __res_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd</code> File descriptor. </li> <li><code>__res_list</code> Result list. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendresultcmd_5","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    int __fd,\n    const std::vector&lt; long &gt; &amp; __res_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd</code> File descriptor. </li> <li><code>__res_list</code> Result list. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendsendcmd","title":"function sendSendCmd","text":"<p>Send SEND command. <pre><code>inline void InterChiplet::sendSendCmd (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendsync","title":"function sendSync","text":"<p>Send SEND command and wait for SYNC command. <pre><code>inline std::string InterChiplet::sendSync (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul> <p>Returns:</p> <p>Pipe name. </p>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendsynccmd","title":"function sendSyncCmd","text":"<p>Send SYNC command. <pre><code>inline void InterChiplet::sendSyncCmd (\n    TimeType __cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to receive SYNC command. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendsynccmd_1","title":"function sendSyncCmd","text":"<p>Send SYNC command to specified file descriptor. <pre><code>inline void InterChiplet::sendSyncCmd (\n    int __fd,\n    TimeType __cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd</code> File descriptor. </li> <li><code>__cycle</code> Cycle to receive SYNC command. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendunlockcmd","title":"function sendUnlockCmd","text":"<p>Send UNLOCK command. <pre><code>inline void InterChiplet::sendUnlockCmd (\n    int __src_x,\n    int __src_y,\n    int __uid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Barrier ID. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendwaitlaunchcmd","title":"function sendWaitlaunchCmd","text":"<p>Send WAITLAUNCH command. <pre><code>inline void InterChiplet::sendWaitlaunchCmd (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-sendwritecmd","title":"function sendWriteCmd","text":"<p>Send WRITE command. <pre><code>inline void InterChiplet::sendWriteCmd (\n    TimeType __cycle,\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y,\n    int __nbyte,\n    long __desc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send WRITE command. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__nbyte</code> Number of bytes to write. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-unlock","title":"function unlock","text":"<p>Unlock mutex. <pre><code>syscall_return_t InterChiplet::unlock (\n    int64_t __uid,\n    int64_t __src_x,\n    int64_t __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Mutex ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-unlocksync","title":"function unlockSync","text":"<p>Send UNLOCK command and wait for SYNC command. <pre><code>inline void InterChiplet::unlockSync (\n    int __src_x,\n    int __src_y,\n    int __uid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Mutex ID. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-waitlaunch","title":"function waitLaunch","text":"<p>Wait launch from remote chiplet. <pre><code>syscall_return_t InterChiplet::waitLaunch (\n    int64_t __dst_x,\n    int64_t __dst_y,\n    int64_t * __src_x,\n    int64_t * __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. Return value. </li> <li><code>__src_y</code> Source address in Y-axis. Return value. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-waitlaunchsync","title":"function waitlaunchSync","text":"<p>Send WAITLAUNCH command and wait for LAUNCH command. <pre><code>inline void InterChiplet::waitlaunchSync (\n    int * __src_x,\n    int * __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/namespaceInterChiplet/#function-writesync","title":"function writeSync","text":"<p>Send WRITE command and wait for SYNC command. <pre><code>inline TimeType InterChiplet::writeSync (\n    TimeType __cycle,\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y,\n    int __nbyte,\n    long __desc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send WRITE command. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__nbyte</code> Number of bytes to write. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> </ul> <p>Returns:</p> <p>Cycle to receive SYNC command. </p> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/apis_c.h</code></p>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/","title":"Class InterChiplet::SyncCommand","text":"<p>ClassList &gt; InterChiplet &gt; SyncCommand</p> <p>Structure of synchronization command. </p> <ul> <li><code>#include &lt;global_define.h&gt;</code></li> </ul>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#public-attributes","title":"Public Attributes","text":"Type Name double m_clock_rate Cycle convert rate. InnerTimeType m_cycle Cycle to send/receive command. long m_desc Descriptor of synchronization behavior. AddrType m_dst Destiantion address in X-axis. int m_nbytes Number of bytes to write. std::vector&lt; std::string &gt; m_res_list List of result strings. AddrType m_src Source address. int m_stdin_fd File descriptor to write response of this command. SyncCommType m_type Type of synchronization command."},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_clock_rate","title":"variable m_clock_rate","text":"<pre><code>double InterChiplet::SyncCommand::m_clock_rate;\n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_cycle","title":"variable m_cycle","text":"<pre><code>InnerTimeType InterChiplet::SyncCommand::m_cycle;\n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_desc","title":"variable m_desc","text":"<pre><code>long InterChiplet::SyncCommand::m_desc;\n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_dst","title":"variable m_dst","text":"<pre><code>AddrType InterChiplet::SyncCommand::m_dst;\n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_nbytes","title":"variable m_nbytes","text":"<pre><code>int InterChiplet::SyncCommand::m_nbytes;\n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_res_list","title":"variable m_res_list","text":"<pre><code>std::vector&lt;std::string&gt; InterChiplet::SyncCommand::m_res_list;\n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_src","title":"variable m_src","text":"<pre><code>AddrType InterChiplet::SyncCommand::m_src;\n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_stdin_fd","title":"variable m_stdin_fd","text":"<p>File descriptor to write response of this command. <pre><code>int InterChiplet::SyncCommand::m_stdin_fd;\n</code></pre></p> <p>For example, if one entity presents READ command, the SYNC command to response this READ command should to send to this file descriptor. </p>"},{"location":"apiProject1/classInterChiplet_1_1SyncCommand/#variable-m_type","title":"variable m_type","text":"<pre><code>SyncCommType InterChiplet::SyncCommand::m_type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/global_define.h</code></p>"},{"location":"apiProject1/classProcessStruct/","title":"Class ProcessStruct","text":"<p>ClassList &gt; ProcessStruct</p> <p>Data structure of process configuration. </p>"},{"location":"apiProject1/classProcessStruct/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; std::string &gt; m_args double m_clock_rate std::string m_command std::string m_log_file int m_phase int m_pid int m_pid2 std::string m_pre_copy int m_round SyncStruct * m_sync_struct Pointer to synchronize structure. int m_thread pthread_t m_thread_id bool m_to_stdout std::string m_unfinished_line"},{"location":"apiProject1/classProcessStruct/#public-functions","title":"Public Functions","text":"Type Name ProcessStruct (const ProcessConfig &amp; __config)"},{"location":"apiProject1/classProcessStruct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/classProcessStruct/#variable-m_args","title":"variable m_args","text":"<pre><code>std::vector&lt;std::string&gt; ProcessStruct::m_args;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_clock_rate","title":"variable m_clock_rate","text":"<pre><code>double ProcessStruct::m_clock_rate;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_command","title":"variable m_command","text":"<pre><code>std::string ProcessStruct::m_command;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_log_file","title":"variable m_log_file","text":"<pre><code>std::string ProcessStruct::m_log_file;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_phase","title":"variable m_phase","text":"<pre><code>int ProcessStruct::m_phase;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_pid","title":"variable m_pid","text":"<pre><code>int ProcessStruct::m_pid;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_pid2","title":"variable m_pid2","text":"<pre><code>int ProcessStruct::m_pid2;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_pre_copy","title":"variable m_pre_copy","text":"<pre><code>std::string ProcessStruct::m_pre_copy;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_round","title":"variable m_round","text":"<pre><code>int ProcessStruct::m_round;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_sync_struct","title":"variable m_sync_struct","text":"<pre><code>SyncStruct* ProcessStruct::m_sync_struct;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_thread","title":"variable m_thread","text":"<pre><code>int ProcessStruct::m_thread;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_thread_id","title":"variable m_thread_id","text":"<pre><code>pthread_t ProcessStruct::m_thread_id;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_to_stdout","title":"variable m_to_stdout","text":"<pre><code>bool ProcessStruct::m_to_stdout;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#variable-m_unfinished_line","title":"variable m_unfinished_line","text":"<pre><code>std::string ProcessStruct::m_unfinished_line;\n</code></pre>"},{"location":"apiProject1/classProcessStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classProcessStruct/#function-processstruct","title":"function ProcessStruct","text":"<pre><code>inline ProcessStruct::ProcessStruct (\n    const ProcessConfig &amp; __config\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/srcs/interchiplet.cpp</code></p>"},{"location":"apiProject1/group__benchmark__yaml/","title":"Group Benchmark_yaml","text":"<p>Modules &gt; Benchmark_yaml</p> <p>YAML configuration file interface. </p>"},{"location":"apiProject1/group__benchmark__yaml/#classes","title":"Classes","text":"Type Name class BenchmarkConfig Benchmark configuration structure. class ProcessConfig Data structure to configure one simulation process."},{"location":"apiProject1/classBenchmarkConfig/","title":"Class BenchmarkConfig","text":"<p>ClassList &gt; BenchmarkConfig</p> <p>Benchmark configuration structure. </p> <ul> <li><code>#include &lt;benchmark_yaml.h&gt;</code></li> </ul>"},{"location":"apiProject1/classBenchmarkConfig/#public-attributes","title":"Public Attributes","text":"Type Name std::string m_benchmark_root Environments. std::vector&lt; ProcessConfig &gt; m_phase1_proc_cfg_list List of configuration structures of phase 1. std::vector&lt; ProcessConfig &gt; m_phase2_proc_cfg_list List of configuration structures of phase 2. std::string m_simulator_root"},{"location":"apiProject1/classBenchmarkConfig/#public-functions","title":"Public Functions","text":"Type Name BenchmarkConfig (const std::string &amp; file_name) Parse YAML configuration file to get benchmark configuration. void yaml_parse (const YAML::Node &amp; config) Parse YAML configuration tree."},{"location":"apiProject1/classBenchmarkConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/classBenchmarkConfig/#variable-m_benchmark_root","title":"variable m_benchmark_root","text":"<pre><code>std::string BenchmarkConfig::m_benchmark_root;\n</code></pre>"},{"location":"apiProject1/classBenchmarkConfig/#variable-m_phase1_proc_cfg_list","title":"variable m_phase1_proc_cfg_list","text":"<pre><code>std::vector&lt;ProcessConfig&gt; BenchmarkConfig::m_phase1_proc_cfg_list;\n</code></pre>"},{"location":"apiProject1/classBenchmarkConfig/#variable-m_phase2_proc_cfg_list","title":"variable m_phase2_proc_cfg_list","text":"<pre><code>std::vector&lt;ProcessConfig&gt; BenchmarkConfig::m_phase2_proc_cfg_list;\n</code></pre>"},{"location":"apiProject1/classBenchmarkConfig/#variable-m_simulator_root","title":"variable m_simulator_root","text":"<pre><code>std::string BenchmarkConfig::m_simulator_root;\n</code></pre>"},{"location":"apiProject1/classBenchmarkConfig/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classBenchmarkConfig/#function-benchmarkconfig","title":"function BenchmarkConfig","text":"<p>Parse YAML configuration file to get benchmark configuration. <pre><code>inline BenchmarkConfig::BenchmarkConfig (\n    const std::string &amp; file_name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>file_name</code> Path of YAML configuration file. </li> </ul>"},{"location":"apiProject1/classBenchmarkConfig/#function-yaml_parse","title":"function yaml_parse","text":"<p>Parse YAML configuration tree. <pre><code>inline void BenchmarkConfig::yaml_parse (\n    const YAML::Node &amp; config\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>config</code> Top node of YAML Tree. </li> </ul> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/benchmark_yaml.h</code></p>"},{"location":"apiProject1/classProcessConfig/","title":"Class ProcessConfig","text":"<p>ClassList &gt; ProcessConfig</p> <p>Data structure to configure one simulation process. </p> <ul> <li><code>#include &lt;benchmark_yaml.h&gt;</code></li> </ul>"},{"location":"apiProject1/classProcessConfig/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; std::string &gt; m_args Arguments of simulation process. double m_clock_rate the rate of inter-simulator cycle convert. std::string m_command Command of simulation process. std::string m_log_file Path of logging name. std::string m_pre_copy Files copy to sub-directory of simulator before executing. bool m_to_stdout True means redirect output of this process to standard output."},{"location":"apiProject1/classProcessConfig/#public-functions","title":"Public Functions","text":"Type Name ProcessConfig (const std::string &amp; __cmd, const std::vector&lt; std::string &gt; &amp; __args, const std::string &amp; __log, bool __to_stdout, double __clock_rate, const std::string &amp; __pre_copy) Construct ProcessConfig ."},{"location":"apiProject1/classProcessConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/classProcessConfig/#variable-m_args","title":"variable m_args","text":"<pre><code>std::vector&lt;std::string&gt; ProcessConfig::m_args;\n</code></pre>"},{"location":"apiProject1/classProcessConfig/#variable-m_clock_rate","title":"variable m_clock_rate","text":"<pre><code>double ProcessConfig::m_clock_rate;\n</code></pre>"},{"location":"apiProject1/classProcessConfig/#variable-m_command","title":"variable m_command","text":"<pre><code>std::string ProcessConfig::m_command;\n</code></pre>"},{"location":"apiProject1/classProcessConfig/#variable-m_log_file","title":"variable m_log_file","text":"<pre><code>std::string ProcessConfig::m_log_file;\n</code></pre>"},{"location":"apiProject1/classProcessConfig/#variable-m_pre_copy","title":"variable m_pre_copy","text":"<pre><code>std::string ProcessConfig::m_pre_copy;\n</code></pre>"},{"location":"apiProject1/classProcessConfig/#variable-m_to_stdout","title":"variable m_to_stdout","text":"<pre><code>bool ProcessConfig::m_to_stdout;\n</code></pre>"},{"location":"apiProject1/classProcessConfig/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classProcessConfig/#function-processconfig","title":"function ProcessConfig","text":"<p>Construct ProcessConfig . <pre><code>inline ProcessConfig::ProcessConfig (\n    const std::string &amp; __cmd,\n    const std::vector&lt; std::string &gt; &amp; __args,\n    const std::string &amp; __log,\n    bool __to_stdout,\n    double __clock_rate,\n    const std::string &amp; __pre_copy\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command of simulation process. </li> <li><code>__args</code> Arguments of simulation process. </li> <li><code>__log</code> Path of logging name. </li> <li><code>__to_stdout</code> True means redirect output of this process to standard output. </li> <li><code>__clock_rate</code> the rate of inter-simulator cycle convert. </li> <li><code>__pre_copy</code> Files copy to sub-directory of simulator before executing. </li> </ul> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/benchmark_yaml.h</code></p>"},{"location":"apiProject1/group__cmd__handler__func/","title":"Group Cmd_handler_func","text":"<p>Modules &gt; Cmd_handler_func</p> <p>Functions to handle commands. </p>"},{"location":"apiProject1/group__cmd__handler__func/#public-functions","title":"Public Functions","text":"Type Name void handle_barrier_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle BARRIER command. void handle_cycle_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle CYCLE command. void handle_launch_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle LAUNCH command. void handle_lock_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle LOCK command. void handle_pipe_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle PIPE command. void handle_read_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle READ command. void handle_unlock_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle UNLOCK command. void handle_waitlaunch_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WAITLAUNCH command. void handle_write_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WRITE command."},{"location":"apiProject1/group__cmd__handler__func/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/group__cmd__handler__func/#function-handle_barrier_cmd","title":"function handle_barrier_cmd","text":"<p>Handle BARRIER command. <pre><code>void handle_barrier_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__func/#function-handle_cycle_cmd","title":"function handle_cycle_cmd","text":"<p>Handle CYCLE command. <pre><code>void handle_cycle_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__func/#function-handle_launch_cmd","title":"function handle_launch_cmd","text":"<p>Handle LAUNCH command. <pre><code>void handle_launch_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__func/#function-handle_lock_cmd","title":"function handle_lock_cmd","text":"<p>Handle LOCK command. <pre><code>void handle_lock_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__func/#function-handle_pipe_cmd","title":"function handle_pipe_cmd","text":"<p>Handle PIPE command. <pre><code>void handle_pipe_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__func/#function-handle_read_cmd","title":"function handle_read_cmd","text":"<p>Handle READ command. <pre><code>void handle_read_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__func/#function-handle_unlock_cmd","title":"function handle_unlock_cmd","text":"<p>Handle UNLOCK command. <pre><code>void handle_unlock_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__func/#function-handle_waitlaunch_cmd","title":"function handle_waitlaunch_cmd","text":"<p>Handle WAITLAUNCH command. <pre><code>void handle_waitlaunch_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__func/#function-handle_write_cmd","title":"function handle_write_cmd","text":"<p>Handle WRITE command. <pre><code>void handle_write_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/group__cmd__handler__struct/","title":"Group Cmd_handler_struct","text":"<p>Modules &gt; Cmd_handler_struct</p> <p>Structures for Command handler. </p>"},{"location":"apiProject1/group__cmd__handler__struct/#classes","title":"Classes","text":"Type Name class SyncBarrierStruct Structure for Barrier synchronization. class SyncClockStruct Structure for Clock synchronization. class SyncCommStruct Structure for Communication synchronization. class SyncLaunchStruct Structure for Launch and Wait-launch synchronization. class SyncLockStruct Structure for Lock and Unlock synchronization. class SyncPipeStruct Structure for Pipe synchronization. class SyncStruct Data structure of synchronize operation."},{"location":"apiProject1/group__cmd__handler__struct/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; InterChiplet::SyncCommand &gt; SyncCmdList List of synchronization commands."},{"location":"apiProject1/group__cmd__handler__struct/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiProject1/group__cmd__handler__struct/#typedef-synccmdlist","title":"typedef SyncCmdList","text":"<pre><code>typedef std::vector&lt;InterChiplet::SyncCommand&gt; SyncCmdList;\n</code></pre>"},{"location":"apiProject1/classSyncBarrierStruct/","title":"Class SyncBarrierStruct","text":"<p>ClassList &gt; SyncBarrierStruct</p> <p>Structure for Barrier synchronization. </p> <ul> <li><code>#include &lt;cmd_handler.h&gt;</code></li> </ul>"},{"location":"apiProject1/classSyncBarrierStruct/#public-functions","title":"Public Functions","text":"Type Name SyncCmdList &amp; barrierCmd (int __uid)  void insertBarrier (int __uid, int __count)  void insertBarrier (int __uid, int __count, const InterChiplet::SyncCommand &amp; __cmd)  bool overflow (int __uid)  void reset (int __uid)"},{"location":"apiProject1/classSyncBarrierStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classSyncBarrierStruct/#function-barriercmd","title":"function barrierCmd","text":"<pre><code>inline SyncCmdList &amp; SyncBarrierStruct::barrierCmd (\n    int __uid\n) \n</code></pre>"},{"location":"apiProject1/classSyncBarrierStruct/#function-insertbarrier-12","title":"function insertBarrier [1/2]","text":"<pre><code>inline void SyncBarrierStruct::insertBarrier (\n    int __uid,\n    int __count\n) \n</code></pre>"},{"location":"apiProject1/classSyncBarrierStruct/#function-insertbarrier-22","title":"function insertBarrier [2/2]","text":"<pre><code>inline void SyncBarrierStruct::insertBarrier (\n    int __uid,\n    int __count,\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncBarrierStruct/#function-overflow","title":"function overflow","text":"<pre><code>inline bool SyncBarrierStruct::overflow (\n    int __uid\n) \n</code></pre>"},{"location":"apiProject1/classSyncBarrierStruct/#function-reset","title":"function reset","text":"<pre><code>inline void SyncBarrierStruct::reset (\n    int __uid\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmd_handler.h</code></p>"},{"location":"apiProject1/classSyncClockStruct/","title":"Class SyncClockStruct","text":"<p>ClassList &gt; SyncClockStruct</p> <p>Structure for Clock synchronization. </p> <ul> <li><code>#include &lt;cmd_handler.h&gt;</code></li> </ul>"},{"location":"apiProject1/classSyncClockStruct/#public-functions","title":"Public Functions","text":"Type Name SyncClockStruct ()  InterChiplet::InnerTimeType cycle ()  void update (InterChiplet::InnerTimeType __cycle)"},{"location":"apiProject1/classSyncClockStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classSyncClockStruct/#function-syncclockstruct","title":"function SyncClockStruct","text":"<pre><code>inline SyncClockStruct::SyncClockStruct () \n</code></pre>"},{"location":"apiProject1/classSyncClockStruct/#function-cycle","title":"function cycle","text":"<pre><code>inline InterChiplet::InnerTimeType SyncClockStruct::cycle () \n</code></pre>"},{"location":"apiProject1/classSyncClockStruct/#function-update","title":"function update","text":"<pre><code>inline void SyncClockStruct::update (\n    InterChiplet::InnerTimeType __cycle\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmd_handler.h</code></p>"},{"location":"apiProject1/classSyncCommStruct/","title":"Class SyncCommStruct","text":"<p>ClassList &gt; SyncCommStruct</p> <p>Structure for Communication synchronization. </p> <ul> <li><code>#include &lt;cmd_handler.h&gt;</code></li> </ul>"},{"location":"apiProject1/classSyncCommStruct/#public-functions","title":"Public Functions","text":"Type Name bool hasMatchRead (const InterChiplet::SyncCommand &amp; __cmd)  bool hasMatchWrite (const InterChiplet::SyncCommand &amp; __cmd)  void insertRead (InterChiplet::SyncCommand &amp; __cmd)  void insertRead (const InterChiplet::SyncCommand &amp; __cmd)  void insertWrite (InterChiplet::SyncCommand &amp; __cmd)  void insertWrite (const InterChiplet::SyncCommand &amp; __cmd)  InterChiplet::SyncCommand popMatchRead (const InterChiplet::SyncCommand &amp; __cmd)  InterChiplet::SyncCommand popMatchWrite (const InterChiplet::SyncCommand &amp; __cmd)"},{"location":"apiProject1/classSyncCommStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classSyncCommStruct/#function-hasmatchread","title":"function hasMatchRead","text":"<pre><code>inline bool SyncCommStruct::hasMatchRead (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncCommStruct/#function-hasmatchwrite","title":"function hasMatchWrite","text":"<pre><code>inline bool SyncCommStruct::hasMatchWrite (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncCommStruct/#function-insertread-12","title":"function insertRead [1/2]","text":"<pre><code>inline void SyncCommStruct::insertRead (\n    InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncCommStruct/#function-insertread-22","title":"function insertRead [2/2]","text":"<pre><code>inline void SyncCommStruct::insertRead (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncCommStruct/#function-insertwrite-12","title":"function insertWrite [1/2]","text":"<pre><code>inline void SyncCommStruct::insertWrite (\n    InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncCommStruct/#function-insertwrite-22","title":"function insertWrite [2/2]","text":"<pre><code>inline void SyncCommStruct::insertWrite (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncCommStruct/#function-popmatchread","title":"function popMatchRead","text":"<pre><code>inline InterChiplet::SyncCommand SyncCommStruct::popMatchRead (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncCommStruct/#function-popmatchwrite","title":"function popMatchWrite","text":"<pre><code>inline InterChiplet::SyncCommand SyncCommStruct::popMatchWrite (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmd_handler.h</code></p>"},{"location":"apiProject1/classSyncLaunchStruct/","title":"Class SyncLaunchStruct","text":"<p>ClassList &gt; SyncLaunchStruct</p> <p>Structure for Launch and Wait-launch synchronization. </p> <ul> <li><code>#include &lt;cmd_handler.h&gt;</code></li> </ul>"},{"location":"apiProject1/classSyncLaunchStruct/#public-functions","title":"Public Functions","text":"Type Name bool hasMatchLaunch (const InterChiplet::SyncCommand &amp; __cmd)  bool hasMatchWaitlaunch (const InterChiplet::SyncCommand &amp; __cmd)  void insertLaunch (InterChiplet::SyncCommand &amp; __cmd)  void insertLaunch (const InterChiplet::SyncCommand &amp; __cmd)  void insertWaitlaunch (InterChiplet::SyncCommand &amp; __cmd)  void insertWaitlaunch (const InterChiplet::SyncCommand &amp; __cmd)  InterChiplet::SyncCommand popMatchLaunch (const InterChiplet::SyncCommand &amp; __cmd)  InterChiplet::SyncCommand popMatchWaitlaunch (const InterChiplet::SyncCommand &amp; __cmd)"},{"location":"apiProject1/classSyncLaunchStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classSyncLaunchStruct/#function-hasmatchlaunch","title":"function hasMatchLaunch","text":"<pre><code>inline bool SyncLaunchStruct::hasMatchLaunch (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLaunchStruct/#function-hasmatchwaitlaunch","title":"function hasMatchWaitlaunch","text":"<pre><code>inline bool SyncLaunchStruct::hasMatchWaitlaunch (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLaunchStruct/#function-insertlaunch-12","title":"function insertLaunch [1/2]","text":"<pre><code>inline void SyncLaunchStruct::insertLaunch (\n    InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLaunchStruct/#function-insertlaunch-22","title":"function insertLaunch [2/2]","text":"<pre><code>inline void SyncLaunchStruct::insertLaunch (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLaunchStruct/#function-insertwaitlaunch-12","title":"function insertWaitlaunch [1/2]","text":"<pre><code>inline void SyncLaunchStruct::insertWaitlaunch (\n    InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLaunchStruct/#function-insertwaitlaunch-22","title":"function insertWaitlaunch [2/2]","text":"<pre><code>inline void SyncLaunchStruct::insertWaitlaunch (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLaunchStruct/#function-popmatchlaunch","title":"function popMatchLaunch","text":"<pre><code>inline InterChiplet::SyncCommand SyncLaunchStruct::popMatchLaunch (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLaunchStruct/#function-popmatchwaitlaunch","title":"function popMatchWaitlaunch","text":"<pre><code>inline InterChiplet::SyncCommand SyncLaunchStruct::popMatchWaitlaunch (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmd_handler.h</code></p>"},{"location":"apiProject1/classSyncLockStruct/","title":"Class SyncLockStruct","text":"<p>ClassList &gt; SyncLockStruct</p> <p>Structure for Lock and Unlock synchronization. </p> <ul> <li><code>#include &lt;cmd_handler.h&gt;</code></li> </ul>"},{"location":"apiProject1/classSyncLockStruct/#public-functions","title":"Public Functions","text":"Type Name InterChiplet::SyncCommand getLastCmd (int __uid)  bool hasLastCmd (int __uid)  bool hasLockCmd (int __uid)  bool hasLockCmd (int __uid, const InterChiplet::AddrType &amp; __src)  void insertLockCmd (int __uid, const InterChiplet::SyncCommand &amp; __cmd)  bool isLocked (int __uid)  void lock (int __uid, const InterChiplet::SyncCommand &amp; __cmd)  InterChiplet::SyncCommand popLockCmd (int __uid)  InterChiplet::SyncCommand popLockCmd (int __uid, const InterChiplet::AddrType &amp; __src)  void unlock (int __uid, const InterChiplet::SyncCommand &amp; __cmd)"},{"location":"apiProject1/classSyncLockStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classSyncLockStruct/#function-getlastcmd","title":"function getLastCmd","text":"<pre><code>inline InterChiplet::SyncCommand SyncLockStruct::getLastCmd (\n    int __uid\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-haslastcmd","title":"function hasLastCmd","text":"<pre><code>inline bool SyncLockStruct::hasLastCmd (\n    int __uid\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-haslockcmd-12","title":"function hasLockCmd [1/2]","text":"<pre><code>inline bool SyncLockStruct::hasLockCmd (\n    int __uid\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-haslockcmd-22","title":"function hasLockCmd [2/2]","text":"<pre><code>inline bool SyncLockStruct::hasLockCmd (\n    int __uid,\n    const InterChiplet::AddrType &amp; __src\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-insertlockcmd","title":"function insertLockCmd","text":"<pre><code>inline void SyncLockStruct::insertLockCmd (\n    int __uid,\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-islocked","title":"function isLocked","text":"<pre><code>inline bool SyncLockStruct::isLocked (\n    int __uid\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-lock","title":"function lock","text":"<pre><code>inline void SyncLockStruct::lock (\n    int __uid,\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-poplockcmd-12","title":"function popLockCmd [1/2]","text":"<pre><code>inline InterChiplet::SyncCommand SyncLockStruct::popLockCmd (\n    int __uid\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-poplockcmd-22","title":"function popLockCmd [2/2]","text":"<pre><code>inline InterChiplet::SyncCommand SyncLockStruct::popLockCmd (\n    int __uid,\n    const InterChiplet::AddrType &amp; __src\n) \n</code></pre>"},{"location":"apiProject1/classSyncLockStruct/#function-unlock","title":"function unlock","text":"<pre><code>inline void SyncLockStruct::unlock (\n    int __uid,\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmd_handler.h</code></p>"},{"location":"apiProject1/classSyncPipeStruct/","title":"Class SyncPipeStruct","text":"<p>ClassList &gt; SyncPipeStruct</p> <p>Structure for Pipe synchronization. </p> <ul> <li><code>#include &lt;cmd_handler.h&gt;</code></li> </ul>"},{"location":"apiProject1/classSyncPipeStruct/#public-functions","title":"Public Functions","text":"Type Name void insert (std::string &amp; __name)  void insert (const std::string &amp; __name)  std::set&lt; std::string &gt; pipeSet ()  const std::set&lt; std::string &gt; &amp; pipeSet () const"},{"location":"apiProject1/classSyncPipeStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classSyncPipeStruct/#function-insert-12","title":"function insert [1/2]","text":"<pre><code>inline void SyncPipeStruct::insert (\n    std::string &amp; __name\n) \n</code></pre>"},{"location":"apiProject1/classSyncPipeStruct/#function-insert-22","title":"function insert [2/2]","text":"<pre><code>inline void SyncPipeStruct::insert (\n    const std::string &amp; __name\n) \n</code></pre>"},{"location":"apiProject1/classSyncPipeStruct/#function-pipeset-12","title":"function pipeSet [1/2]","text":"<pre><code>inline std::set&lt; std::string &gt; SyncPipeStruct::pipeSet () \n</code></pre>"},{"location":"apiProject1/classSyncPipeStruct/#function-pipeset-22","title":"function pipeSet [2/2]","text":"<pre><code>inline const std::set&lt; std::string &gt; &amp; SyncPipeStruct::pipeSet () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmd_handler.h</code></p>"},{"location":"apiProject1/classSyncStruct/","title":"Class SyncStruct","text":"<p>ClassList &gt; SyncStruct</p> <p>Data structure of synchronize operation. </p> <ul> <li><code>#include &lt;cmd_handler.h&gt;</code></li> </ul>"},{"location":"apiProject1/classSyncStruct/#public-attributes","title":"Public Attributes","text":"Type Name SyncBarrierStruct m_barrier_struct Barrier behavior. SyncBarrierStruct m_barrier_timing_struct Barrier timing behavior. NetworkBenchList m_bench_list Benchmark list, recording the communication transactions have sent out. SyncCommStruct m_comm_struct Communication behavior. SyncClockStruct m_cycle_struct Global simulation cycle, which is the largest notified cycle count. NetworkDelayStruct m_delay_list Delay list, recording the delay of each communication transactions. SyncLaunchStruct m_launch_struct Launch behavior. SyncLockStruct m_lock_struct Lock behavior. SyncLockStruct m_lock_timing_struct Lock behavior. pthread_mutex_t m_mutex Mutex to access this structure. SyncPipeStruct m_pipe_struct Pipe behavior."},{"location":"apiProject1/classSyncStruct/#public-functions","title":"Public Functions","text":"Type Name SyncStruct () Construct synchronize stucture. ~SyncStruct () Destory synchronize structure."},{"location":"apiProject1/classSyncStruct/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/classSyncStruct/#variable-m_barrier_struct","title":"variable m_barrier_struct","text":"<pre><code>SyncBarrierStruct SyncStruct::m_barrier_struct;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_barrier_timing_struct","title":"variable m_barrier_timing_struct","text":"<pre><code>SyncBarrierStruct SyncStruct::m_barrier_timing_struct;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_bench_list","title":"variable m_bench_list","text":"<pre><code>NetworkBenchList SyncStruct::m_bench_list;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_comm_struct","title":"variable m_comm_struct","text":"<pre><code>SyncCommStruct SyncStruct::m_comm_struct;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_cycle_struct","title":"variable m_cycle_struct","text":"<pre><code>SyncClockStruct SyncStruct::m_cycle_struct;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_delay_list","title":"variable m_delay_list","text":"<pre><code>NetworkDelayStruct SyncStruct::m_delay_list;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_launch_struct","title":"variable m_launch_struct","text":"<pre><code>SyncLaunchStruct SyncStruct::m_launch_struct;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_lock_struct","title":"variable m_lock_struct","text":"<pre><code>SyncLockStruct SyncStruct::m_lock_struct;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_lock_timing_struct","title":"variable m_lock_timing_struct","text":"<pre><code>SyncLockStruct SyncStruct::m_lock_timing_struct;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_mutex","title":"variable m_mutex","text":"<pre><code>pthread_mutex_t SyncStruct::m_mutex;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#variable-m_pipe_struct","title":"variable m_pipe_struct","text":"<pre><code>SyncPipeStruct SyncStruct::m_pipe_struct;\n</code></pre>"},{"location":"apiProject1/classSyncStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classSyncStruct/#function-syncstruct","title":"function SyncStruct","text":"<p>Construct synchronize stucture. <pre><code>inline SyncStruct::SyncStruct () \n</code></pre></p> <p>Initializete mutex. </p>"},{"location":"apiProject1/classSyncStruct/#function-syncstruct_1","title":"function ~SyncStruct","text":"<p>Destory synchronize structure. <pre><code>inline SyncStruct::~SyncStruct () \n</code></pre></p> <p>Destory mutex. </p> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmd_handler.h</code></p>"},{"location":"apiProject1/group__apis__for__cpu/","title":"Group apis_for_cpu","text":"<p>Modules &gt; apis_for_cpu</p> <p>APIs for CPU. </p>"},{"location":"apiProject1/group__apis__for__cpu/#public-functions","title":"Public Functions","text":"Type Name syscall_return_t InterChiplet::barrier (int64_t __uid, int64_t __src_x, int64_t __src_y, int64_t __count=0) Barrier. syscall_return_t InterChiplet::launch (int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y) Launch application to remote chiplet. syscall_return_t InterChiplet::lock (int64_t __uid, int64_t __src_x, int64_t __src_y) Lock mutex. syscall_return_t InterChiplet::receiveMessage (int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y, void * __addr, int64_t __nbyte) Read data from remote chiplet. syscall_return_t InterChiplet::sendMessage (int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y, void * __addr, int64_t __nbyte) Send data to remote chiplet. syscall_return_t InterChiplet::unlock (int64_t __uid, int64_t __src_x, int64_t __src_y) Unlock mutex. syscall_return_t InterChiplet::waitLaunch (int64_t __dst_x, int64_t __dst_y, int64_t * __src_x, int64_t * __src_y) Wait launch from remote chiplet."},{"location":"apiProject1/group__apis__for__cpu/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/group__apis__for__cpu/#function-barrier","title":"function barrier","text":"<p>Barrier. <pre><code>syscall_return_t InterChiplet::barrier (\n    int64_t __uid,\n    int64_t __src_x,\n    int64_t __src_y,\n    int64_t __count=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Barrier ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__count</code> Number of threads to barrier. </li> </ul>"},{"location":"apiProject1/group__apis__for__cpu/#function-launch","title":"function launch","text":"<p>Launch application to remote chiplet. <pre><code>syscall_return_t InterChiplet::launch (\n    int64_t __dst_x,\n    int64_t __dst_y,\n    int64_t __src_x,\n    int64_t __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__apis__for__cpu/#function-lock","title":"function lock","text":"<p>Lock mutex. <pre><code>syscall_return_t InterChiplet::lock (\n    int64_t __uid,\n    int64_t __src_x,\n    int64_t __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Mutex ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__apis__for__cpu/#function-receivemessage","title":"function receiveMessage","text":"<p>Read data from remote chiplet. <pre><code>syscall_return_t InterChiplet::receiveMessage (\n    int64_t __dst_x,\n    int64_t __dst_y,\n    int64_t __src_x,\n    int64_t __src_y,\n    void * __addr,\n    int64_t __nbyte\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__addr</code> Data address. </li> <li><code>__nbyte</code> Number of bytes. </li> </ul>"},{"location":"apiProject1/group__apis__for__cpu/#function-sendmessage","title":"function sendMessage","text":"<p>Send data to remote chiplet. <pre><code>syscall_return_t InterChiplet::sendMessage (\n    int64_t __dst_x,\n    int64_t __dst_y,\n    int64_t __src_x,\n    int64_t __src_y,\n    void * __addr,\n    int64_t __nbyte\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__addr</code> Data address. </li> <li><code>__nbyte</code> Number of bytes. </li> </ul>"},{"location":"apiProject1/group__apis__for__cpu/#function-unlock","title":"function unlock","text":"<p>Unlock mutex. <pre><code>syscall_return_t InterChiplet::unlock (\n    int64_t __uid,\n    int64_t __src_x,\n    int64_t __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Mutex ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__apis__for__cpu/#function-waitlaunch","title":"function waitLaunch","text":"<p>Wait launch from remote chiplet. <pre><code>syscall_return_t InterChiplet::waitLaunch (\n    int64_t __dst_x,\n    int64_t __dst_y,\n    int64_t * __src_x,\n    int64_t * __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. Return value. </li> <li><code>__src_y</code> Source address in Y-axis. Return value. </li> </ul>"},{"location":"apiProject1/group__apis__for__cuda/","title":"Group apis_for_cuda","text":"<p>Modules &gt; apis_for_cuda</p> <p>APIs for CUDA. </p>"},{"location":"apiProject1/group__apis__for__cuda/#public-functions","title":"Public Functions","text":"Type Name __host__ cudaError_t CUDARTAPI barrier (int __uid, int __src_x, int __src_y, int __count=0) Barrier. __host__ cudaError_t CUDARTAPI launch (int __dst_x, int __dst_y, int __src_x, int __src_y) Launch application to remote chiplet. __host__ cudaError_t CUDARTAPI lock (int __uid, int __src_x, int __src_y) Lock mutex. __host__ cudaError_t CUDARTAPI receiveMessage (int __dst_x, int __dst_y, int __src_x, int __srx_y, void * __addr, int __nbyte) Read data from remote chiplet. __host__ cudaError_t CUDARTAPI sendMessage (int __dst_x, int __dst_y, int __src_x, int __srx_y, void * __addr, int __nbyte) Send data to remote chiplet. __host__ cudaError_t CUDARTAPI unlock (int __uid, int __src_x, int __src_y) Unlock mutex. __host__ cudaError_t CUDARTAPI waitLaunch (int __dst_x, int __dst_y, int * __src_x, int * __src_y) Wait launch from remote chiplet."},{"location":"apiProject1/group__apis__for__cuda/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/group__apis__for__cuda/#function-barrier","title":"function barrier","text":"<p>Barrier. <pre><code>__host__ cudaError_t CUDARTAPI barrier (\n    int __uid,\n    int __src_x,\n    int __src_y,\n    int __count=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Barrier ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__count</code> Number of threads to barrier. </li> </ul>"},{"location":"apiProject1/group__apis__for__cuda/#function-launch","title":"function launch","text":"<p>Launch application to remote chiplet. <pre><code>__host__ cudaError_t CUDARTAPI launch (\n    int __dst_x,\n    int __dst_y,\n    int __src_x,\n    int __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__apis__for__cuda/#function-lock","title":"function lock","text":"<p>Lock mutex. <pre><code>__host__ cudaError_t CUDARTAPI lock (\n    int __uid,\n    int __src_x,\n    int __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Mutex ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__apis__for__cuda/#function-receivemessage","title":"function receiveMessage","text":"<p>Read data from remote chiplet. <pre><code>__host__ cudaError_t CUDARTAPI receiveMessage (\n    int __dst_x,\n    int __dst_y,\n    int __src_x,\n    int __srx_y,\n    void * __addr,\n    int __nbyte\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__addr</code> Data address. </li> <li><code>__nbyte</code> Number of bytes. </li> </ul>"},{"location":"apiProject1/group__apis__for__cuda/#function-sendmessage","title":"function sendMessage","text":"<p>Send data to remote chiplet. <pre><code>__host__ cudaError_t CUDARTAPI sendMessage (\n    int __dst_x,\n    int __dst_y,\n    int __src_x,\n    int __srx_y,\n    void * __addr,\n    int __nbyte\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__addr</code> Data address. </li> <li><code>__nbyte</code> Number of bytes. </li> </ul>"},{"location":"apiProject1/group__apis__for__cuda/#function-unlock","title":"function unlock","text":"<p>Unlock mutex. <pre><code>__host__ cudaError_t CUDARTAPI unlock (\n    int __uid,\n    int __src_x,\n    int __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Mutex ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__apis__for__cuda/#function-waitlaunch","title":"function waitLaunch","text":"<p>Wait launch from remote chiplet. <pre><code>__host__ cudaError_t CUDARTAPI waitLaunch (\n    int __dst_x,\n    int __dst_y,\n    int * __src_x,\n    int * __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__cmdline/","title":"Group cmdline","text":"<p>Modules &gt; cmdline</p> <p>Command line parser. </p>"},{"location":"apiProject1/group__cmdline/#classes","title":"Classes","text":"Type Name class CmdLineOptions Options from command line."},{"location":"apiProject1/classCmdLineOptions/","title":"Class CmdLineOptions","text":"<p>ClassList &gt; CmdLineOptions</p> <p>Options from command line. </p> <ul> <li><code>#include &lt;cmdline_options.h&gt;</code></li> </ul>"},{"location":"apiProject1/classCmdLineOptions/#public-attributes","title":"Public Attributes","text":"Type Name std::string m_bench Path of benchmark configuration yaml. std::string m_cwd New working directory. bool m_debug Print debug information. double m_err_rate_threshold Error rate threshold, used to quit iteration. long m_timeout_threshold Timeout threshold, in term of round."},{"location":"apiProject1/classCmdLineOptions/#public-functions","title":"Public Functions","text":"Type Name CmdLineOptions () Constructor. int parse (int argc, const char * argv) Read options from command line."},{"location":"apiProject1/classCmdLineOptions/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/classCmdLineOptions/#variable-m_bench","title":"variable m_bench","text":"<pre><code>std::string CmdLineOptions::m_bench;\n</code></pre>"},{"location":"apiProject1/classCmdLineOptions/#variable-m_cwd","title":"variable m_cwd","text":"<pre><code>std::string CmdLineOptions::m_cwd;\n</code></pre>"},{"location":"apiProject1/classCmdLineOptions/#variable-m_debug","title":"variable m_debug","text":"<pre><code>bool CmdLineOptions::m_debug;\n</code></pre>"},{"location":"apiProject1/classCmdLineOptions/#variable-m_err_rate_threshold","title":"variable m_err_rate_threshold","text":"<pre><code>double CmdLineOptions::m_err_rate_threshold;\n</code></pre>"},{"location":"apiProject1/classCmdLineOptions/#variable-m_timeout_threshold","title":"variable m_timeout_threshold","text":"<pre><code>long CmdLineOptions::m_timeout_threshold;\n</code></pre>"},{"location":"apiProject1/classCmdLineOptions/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classCmdLineOptions/#function-cmdlineoptions","title":"function CmdLineOptions","text":"<pre><code>inline CmdLineOptions::CmdLineOptions () \n</code></pre>"},{"location":"apiProject1/classCmdLineOptions/#function-parse","title":"function parse","text":"<p>Read options from command line. <pre><code>inline int CmdLineOptions::parse (\n    int argc,\n    const char * argv\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>argc</code> Number of argument. </li> <li><code>argv</code> String of argument. </li> </ul> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmdline_options.h</code></p>"},{"location":"apiProject1/group__net__bench/","title":"Group net_bench","text":"<p>Modules &gt; net_bench</p> <p>Network benchmark interface. </p>"},{"location":"apiProject1/group__net__bench/#classes","title":"Classes","text":"Type Name class NetworkBenchItem Structure of one package in network. class NetworkBenchList List of network benchmark item."},{"location":"apiProject1/classNetworkBenchItem/","title":"Class NetworkBenchItem","text":"<p>ClassList &gt; NetworkBenchItem</p> <p>Structure of one package in network. </p> <ul> <li><code>#include &lt;net_bench.h&gt;</code></li> </ul>"},{"location":"apiProject1/classNetworkBenchItem/#public-attributes","title":"Public Attributes","text":"Type Name long m_desc Synchronization protocol descriptor. InterChiplet::AddrType m_dst Destination address. InterChiplet::InnerTimeType m_dst_cycle Package injection cycle from the destination side. uint64_t m_id Packate id. (Not used yet.) int m_pac_size Size of package in bytes. InterChiplet::AddrType m_src Source address. InterChiplet::InnerTimeType m_src_cycle Package injection cycle from the source side."},{"location":"apiProject1/classNetworkBenchItem/#public-functions","title":"Public Functions","text":"Type Name NetworkBenchItem () Construct Empty NetworkBenchItem . NetworkBenchItem (const InterChiplet::SyncCommand &amp; __src_cmd, const InterChiplet::SyncCommand &amp; __dst_cmd) Construct NetworkBenchItem from SyncCommand. NetworkBenchItem (const InterChiplet::SyncCommand &amp; __src_cmd) Construct NetworkBenchItem from SyncCommand."},{"location":"apiProject1/classNetworkBenchItem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/classNetworkBenchItem/#variable-m_desc","title":"variable m_desc","text":"<pre><code>long NetworkBenchItem::m_desc;\n</code></pre>"},{"location":"apiProject1/classNetworkBenchItem/#variable-m_dst","title":"variable m_dst","text":"<pre><code>InterChiplet::AddrType NetworkBenchItem::m_dst;\n</code></pre>"},{"location":"apiProject1/classNetworkBenchItem/#variable-m_dst_cycle","title":"variable m_dst_cycle","text":"<pre><code>InterChiplet::InnerTimeType NetworkBenchItem::m_dst_cycle;\n</code></pre>"},{"location":"apiProject1/classNetworkBenchItem/#variable-m_id","title":"variable m_id","text":"<pre><code>uint64_t NetworkBenchItem::m_id;\n</code></pre>"},{"location":"apiProject1/classNetworkBenchItem/#variable-m_pac_size","title":"variable m_pac_size","text":"<pre><code>int NetworkBenchItem::m_pac_size;\n</code></pre>"},{"location":"apiProject1/classNetworkBenchItem/#variable-m_src","title":"variable m_src","text":"<pre><code>InterChiplet::AddrType NetworkBenchItem::m_src;\n</code></pre>"},{"location":"apiProject1/classNetworkBenchItem/#variable-m_src_cycle","title":"variable m_src_cycle","text":"<pre><code>InterChiplet::InnerTimeType NetworkBenchItem::m_src_cycle;\n</code></pre>"},{"location":"apiProject1/classNetworkBenchItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classNetworkBenchItem/#function-networkbenchitem-13","title":"function NetworkBenchItem [1/3]","text":"<pre><code>inline NetworkBenchItem::NetworkBenchItem () \n</code></pre>"},{"location":"apiProject1/classNetworkBenchItem/#function-networkbenchitem-23","title":"function NetworkBenchItem [2/3]","text":"<p>Construct NetworkBenchItem from SyncCommand. <pre><code>inline NetworkBenchItem::NetworkBenchItem (\n    const InterChiplet::SyncCommand &amp; __src_cmd,\n    const InterChiplet::SyncCommand &amp; __dst_cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_cmd</code> Structure of source command. </li> <li><code>__dst_cmd</code> Structure of destination command. </li> </ul>"},{"location":"apiProject1/classNetworkBenchItem/#function-networkbenchitem-33","title":"function NetworkBenchItem [3/3]","text":"<p>Construct NetworkBenchItem from SyncCommand. <pre><code>inline NetworkBenchItem::NetworkBenchItem (\n    const InterChiplet::SyncCommand &amp; __src_cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_cmd</code> Structure of source command. <pre><code>## Friends Documentation\n</code></pre> </li> </ul>"},{"location":"apiProject1/classNetworkBenchItem/#friend-operator","title":"friend operator&lt;&lt;","text":"<p>Overloading operator &lt;&lt;. <pre><code>inline friend std::ostream &amp; NetworkBenchItem::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const NetworkBenchItem &amp; __item\n) \n</code></pre></p> <p>Write NetworkBenchItem to output stream. </p>"},{"location":"apiProject1/classNetworkBenchItem/#friend-operator_1","title":"friend operator&gt;&gt;","text":"<p>Overloading operator &gt;&gt;. <pre><code>inline friend std::istream &amp; NetworkBenchItem::operator&gt;&gt; (\n    std::istream &amp; os,\n    NetworkBenchItem &amp; __item\n) \n</code></pre></p> <p>Read NetworkBenchItem from input stream. </p> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/net_bench.h</code></p>"},{"location":"apiProject1/classNetworkBenchList/","title":"Class NetworkBenchList","text":"<p>ClassList &gt; NetworkBenchList</p> <p>List of network benchmark item. </p> <ul> <li><code>#include &lt;net_bench.h&gt;</code></li> </ul> <p>Inherits the following classes: std::multimap&lt; InterChiplet::InnerTimeType, NetworkBenchItem &gt;</p>"},{"location":"apiProject1/classNetworkBenchList/#public-functions","title":"Public Functions","text":"Type Name NetworkBenchList () Construct NetworkBenchList . void dumpBench (const std::string &amp; __file_name, double __clock_rate) Dump benchmark list to specified file. void insert (const NetworkBenchItem &amp; __item) Insert item into list."},{"location":"apiProject1/classNetworkBenchList/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classNetworkBenchList/#function-networkbenchlist","title":"function NetworkBenchList","text":"<pre><code>inline NetworkBenchList::NetworkBenchList () \n</code></pre>"},{"location":"apiProject1/classNetworkBenchList/#function-dumpbench","title":"function dumpBench","text":"<p>Dump benchmark list to specified file. <pre><code>inline void NetworkBenchList::dumpBench (\n    const std::string &amp; __file_name,\n    double __clock_rate\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__file_name</code> Path to benchmark file. </li> <li><code>__clock_rate</code> Clock ratio (Simulator clock/Interchiplet clock). </li> </ul>"},{"location":"apiProject1/classNetworkBenchList/#function-insert","title":"function insert","text":"<p>Insert item into list. <pre><code>inline void NetworkBenchList::insert (\n    const NetworkBenchItem &amp; __item\n) \n</code></pre></p> <p>Take the start cycle on source side as ordering key. </p> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/net_bench.h</code></p>"},{"location":"apiProject1/group__net__delay/","title":"Group net_delay","text":"<p>Modules &gt; net_delay</p> <p>Network latency information interface. </p>"},{"location":"apiProject1/group__net__delay/#classes","title":"Classes","text":"Type Name class NetworkDelayItem Structure presents delay of one package in network. class NetworkDelayMap Map for network delay information. class NetworkDelayStruct List of network delay item."},{"location":"apiProject1/group__net__delay/#public-types","title":"Public Types","text":"Type Name typedef std::tuple&lt; InterChiplet::InnerTimeType, InterChiplet::InnerTimeType &gt; CmdDelayPair typedef std::multimap&lt; InterChiplet::InnerTimeType, NetworkDelayItem &gt; NetworkDelayOrder"},{"location":"apiProject1/group__net__delay/#macros","title":"Macros","text":"Type Name define DST_DELAY (pair) std::get&lt;1&gt;(pair) define SRC_DELAY (pair) std::get&lt;0&gt;(pair)"},{"location":"apiProject1/group__net__delay/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiProject1/group__net__delay/#typedef-cmddelaypair","title":"typedef CmdDelayPair","text":"<pre><code>typedef std::tuple&lt;InterChiplet::InnerTimeType, InterChiplet::InnerTimeType&gt; CmdDelayPair;\n</code></pre>"},{"location":"apiProject1/group__net__delay/#typedef-networkdelayorder","title":"typedef NetworkDelayOrder","text":"<pre><code>typedef std::multimap&lt;InterChiplet::InnerTimeType, NetworkDelayItem&gt; NetworkDelayOrder;\n</code></pre>"},{"location":"apiProject1/group__net__delay/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiProject1/group__net__delay/#define-dst_delay","title":"define DST_DELAY","text":"<pre><code>#define DST_DELAY (\n    pair\n) std::get&lt;1&gt;(pair)\n</code></pre>"},{"location":"apiProject1/group__net__delay/#define-src_delay","title":"define SRC_DELAY","text":"<pre><code>#define SRC_DELAY (\n    pair\n) std::get&lt;0&gt;(pair)\n</code></pre>"},{"location":"apiProject1/classNetworkDelayItem/","title":"Class NetworkDelayItem","text":"<p>ClassList &gt; NetworkDelayItem</p> <p>Structure presents delay of one package in network. </p> <ul> <li><code>#include &lt;net_delay.h&gt;</code></li> </ul>"},{"location":"apiProject1/classNetworkDelayItem/#public-attributes","title":"Public Attributes","text":"Type Name InterChiplet::InnerTimeType m_cycle Package injection cycle. Used to order packages. std::vector&lt; InterChiplet::InnerTimeType &gt; m_delay_list Delay of packages. long m_desc Synchronization protocol descriptor. InterChiplet::AddrType m_dst Destination address. uint64_t m_id Packate id. (Not used yet.) InterChiplet::AddrType m_src Source address."},{"location":"apiProject1/classNetworkDelayItem/#public-functions","title":"Public Functions","text":"Type Name NetworkDelayItem () Construct Empty NetworkDelayItem . NetworkDelayItem (InterChiplet::InnerTimeType __cycle, const InterChiplet::AddrType &amp; __src, const InterChiplet::AddrType &amp; __dst, long __desc, const std::vector&lt; InterChiplet::InnerTimeType &gt; &amp; __delay_list) Construct NetworkDelayItem ."},{"location":"apiProject1/classNetworkDelayItem/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"apiProject1/classNetworkDelayItem/#variable-m_cycle","title":"variable m_cycle","text":"<pre><code>InterChiplet::InnerTimeType NetworkDelayItem::m_cycle;\n</code></pre>"},{"location":"apiProject1/classNetworkDelayItem/#variable-m_delay_list","title":"variable m_delay_list","text":"<p>Delay of packages. <pre><code>std::vector&lt;InterChiplet::InnerTimeType&gt; NetworkDelayItem::m_delay_list;\n</code></pre></p> <p>Each package has two delay values. The first value is the delay from the write side, and the second value is the delay from the read side. </p>"},{"location":"apiProject1/classNetworkDelayItem/#variable-m_desc","title":"variable m_desc","text":"<pre><code>long NetworkDelayItem::m_desc;\n</code></pre>"},{"location":"apiProject1/classNetworkDelayItem/#variable-m_dst","title":"variable m_dst","text":"<pre><code>InterChiplet::AddrType NetworkDelayItem::m_dst;\n</code></pre>"},{"location":"apiProject1/classNetworkDelayItem/#variable-m_id","title":"variable m_id","text":"<pre><code>uint64_t NetworkDelayItem::m_id;\n</code></pre>"},{"location":"apiProject1/classNetworkDelayItem/#variable-m_src","title":"variable m_src","text":"<pre><code>InterChiplet::AddrType NetworkDelayItem::m_src;\n</code></pre>"},{"location":"apiProject1/classNetworkDelayItem/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classNetworkDelayItem/#function-networkdelayitem-12","title":"function NetworkDelayItem [1/2]","text":"<pre><code>inline NetworkDelayItem::NetworkDelayItem () \n</code></pre>"},{"location":"apiProject1/classNetworkDelayItem/#function-networkdelayitem-22","title":"function NetworkDelayItem [2/2]","text":"<p>Construct NetworkDelayItem . <pre><code>inline NetworkDelayItem::NetworkDelayItem (\n    InterChiplet::InnerTimeType __cycle,\n    const InterChiplet::AddrType &amp; __src,\n    const InterChiplet::AddrType &amp; __dst,\n    long __desc,\n    const std::vector&lt; InterChiplet::InnerTimeType &gt; &amp; __delay_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Package injection cycle. </li> <li><code>__src</code> Source address. </li> <li><code>__dst</code> Destination address. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> <li><code>__delay_list</code> List of package delays. <pre><code>## Friends Documentation\n</code></pre> </li> </ul>"},{"location":"apiProject1/classNetworkDelayItem/#friend-operator","title":"friend operator&lt;&lt;","text":"<p>Overloading operator &lt;&lt;. <pre><code>inline friend std::ostream &amp; NetworkDelayItem::operator&lt;&lt; (\n    std::ostream &amp; os,\n    const NetworkDelayItem &amp; __item\n) \n</code></pre></p> <p>Write NetworkDelayItem to output stream. </p>"},{"location":"apiProject1/classNetworkDelayItem/#friend-operator_1","title":"friend operator&gt;&gt;","text":"<p>Overloading operator &gt;&gt;. <pre><code>inline friend std::istream &amp; NetworkDelayItem::operator&gt;&gt; (\n    std::istream &amp; os,\n    NetworkDelayItem &amp; __item\n) \n</code></pre></p> <p>Read NetworkDelayItem from input stream. </p> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/net_delay.h</code></p>"},{"location":"apiProject1/classNetworkDelayMap/","title":"Class NetworkDelayMap","text":"<p>ClassList &gt; NetworkDelayMap</p> <p>Map for network delay information. </p> <ul> <li><code>#include &lt;net_delay.h&gt;</code></li> </ul> <p>Inherits the following classes: std::map&lt; InterChiplet::AddrType, NetworkDelayOrder &gt;</p>"},{"location":"apiProject1/classNetworkDelayMap/#public-functions","title":"Public Functions","text":"Type Name bool checkOrderOfCommand (const InterChiplet::SyncCommand &amp; __cmd) Check the order of write/read commands. NetworkDelayItem front (const InterChiplet::AddrType &amp; __addr) Return the first delay information for the specified address. NetworkDelayItem front (const InterChiplet::AddrType &amp; __addr, const InterChiplet::AddrType &amp; __src, const InterChiplet::AddrType &amp; __dst) Return the first delay information for the specified address. bool hasAddr (const InterChiplet::AddrType &amp; __addr) Check whether there is delay information for the specified address. bool hasAddr (const InterChiplet::AddrType &amp; __addr, const InterChiplet::AddrType &amp; __src, const InterChiplet::AddrType &amp; __dst) Check whether there is delay information for the specified address. void insert (const InterChiplet::AddrType &amp; __addr, InterChiplet::InnerTimeType __cycle, const NetworkDelayItem &amp; __item) Insert delay information. void pop (const InterChiplet::AddrType &amp; __addr) Pop the first delay information for the specified address. void pop (const InterChiplet::AddrType &amp; __addr, const InterChiplet::AddrType &amp; __src, const InterChiplet::AddrType &amp; __dst) Pop the first delay information for the specified address."},{"location":"apiProject1/classNetworkDelayMap/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classNetworkDelayMap/#function-checkorderofcommand","title":"function checkOrderOfCommand","text":"<p>Check the order of write/read commands. <pre><code>inline bool NetworkDelayMap::checkOrderOfCommand (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to check. </li> </ul> <p>Returns:</p> <p>If the order of command matches the order of delay infomation, return True. Otherwise return False. </p>"},{"location":"apiProject1/classNetworkDelayMap/#function-front-12","title":"function front [1/2]","text":"<p>Return the first delay information for the specified address. <pre><code>inline NetworkDelayItem NetworkDelayMap::front (\n    const InterChiplet::AddrType &amp; __addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__addr</code> Address. </li> </ul> <p>Returns:</p> <p>The first delay information to the specified address. </p>"},{"location":"apiProject1/classNetworkDelayMap/#function-front-22","title":"function front [2/2]","text":"<p>Return the first delay information for the specified address. <pre><code>inline NetworkDelayItem NetworkDelayMap::front (\n    const InterChiplet::AddrType &amp; __addr,\n    const InterChiplet::AddrType &amp; __src,\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__addr</code> Address as key. </li> <li><code>__src</code> Source address. </li> <li><code>__dst</code> Destination address. </li> </ul> <p>Returns:</p> <p>The first delay information to the specified address. </p>"},{"location":"apiProject1/classNetworkDelayMap/#function-hasaddr-12","title":"function hasAddr [1/2]","text":"<p>Check whether there is delay information for the specified address. <pre><code>inline bool NetworkDelayMap::hasAddr (\n    const InterChiplet::AddrType &amp; __addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__addr</code> Address. </li> </ul> <p>Returns:</p> <p>If there is delay information for the specified address, return True. </p>"},{"location":"apiProject1/classNetworkDelayMap/#function-hasaddr-22","title":"function hasAddr [2/2]","text":"<p>Check whether there is delay information for the specified address. <pre><code>inline bool NetworkDelayMap::hasAddr (\n    const InterChiplet::AddrType &amp; __addr,\n    const InterChiplet::AddrType &amp; __src,\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__addr</code> Address as key. </li> <li><code>__src</code> Source address. </li> <li><code>__dst</code> Destination address. </li> </ul> <p>Returns:</p> <p>If there is delay information for the specified address, return True. </p>"},{"location":"apiProject1/classNetworkDelayMap/#function-insert","title":"function insert","text":"<p>Insert delay information. <pre><code>inline void NetworkDelayMap::insert (\n    const InterChiplet::AddrType &amp; __addr,\n    InterChiplet::InnerTimeType __cycle,\n    const NetworkDelayItem &amp; __item\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__addr</code> Address as key. </li> <li><code>__cycle</code> Event cycle. </li> <li><code>__item</code> Delay information structure. </li> </ul>"},{"location":"apiProject1/classNetworkDelayMap/#function-pop-12","title":"function pop [1/2]","text":"<p>Pop the first delay information for the specified address. <pre><code>inline void NetworkDelayMap::pop (\n    const InterChiplet::AddrType &amp; __addr\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__addr</code> Asdress. </li> </ul>"},{"location":"apiProject1/classNetworkDelayMap/#function-pop-22","title":"function pop [2/2]","text":"<p>Pop the first delay information for the specified address. <pre><code>inline void NetworkDelayMap::pop (\n    const InterChiplet::AddrType &amp; __addr,\n    const InterChiplet::AddrType &amp; __src,\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__addr</code> Address as key. </li> <li><code>__src</code> Source address. </li> <li><code>__dst</code> Destination address. </li> </ul> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/net_delay.h</code></p>"},{"location":"apiProject1/classNetworkDelayStruct/","title":"Class NetworkDelayStruct","text":"<p>ClassList &gt; NetworkDelayStruct</p> <p>List of network delay item. </p> <ul> <li><code>#include &lt;net_delay.h&gt;</code></li> </ul>"},{"location":"apiProject1/classNetworkDelayStruct/#public-functions","title":"Public Functions","text":"Type Name NetworkDelayStruct ()  bool checkOrderOfCommand (const InterChiplet::SyncCommand &amp; __cmd) Check the order of write/read commands. void clearDelayInfo () Clear delay information. InterChiplet::AddrType frontLaunchSrc (const InterChiplet::AddrType &amp; __dst) Return the source address of the first LAUNCH command to the specified destination address. InterChiplet::AddrType frontLockSrc (const InterChiplet::AddrType &amp; __dst) Return the source address of the first LOCK command to the specified destination address. InterChiplet::InnerTimeType getBarrierCycle (const std::vector&lt; InterChiplet::SyncCommand &gt; &amp; barrier_items)  InterChiplet::InnerTimeType getDefaultEndCycle (const InterChiplet::SyncCommand &amp; write_cmd) Get end cycle of one communication if cannot find this communication from delay list. CmdDelayPair getDefaultEndCycle (const InterChiplet::SyncCommand &amp; write_cmd, const InterChiplet::SyncCommand &amp; read_cmd) Get end cycle of one communication if cannot find this communication from delay list. CmdDelayPair getEndCycle (const InterChiplet::SyncCommand &amp; __write_cmd, const InterChiplet::SyncCommand &amp; __read_cmd) Get end cycle of one communication. bool hasLaunch (const InterChiplet::AddrType &amp; __dst) Check whether there is LAUNCH command in order. bool hasLock (const InterChiplet::AddrType &amp; __dst) Check whether there is LOCK command in order. void loadDelayInfo (const std::string &amp; __file_name, double __clock_rate) Load package delay list from specified file. void popLaunch (const InterChiplet::AddrType &amp; __dst) Pop the first LAUNCH command to the specified destination address. void popLock (const InterChiplet::AddrType &amp; __dst) Pop the first LOCK command to the specified destination address. int size () const"},{"location":"apiProject1/classNetworkDelayStruct/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classNetworkDelayStruct/#function-networkdelaystruct","title":"function NetworkDelayStruct","text":"<pre><code>inline NetworkDelayStruct::NetworkDelayStruct () \n</code></pre>"},{"location":"apiProject1/classNetworkDelayStruct/#function-checkorderofcommand","title":"function checkOrderOfCommand","text":"<p>Check the order of write/read commands. <pre><code>inline bool NetworkDelayStruct::checkOrderOfCommand (\n    const InterChiplet::SyncCommand &amp; __cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to check. </li> </ul> <p>Returns:</p> <p>If the order of command matches the order of delay infomation, return True. Otherwise return False. </p>"},{"location":"apiProject1/classNetworkDelayStruct/#function-cleardelayinfo","title":"function clearDelayInfo","text":"<pre><code>inline void NetworkDelayStruct::clearDelayInfo () \n</code></pre>"},{"location":"apiProject1/classNetworkDelayStruct/#function-frontlaunchsrc","title":"function frontLaunchSrc","text":"<p>Return the source address of the first LAUNCH command to the specified destination address. <pre><code>inline InterChiplet::AddrType NetworkDelayStruct::frontLaunchSrc (\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst</code> Destination address. </li> </ul> <p>Returns:</p> <p>The source address of the first LAUNCH command. </p>"},{"location":"apiProject1/classNetworkDelayStruct/#function-frontlocksrc","title":"function frontLockSrc","text":"<p>Return the source address of the first LOCK command to the specified destination address. <pre><code>inline InterChiplet::AddrType NetworkDelayStruct::frontLockSrc (\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst</code> Destination address. </li> </ul> <p>Returns:</p> <p>The source address of the first LOCK command. </p>"},{"location":"apiProject1/classNetworkDelayStruct/#function-getbarriercycle","title":"function getBarrierCycle","text":"<pre><code>inline InterChiplet::InnerTimeType NetworkDelayStruct::getBarrierCycle (\n    const std::vector&lt; InterChiplet::SyncCommand &gt; &amp; barrier_items\n) \n</code></pre>"},{"location":"apiProject1/classNetworkDelayStruct/#function-getdefaultendcycle-12","title":"function getDefaultEndCycle [1/2]","text":"<p>Get end cycle of one communication if cannot find this communication from delay list. <pre><code>inline InterChiplet::InnerTimeType NetworkDelayStruct::getDefaultEndCycle (\n    const InterChiplet::SyncCommand &amp; write_cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__write_cmd</code> Write command </li> </ul> <p>Returns:</p> <p>End cycle of this communication, used to acknowledge SYNC command. </p>"},{"location":"apiProject1/classNetworkDelayStruct/#function-getdefaultendcycle-22","title":"function getDefaultEndCycle [2/2]","text":"<p>Get end cycle of one communication if cannot find this communication from delay list. <pre><code>inline CmdDelayPair NetworkDelayStruct::getDefaultEndCycle (\n    const InterChiplet::SyncCommand &amp; write_cmd,\n    const InterChiplet::SyncCommand &amp; read_cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__write_cmd</code> Write command </li> <li><code>__read_cmd</code> Read command. </li> </ul> <p>Returns:</p> <p>End cycle of this communication, used to acknowledge SYNC command. </p>"},{"location":"apiProject1/classNetworkDelayStruct/#function-getendcycle","title":"function getEndCycle","text":"<p>Get end cycle of one communication. <pre><code>inline CmdDelayPair NetworkDelayStruct::getEndCycle (\n    const InterChiplet::SyncCommand &amp; __write_cmd,\n    const InterChiplet::SyncCommand &amp; __read_cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__write_cmd</code> Write command </li> <li><code>__read_cmd</code> Read command. </li> </ul> <p>Returns:</p> <p>End cycle of this communication, used to acknowledge SYNC command. </p>"},{"location":"apiProject1/classNetworkDelayStruct/#function-haslaunch","title":"function hasLaunch","text":"<p>Check whether there is LAUNCH command in order. <pre><code>inline bool NetworkDelayStruct::hasLaunch (\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst</code> Destination address. </li> </ul> <p>Returns:</p> <p>If there is LAUNCH command to the specified destination address, return True. </p>"},{"location":"apiProject1/classNetworkDelayStruct/#function-haslock","title":"function hasLock","text":"<p>Check whether there is LOCK command in order. <pre><code>inline bool NetworkDelayStruct::hasLock (\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst</code> Destination address. </li> </ul> <p>Returns:</p> <p>If there is LOCK command to the specified destination address, return True. </p>"},{"location":"apiProject1/classNetworkDelayStruct/#function-loaddelayinfo","title":"function loadDelayInfo","text":"<p>Load package delay list from specified file. <pre><code>inline void NetworkDelayStruct::loadDelayInfo (\n    const std::string &amp; __file_name,\n    double __clock_rate\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__file_name</code> Path to benchmark file. </li> <li><code>__clock_rate</code> Clock ratio (Simulator clock/Interchiplet clock). </li> </ul>"},{"location":"apiProject1/classNetworkDelayStruct/#function-poplaunch","title":"function popLaunch","text":"<p>Pop the first LAUNCH command to the specified destination address. <pre><code>inline void NetworkDelayStruct::popLaunch (\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst</code> Destination address. </li> </ul>"},{"location":"apiProject1/classNetworkDelayStruct/#function-poplock","title":"function popLock","text":"<p>Pop the first LOCK command to the specified destination address. <pre><code>inline void NetworkDelayStruct::popLock (\n    const InterChiplet::AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst</code> Destination address. </li> </ul>"},{"location":"apiProject1/classNetworkDelayStruct/#function-size","title":"function size","text":"<pre><code>inline int NetworkDelayStruct::size () const\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/net_delay.h</code></p>"},{"location":"apiProject1/group__pipe__comm/","title":"Group pipe_comm","text":"<p>Modules &gt; pipe_comm</p> <p>Pipe communication interface. </p>"},{"location":"apiProject1/group__pipe__comm/#classes","title":"Classes","text":"Type Name class InterChiplet::PipeComm Pipe communication structure. class InterChiplet::PipeCommUnit Structure for Single Pipe communication."},{"location":"apiProject1/classInterChiplet_1_1PipeComm/","title":"Class InterChiplet::PipeComm","text":"<p>ClassList &gt; InterChiplet &gt; PipeComm</p> <p>Pipe communication structure. </p> <ul> <li><code>#include &lt;pipe_comm.h&gt;</code></li> </ul>"},{"location":"apiProject1/classInterChiplet_1_1PipeComm/#public-functions","title":"Public Functions","text":"Type Name PipeComm ()  int read_data (const char * file_name, void * buf, int nbyte)  int write_data (const char * file_name, void * buf, int nbyte)"},{"location":"apiProject1/classInterChiplet_1_1PipeComm/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classInterChiplet_1_1PipeComm/#function-pipecomm","title":"function PipeComm","text":"<pre><code>inline InterChiplet::PipeComm::PipeComm () \n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1PipeComm/#function-read_data","title":"function read_data","text":"<pre><code>inline int InterChiplet::PipeComm::read_data (\n    const char * file_name,\n    void * buf,\n    int nbyte\n) \n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1PipeComm/#function-write_data","title":"function write_data","text":"<pre><code>inline int InterChiplet::PipeComm::write_data (\n    const char * file_name,\n    void * buf,\n    int nbyte\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/pipe_comm.h</code></p>"},{"location":"apiProject1/classInterChiplet_1_1PipeCommUnit/","title":"Class InterChiplet::PipeCommUnit","text":"<p>ClassList &gt; InterChiplet &gt; PipeCommUnit</p> <p>Structure for Single Pipe communication. </p> <ul> <li><code>#include &lt;pipe_comm.h&gt;</code></li> </ul>"},{"location":"apiProject1/classInterChiplet_1_1PipeCommUnit/#public-functions","title":"Public Functions","text":"Type Name PipeCommUnit (const char * file_name, bool read)  int read_data (void * dst_buf, int nbyte)  bool valid () const int write_data (void * src_buf, int nbyte)"},{"location":"apiProject1/classInterChiplet_1_1PipeCommUnit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/classInterChiplet_1_1PipeCommUnit/#function-pipecommunit","title":"function PipeCommUnit","text":"<pre><code>inline InterChiplet::PipeCommUnit::PipeCommUnit (\n    const char * file_name,\n    bool read\n) \n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1PipeCommUnit/#function-read_data","title":"function read_data","text":"<pre><code>inline int InterChiplet::PipeCommUnit::read_data (\n    void * dst_buf,\n    int nbyte\n) \n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1PipeCommUnit/#function-valid","title":"function valid","text":"<pre><code>inline bool InterChiplet::PipeCommUnit::valid () const\n</code></pre>"},{"location":"apiProject1/classInterChiplet_1_1PipeCommUnit/#function-write_data","title":"function write_data","text":"<pre><code>inline int InterChiplet::PipeCommUnit::write_data (\n    void * src_buf,\n    int nbyte\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/pipe_comm.h</code></p>"},{"location":"apiProject1/group__sync__proto/","title":"Group sync_proto","text":"<p>Modules &gt; sync_proto</p> <p>Synchronization protocol interface. </p>"},{"location":"apiProject1/group__sync__proto/#public-functions","title":"Public Functions","text":"Type Name void InterChiplet::barrierSync (int __src_x, int __src_y, int __uid, int __count) Send BARRIER command and wait for SYNC command. TimeType InterChiplet::cycleSync (TimeType __cycle) Send CYCLE command and wait for SYNC command. std::string InterChiplet::dumpCmd (const SyncCommand &amp; __cmd) Dump command to a string for debugging. void InterChiplet::launchSync (int __src_x, int __src_y, int __dst_x, int __dst_y) Send LAUNCH command and wait for SYNC command. void InterChiplet::lockSync (int __src_x, int __src_y, int __uid) Send UNLOCK command and wait for SYNC command. SyncCommand InterChiplet::parseCmd (const std::string &amp; __message) Parse command from string. SyncCommand InterChiplet::parseCmd (int __fd_in=STDIN_FILENO) Receive command from stdin and parse the message. Used by simulator only. std::string InterChiplet::pipeName (const AddrType &amp; __src, const AddrType &amp; __dst) Return name of file name in a std::string. Return directory related to the directory of main process. TimeType InterChiplet::readSync (TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y, int __nbyte, long __desc) Send READ command and wait for SYNC command. std::string InterChiplet::receiveSync (int __src_x, int __src_y, int __dst_x, int __dst_y) Send RECEIVE command and wait for SYNC command. void InterChiplet::sendBarrierCmd (int __src_x, int __src_y, int __uid, int __count) Send BARRIER command. void InterChiplet::sendCycleCmd (TimeType __cycle) Send CYCLE command. void InterChiplet::sendLaunchCmd (int __src_x, int __src_y, int __dst_x, int __dst_y) Send LAUNCH command. void InterChiplet::sendLockCmd (int __src_x, int __src_y, int __uid) Send LOCK command. void InterChiplet::sendReadCmd (TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y, int __nbyte, long __desc) Send READ command. void InterChiplet::sendReceiveCmd (int __src_x, int __src_y, int __dst_x, int __dst_y) Send RECEIVE command. void InterChiplet::sendResultCmd () Send RESULT command. void InterChiplet::sendResultCmd (const std::vector&lt; std::string &gt; &amp; __res_list) Send RESULT command. void InterChiplet::sendResultCmd (const std::vector&lt; long &gt; &amp; __res_list) Send RESULT command. void InterChiplet::sendResultCmd (int __fd) Send RESULT command. void InterChiplet::sendResultCmd (int __fd, const std::vector&lt; std::string &gt; &amp; __res_list) Send RESULT command. void InterChiplet::sendResultCmd (int __fd, const std::vector&lt; long &gt; &amp; __res_list) Send RESULT command. void InterChiplet::sendSendCmd (int __src_x, int __src_y, int __dst_x, int __dst_y) Send SEND command. std::string InterChiplet::sendSync (int __src_x, int __src_y, int __dst_x, int __dst_y) Send SEND command and wait for SYNC command. void InterChiplet::sendSyncCmd (TimeType __cycle) Send SYNC command. void InterChiplet::sendSyncCmd (int __fd, TimeType __cycle) Send SYNC command to specified file descriptor. void InterChiplet::sendUnlockCmd (int __src_x, int __src_y, int __uid) Send UNLOCK command. void InterChiplet::sendWaitlaunchCmd (int __src_x, int __src_y, int __dst_x, int __dst_y) Send WAITLAUNCH command. void InterChiplet::sendWriteCmd (TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y, int __nbyte, long __desc) Send WRITE command. void InterChiplet::unlockSync (int __src_x, int __src_y, int __uid) Send UNLOCK command and wait for SYNC command. void InterChiplet::waitlaunchSync (int * __src_x, int * __src_y, int __dst_x, int __dst_y) Send WAITLAUNCH command and wait for LAUNCH command. TimeType InterChiplet::writeSync (TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y, int __nbyte, long __desc) Send WRITE command and wait for SYNC command."},{"location":"apiProject1/group__sync__proto/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/group__sync__proto/#function-barriersync","title":"function barrierSync","text":"<p>Send BARRIER command and wait for SYNC command. <pre><code>inline void InterChiplet::barrierSync (\n    int __src_x,\n    int __src_y,\n    int __uid,\n    int __count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Barrier ID. </li> <li><code>__count</code> Number of items in barrier. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-cyclesync","title":"function cycleSync","text":"<p>Send CYCLE command and wait for SYNC command. <pre><code>inline TimeType InterChiplet::cycleSync (\n    TimeType __cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send CYCLE command. </li> </ul> <p>Returns:</p> <p>Cycle to receive SYNC command. </p>"},{"location":"apiProject1/group__sync__proto/#function-dumpcmd","title":"function dumpCmd","text":"<p>Dump command to a string for debugging. <pre><code>inline std::string InterChiplet::dumpCmd (\n    const SyncCommand &amp; __cmd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Structure of synchronization command. </li> </ul> <p>Returns:</p> <p>String of message. </p>"},{"location":"apiProject1/group__sync__proto/#function-launchsync","title":"function launchSync","text":"<p>Send LAUNCH command and wait for SYNC command. <pre><code>inline void InterChiplet::launchSync (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-locksync","title":"function lockSync","text":"<p>Send UNLOCK command and wait for SYNC command. <pre><code>inline void InterChiplet::lockSync (\n    int __src_x,\n    int __src_y,\n    int __uid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Mutex ID. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-parsecmd","title":"function parseCmd","text":"<p>Parse command from string. <pre><code>inline SyncCommand InterChiplet::parseCmd (\n    const std::string &amp; __message\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__message</code> String of message. </li> </ul> <p>Returns:</p> <p>Structure of synchronization command. </p>"},{"location":"apiProject1/group__sync__proto/#function-parsecmd_1","title":"function parseCmd","text":"<p>Receive command from stdin and parse the message. Used by simulator only. <pre><code>inline SyncCommand InterChiplet::parseCmd (\n    int __fd_in=STDIN_FILENO\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd_in</code> Input file descriptor. </li> </ul> <p>Returns:</p> <p>Structure of synchronization command. </p>"},{"location":"apiProject1/group__sync__proto/#function-pipename","title":"function pipeName","text":"<p>Return name of file name in a std::string. Return directory related to the directory of main process. <pre><code>inline std::string InterChiplet::pipeName (\n    const AddrType &amp; __src,\n    const AddrType &amp; __dst\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src</code> Source address. </li> <li><code>__dst</code> Destiantion address. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-readsync","title":"function readSync","text":"<p>Send READ command and wait for SYNC command. <pre><code>inline TimeType InterChiplet::readSync (\n    TimeType __cycle,\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y,\n    int __nbyte,\n    long __desc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send READ command. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__nbyte</code> Number of bytes to read. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> </ul> <p>Returns:</p> <p>Cycle to receive SYNC command. </p>"},{"location":"apiProject1/group__sync__proto/#function-receivesync","title":"function receiveSync","text":"<p>Send RECEIVE command and wait for SYNC command. <pre><code>inline std::string InterChiplet::receiveSync (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul> <p>Returns:</p> <p>Pipe name. </p>"},{"location":"apiProject1/group__sync__proto/#function-sendbarriercmd","title":"function sendBarrierCmd","text":"<p>Send BARRIER command. <pre><code>inline void InterChiplet::sendBarrierCmd (\n    int __src_x,\n    int __src_y,\n    int __uid,\n    int __count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Barrier ID. </li> <li><code>__count</code> Number of items in barrier. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendcyclecmd","title":"function sendCycleCmd","text":"<p>Send CYCLE command. <pre><code>inline void InterChiplet::sendCycleCmd (\n    TimeType __cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send CYCLE command. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendlaunchcmd","title":"function sendLaunchCmd","text":"<p>Send LAUNCH command. <pre><code>inline void InterChiplet::sendLaunchCmd (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendlockcmd","title":"function sendLockCmd","text":"<p>Send LOCK command. <pre><code>inline void InterChiplet::sendLockCmd (\n    int __src_x,\n    int __src_y,\n    int __uid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Barrier ID. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendreadcmd","title":"function sendReadCmd","text":"<p>Send READ command. <pre><code>inline void InterChiplet::sendReadCmd (\n    TimeType __cycle,\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y,\n    int __nbyte,\n    long __desc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send READ command. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__nbyte</code> Number of bytes to read. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendreceivecmd","title":"function sendReceiveCmd","text":"<p>Send RECEIVE command. <pre><code>inline void InterChiplet::sendReceiveCmd (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendresultcmd","title":"function sendResultCmd","text":"<pre><code>inline void InterChiplet::sendResultCmd () \n</code></pre>"},{"location":"apiProject1/group__sync__proto/#function-sendresultcmd_1","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    const std::vector&lt; std::string &gt; &amp; __res_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__res_list</code> Result list. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendresultcmd_2","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    const std::vector&lt; long &gt; &amp; __res_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__res_list</code> Result list. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendresultcmd_3","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    int __fd\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd</code> File descriptor. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendresultcmd_4","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    int __fd,\n    const std::vector&lt; std::string &gt; &amp; __res_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd</code> File descriptor. </li> <li><code>__res_list</code> Result list. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendresultcmd_5","title":"function sendResultCmd","text":"<p>Send RESULT command. <pre><code>inline void InterChiplet::sendResultCmd (\n    int __fd,\n    const std::vector&lt; long &gt; &amp; __res_list\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd</code> File descriptor. </li> <li><code>__res_list</code> Result list. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendsendcmd","title":"function sendSendCmd","text":"<p>Send SEND command. <pre><code>inline void InterChiplet::sendSendCmd (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendsync","title":"function sendSync","text":"<p>Send SEND command and wait for SYNC command. <pre><code>inline std::string InterChiplet::sendSync (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul> <p>Returns:</p> <p>Pipe name. </p>"},{"location":"apiProject1/group__sync__proto/#function-sendsynccmd","title":"function sendSyncCmd","text":"<p>Send SYNC command. <pre><code>inline void InterChiplet::sendSyncCmd (\n    TimeType __cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to receive SYNC command. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendsynccmd_1","title":"function sendSyncCmd","text":"<p>Send SYNC command to specified file descriptor. <pre><code>inline void InterChiplet::sendSyncCmd (\n    int __fd,\n    TimeType __cycle\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__fd</code> File descriptor. </li> <li><code>__cycle</code> Cycle to receive SYNC command. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendunlockcmd","title":"function sendUnlockCmd","text":"<p>Send UNLOCK command. <pre><code>inline void InterChiplet::sendUnlockCmd (\n    int __src_x,\n    int __src_y,\n    int __uid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Barrier ID. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendwaitlaunchcmd","title":"function sendWaitlaunchCmd","text":"<p>Send WAITLAUNCH command. <pre><code>inline void InterChiplet::sendWaitlaunchCmd (\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-sendwritecmd","title":"function sendWriteCmd","text":"<p>Send WRITE command. <pre><code>inline void InterChiplet::sendWriteCmd (\n    TimeType __cycle,\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y,\n    int __nbyte,\n    long __desc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send WRITE command. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__nbyte</code> Number of bytes to write. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-unlocksync","title":"function unlockSync","text":"<p>Send UNLOCK command and wait for SYNC command. <pre><code>inline void InterChiplet::unlockSync (\n    int __src_x,\n    int __src_y,\n    int __uid\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__uid</code> Mutex ID. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-waitlaunchsync","title":"function waitlaunchSync","text":"<p>Send WAITLAUNCH command and wait for LAUNCH command. <pre><code>inline void InterChiplet::waitlaunchSync (\n    int * __src_x,\n    int * __src_y,\n    int __dst_x,\n    int __dst_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> </ul>"},{"location":"apiProject1/group__sync__proto/#function-writesync","title":"function writeSync","text":"<p>Send WRITE command and wait for SYNC command. <pre><code>inline TimeType InterChiplet::writeSync (\n    TimeType __cycle,\n    int __src_x,\n    int __src_y,\n    int __dst_x,\n    int __dst_y,\n    int __nbyte,\n    long __desc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cycle</code> Cycle to send WRITE command. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__dst_x</code> Destiantion address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__nbyte</code> Number of bytes to write. </li> <li><code>__desc</code> Synchronization protocol descriptor. </li> </ul> <p>Returns:</p> <p>Cycle to receive SYNC command. </p>"},{"location":"apiProject1/dir_a2025b34133129e5724d121abe9a4a4a/","title":"Dir /data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet","text":"<p>FileList &gt; interchiplet</p>"},{"location":"apiProject1/dir_a2025b34133129e5724d121abe9a4a4a/#directories","title":"Directories","text":"Type Name dir includes dir srcs <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/</code></p>"},{"location":"apiProject1/dir_943fa6db2bfb09b7dcf1f02346dde40e/","title":"Dir /data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes","text":"<p>FileList &gt; includes</p>"},{"location":"apiProject1/dir_943fa6db2bfb09b7dcf1f02346dde40e/#files","title":"Files","text":"Type Name file apis_c.h file apis_cu.h file benchmark_yaml.h file cmd_handler.h file cmdline_options.h file global_define.h file net_bench.h file net_delay.h file pipe_comm.h file sync_protocol.h <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/</code></p>"},{"location":"apiProject1/apis__c_8h/","title":"File apis_c.h","text":"<p>FileList &gt; includes &gt; apis_c.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;unistd.h&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"apiProject1/apis__c_8h/#namespaces","title":"Namespaces","text":"Type Name namespace InterChiplet <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/apis_c.h</code></p>"},{"location":"apiProject1/apis__c_8h_source/","title":"File apis_c.h","text":"<p>File List &gt; includes &gt; apis_c.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;unistd.h&gt;\n\n#include &lt;cstdint&gt;\n\nnamespace InterChiplet {\ntypedef decltype(syscall(0)) syscall_return_t;\n\nsyscall_return_t launch(int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y);\n\nsyscall_return_t waitLaunch(int64_t __dst_x, int64_t __dst_y, int64_t* __src_x, int64_t* __src_y);\n\nsyscall_return_t barrier(int64_t __uid, int64_t __src_x, int64_t __src_y, int64_t __count = 0);\n\nsyscall_return_t lock(int64_t __uid, int64_t __src_x, int64_t __src_y);\n\nsyscall_return_t unlock(int64_t __uid, int64_t __src_x, int64_t __src_y);\n\nsyscall_return_t sendMessage(int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y,\n                             void* __addr, int64_t __nbyte);\n\nsyscall_return_t receiveMessage(int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y,\n                                void* __addr, int64_t __nbyte);\n\n}  // namespace InterChiplet\n</code></pre>"},{"location":"apiProject1/apis__cu_8h/","title":"File apis_cu.h","text":"<p>FileList &gt; includes &gt; apis_cu.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cuda_runtime_api.h\"</code></li> </ul>"},{"location":"apiProject1/apis__cu_8h/#public-functions","title":"Public Functions","text":"Type Name __host__ cudaError_t CUDARTAPI barrier (int __uid, int __src_x, int __src_y, int __count=0) Barrier. __host__ cudaError_t CUDARTAPI launch (int __dst_x, int __dst_y, int __src_x, int __src_y) Launch application to remote chiplet. __host__ cudaError_t CUDARTAPI lock (int __uid, int __src_x, int __src_y) Lock mutex. __host__ cudaError_t CUDARTAPI receiveMessage (int __dst_x, int __dst_y, int __src_x, int __srx_y, void * __addr, int __nbyte) Read data from remote chiplet. __host__ cudaError_t CUDARTAPI sendMessage (int __dst_x, int __dst_y, int __src_x, int __srx_y, void * __addr, int __nbyte) Send data to remote chiplet. __host__ cudaError_t CUDARTAPI unlock (int __uid, int __src_x, int __src_y) Unlock mutex. __host__ cudaError_t CUDARTAPI waitLaunch (int __dst_x, int __dst_y, int * __src_x, int * __src_y) Wait launch from remote chiplet."},{"location":"apiProject1/apis__cu_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/apis__cu_8h/#function-barrier","title":"function barrier","text":"<p>Barrier. <pre><code>__host__ cudaError_t CUDARTAPI barrier (\n    int __uid,\n    int __src_x,\n    int __src_y,\n    int __count=0\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Barrier ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__count</code> Number of threads to barrier. </li> </ul>"},{"location":"apiProject1/apis__cu_8h/#function-launch","title":"function launch","text":"<p>Launch application to remote chiplet. <pre><code>__host__ cudaError_t CUDARTAPI launch (\n    int __dst_x,\n    int __dst_y,\n    int __src_x,\n    int __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/apis__cu_8h/#function-lock","title":"function lock","text":"<p>Lock mutex. <pre><code>__host__ cudaError_t CUDARTAPI lock (\n    int __uid,\n    int __src_x,\n    int __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Mutex ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/apis__cu_8h/#function-receivemessage","title":"function receiveMessage","text":"<p>Read data from remote chiplet. <pre><code>__host__ cudaError_t CUDARTAPI receiveMessage (\n    int __dst_x,\n    int __dst_y,\n    int __src_x,\n    int __srx_y,\n    void * __addr,\n    int __nbyte\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__addr</code> Data address. </li> <li><code>__nbyte</code> Number of bytes. </li> </ul>"},{"location":"apiProject1/apis__cu_8h/#function-sendmessage","title":"function sendMessage","text":"<p>Send data to remote chiplet. <pre><code>__host__ cudaError_t CUDARTAPI sendMessage (\n    int __dst_x,\n    int __dst_y,\n    int __src_x,\n    int __srx_y,\n    void * __addr,\n    int __nbyte\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> <li><code>__addr</code> Data address. </li> <li><code>__nbyte</code> Number of bytes. </li> </ul>"},{"location":"apiProject1/apis__cu_8h/#function-unlock","title":"function unlock","text":"<p>Unlock mutex. <pre><code>__host__ cudaError_t CUDARTAPI unlock (\n    int __uid,\n    int __src_x,\n    int __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__uid</code> Mutex ID. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul>"},{"location":"apiProject1/apis__cu_8h/#function-waitlaunch","title":"function waitLaunch","text":"<p>Wait launch from remote chiplet. <pre><code>__host__ cudaError_t CUDARTAPI waitLaunch (\n    int __dst_x,\n    int __dst_y,\n    int * __src_x,\n    int * __src_y\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__dst_x</code> Destination address in X-axis. </li> <li><code>__dst_y</code> Destination address in Y-axis. </li> <li><code>__src_x</code> Source address in X-axis. </li> <li><code>__src_y</code> Source address in Y-axis. </li> </ul> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/apis_cu.h</code></p>"},{"location":"apiProject1/apis__cu_8h_source/","title":"File apis_cu.h","text":"<p>File List &gt; includes &gt; apis_cu.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include \"cuda_runtime_api.h\"\n\nextern __host__ cudaError_t CUDARTAPI launch(int __dst_x, int __dst_y, int __src_x, int __src_y);\n\nextern __host__ cudaError_t CUDARTAPI waitLaunch(int __dst_x, int __dst_y, int* __src_x,\n                                                 int* __src_y);\n\nextern __host__ cudaError_t CUDARTAPI barrier(int __uid, int __src_x, int __src_y, int __count = 0);\n\nextern __host__ cudaError_t CUDARTAPI lock(int __uid, int __src_x, int __src_y);\n\nextern __host__ cudaError_t CUDARTAPI unlock(int __uid, int __src_x, int __src_y);\n\nextern __host__ cudaError_t CUDARTAPI sendMessage(int __dst_x, int __dst_y, int __src_x,\n                                                  int __srx_y, void* __addr, int __nbyte);\n\nextern __host__ cudaError_t CUDARTAPI receiveMessage(int __dst_x, int __dst_y, int __src_x,\n                                                     int __srx_y, void* __addr, int __nbyte);\n</code></pre>"},{"location":"apiProject1/benchmark__yaml_8h/","title":"File benchmark_yaml.h","text":"<p>FileList &gt; includes &gt; benchmark_yaml.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;boost/filesystem.hpp&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"yaml-cpp/yaml.h\"</code></li> </ul>"},{"location":"apiProject1/benchmark__yaml_8h/#classes","title":"Classes","text":"Type Name class BenchmarkConfig Benchmark configuration structure. class ProcessConfig Data structure to configure one simulation process. <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/benchmark_yaml.h</code></p>"},{"location":"apiProject1/benchmark__yaml_8h_source/","title":"File benchmark_yaml.h","text":"<p>File List &gt; includes &gt; benchmark_yaml.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;boost/filesystem.hpp&gt;\n#include &lt;iostream&gt;\n\n#include \"yaml-cpp/yaml.h\"\nnamespace fs = boost::filesystem;\n\nclass ProcessConfig {\n   public:\n    ProcessConfig(const std::string&amp; __cmd, const std::vector&lt;std::string&gt;&amp; __args,\n                  const std::string&amp; __log, bool __to_stdout, double __clock_rate,\n                  const std::string&amp; __pre_copy)\n        : m_command(__cmd),\n          m_args(__args),\n          m_log_file(__log),\n          m_to_stdout(__to_stdout),\n          m_clock_rate(__clock_rate),\n          m_pre_copy(__pre_copy) {}\n\n   public:\n    std::string m_command;\n    std::vector&lt;std::string&gt; m_args;\n    std::string m_log_file;\n    bool m_to_stdout;\n    double m_clock_rate;\n    std::string m_pre_copy;\n};\n\nclass BenchmarkConfig {\n   public:\n    BenchmarkConfig(const std::string&amp; file_name) {\n        // Get environment variables.\n        m_benchmark_root = fs::canonical(fs::path(file_name)).parent_path().string();\n        if (getenv(\"SIMULATOR_ROOT\") == NULL) {\n            std::cerr &lt;&lt; \"The environment variable SIMULATOR_ROOT is not defined.\\n\";\n            exit(EXIT_FAILURE);\n        } else {\n            m_simulator_root = getenv(\"SIMULATOR_ROOT\");\n        }\n\n        // Parse YAML file.\n        YAML::Node config;\n        try {\n            config = YAML::LoadFile(file_name);\n        } catch (const std::exception&amp; e) {\n            std::cerr &lt;&lt; \"Error: \" &lt;&lt; e.what() &lt;&lt; \"\\n\";\n            exit(EXIT_FAILURE);\n        }\n\n        // Parse YAML Tree.\n        yaml_parse(config);\n\n        // Extend environment variables.\n        extend_env_var();\n    }\n\n    void yaml_parse(const YAML::Node&amp; config) {\n        m_phase1_proc_cfg_list = yaml_parse_phase(config[\"phase1\"]);\n        m_phase2_proc_cfg_list = yaml_parse_phase(config[\"phase2\"]);\n    }\n\n   private:\n    std::vector&lt;ProcessConfig&gt; yaml_parse_phase(const YAML::Node&amp; config) {\n        std::vector&lt;ProcessConfig&gt; proc_list;\n        for (YAML::const_iterator it = config.begin(); it != config.end(); it++) {\n            proc_list.push_back(yaml_parse_process(*it));\n        }\n        return proc_list;\n    }\n\n    ProcessConfig yaml_parse_process(const YAML::Node&amp; config) {\n        std::string pre_copy;\n        if (config[\"pre_copy\"]) {\n            pre_copy = config[\"pre_copy\"].as&lt;std::string&gt;();\n        }\n        return ProcessConfig(config[\"cmd\"].as&lt;std::string&gt;(),\n                             config[\"args\"].as&lt;std::vector&lt;std::string&gt; &gt;(),\n                             config[\"log\"].as&lt;std::string&gt;(), config[\"is_to_stdout\"].as&lt;bool&gt;(),\n                             config[\"clock_rate\"].as&lt;double&gt;(), pre_copy);\n    }\n\n    void extend_env_var() {\n        for (ProcessConfig&amp; config : m_phase1_proc_cfg_list) {\n            extend_env_var_proc(config);\n        }\n        for (ProcessConfig&amp; config : m_phase2_proc_cfg_list) {\n            extend_env_var_proc(config);\n        }\n    }\n\n    void extend_env_var_proc(ProcessConfig&amp; proc_config) {\n        extend_env_var_string(proc_config.m_command);\n        extend_env_var_string(proc_config.m_log_file);\n        for (std::string&amp; arg : proc_config.m_args) {\n            extend_env_var_string(arg);\n        }\n    }\n\n    void extend_env_var_string(std::string&amp; __str) {\n        std::size_t find_pos;\n        while ((find_pos = __str.find(\"$SIMULATOR_ROOT\")) != std::string::npos) {\n            __str = __str.replace(find_pos, 15, m_simulator_root);\n        }\n        while ((find_pos = __str.find(\"$BENCHMARK_ROOT\")) != std::string::npos) {\n            __str = __str.replace(find_pos, 15, m_benchmark_root);\n        }\n    }\n\n   public:\n    std::string m_benchmark_root;\n    std::string m_simulator_root;\n    std::vector&lt;ProcessConfig&gt; m_phase1_proc_cfg_list;\n    std::vector&lt;ProcessConfig&gt; m_phase2_proc_cfg_list;\n};\n</code></pre>"},{"location":"apiProject1/cmd__handler_8h/","title":"File cmd_handler.h","text":"<p>FileList &gt; includes &gt; cmd_handler.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;list&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;set&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"net_bench.h\"</code></li> <li><code>#include \"net_delay.h\"</code></li> <li><code>#include \"sync_protocol.h\"</code></li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#classes","title":"Classes","text":"Type Name class SyncBarrierStruct Structure for Barrier synchronization. class SyncClockStruct Structure for Clock synchronization. class SyncCommStruct Structure for Communication synchronization. class SyncLaunchStruct Structure for Launch and Wait-launch synchronization. class SyncLockStruct Structure for Lock and Unlock synchronization. class SyncPipeStruct Structure for Pipe synchronization. class SyncStruct Data structure of synchronize operation."},{"location":"apiProject1/cmd__handler_8h/#public-types","title":"Public Types","text":"Type Name typedef std::vector&lt; InterChiplet::SyncCommand &gt; SyncCmdList List of synchronization commands."},{"location":"apiProject1/cmd__handler_8h/#public-functions","title":"Public Functions","text":"Type Name void handle_barrier_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle BARRIER command. void handle_cycle_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle CYCLE command. void handle_launch_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle LAUNCH command. void handle_lock_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle LOCK command. void handle_pipe_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle PIPE command. void handle_read_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle READ command. void handle_unlock_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle UNLOCK command. void handle_waitlaunch_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WAITLAUNCH command. void handle_write_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WRITE command."},{"location":"apiProject1/cmd__handler_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiProject1/cmd__handler_8h/#typedef-synccmdlist","title":"typedef SyncCmdList","text":"<pre><code>typedef std::vector&lt;InterChiplet::SyncCommand&gt; SyncCmdList;\n</code></pre>"},{"location":"apiProject1/cmd__handler_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/cmd__handler_8h/#function-handle_barrier_cmd","title":"function handle_barrier_cmd","text":"<p>Handle BARRIER command. <pre><code>void handle_barrier_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#function-handle_cycle_cmd","title":"function handle_cycle_cmd","text":"<p>Handle CYCLE command. <pre><code>void handle_cycle_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#function-handle_launch_cmd","title":"function handle_launch_cmd","text":"<p>Handle LAUNCH command. <pre><code>void handle_launch_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#function-handle_lock_cmd","title":"function handle_lock_cmd","text":"<p>Handle LOCK command. <pre><code>void handle_lock_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#function-handle_pipe_cmd","title":"function handle_pipe_cmd","text":"<p>Handle PIPE command. <pre><code>void handle_pipe_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#function-handle_read_cmd","title":"function handle_read_cmd","text":"<p>Handle READ command. <pre><code>void handle_read_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#function-handle_unlock_cmd","title":"function handle_unlock_cmd","text":"<p>Handle UNLOCK command. <pre><code>void handle_unlock_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#function-handle_waitlaunch_cmd","title":"function handle_waitlaunch_cmd","text":"<p>Handle WAITLAUNCH command. <pre><code>void handle_waitlaunch_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8h/#function-handle_write_cmd","title":"function handle_write_cmd","text":"<p>Handle WRITE command. <pre><code>void handle_write_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmd_handler.h</code></p>"},{"location":"apiProject1/cmd__handler_8h_source/","title":"File cmd_handler.h","text":"<p>File List &gt; includes &gt; cmd_handler.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma\n\n#include &lt;list&gt;\n#include &lt;map&gt;\n#include &lt;set&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\n#include \"net_bench.h\"\n#include \"net_delay.h\"\n#include \"sync_protocol.h\"\n\ntypedef std::vector&lt;InterChiplet::SyncCommand&gt; SyncCmdList;\n\nclass SyncClockStruct {\n   private:\n    InterChiplet::InnerTimeType m_cycle;\n\n   public:\n    SyncClockStruct() : m_cycle(0) {}\n\n    inline void update(InterChiplet::InnerTimeType __cycle) {\n        if (m_cycle &lt; __cycle) {\n            m_cycle = __cycle;\n        }\n    }\n\n    inline InterChiplet::InnerTimeType cycle() { return m_cycle; }\n};\n\nclass SyncPipeStruct {\n   private:\n    std::set&lt;std::string&gt; m_pipe_set;\n\n   public:\n    inline void insert(std::string&amp; __name) { m_pipe_set.insert(__name); }\n\n    inline void insert(const std::string&amp; __name) { m_pipe_set.insert(__name); }\n\n    inline std::set&lt;std::string&gt; pipeSet() { return m_pipe_set; }\n\n    inline const std::set&lt;std::string&gt;&amp; pipeSet() const { return m_pipe_set; }\n};\n\nclass SyncBarrierStruct {\n   private:\n    std::map&lt;int, int&gt; m_barrier_count_map;\n    std::map&lt;int, SyncCmdList&gt; m_barrier_items_map;\n\n   public:\n    inline void insertBarrier(int __uid, int __count) {\n        // Exist barrier\n        if (m_barrier_count_map.find(__uid) != m_barrier_count_map.end()) {\n            // Update barrier count\n            if (__count &gt; 0) {\n                m_barrier_count_map[__uid] = __count;\n            }\n        }\n        // New barrier\n        else {\n            m_barrier_count_map[__uid] = __count;\n            m_barrier_items_map[__uid] = SyncCmdList();\n        }\n    }\n\n    inline void insertBarrier(int __uid, int __count, const InterChiplet::SyncCommand&amp; __cmd) {\n        // Exist barrier\n        if (m_barrier_count_map.find(__uid) != m_barrier_count_map.end()) {\n            // Update barrier count\n            if (__count &gt; 0) {\n                m_barrier_count_map[__uid] = __count;\n            }\n        }\n        // New barrier\n        else {\n            m_barrier_count_map[__uid] = __count;\n            m_barrier_items_map[__uid] = SyncCmdList();\n        }\n        m_barrier_items_map[__uid].push_back(__cmd);\n    }\n\n    inline bool overflow(int __uid) {\n        // New Barrier\n        if (m_barrier_count_map.find(__uid) == m_barrier_count_map.end()) {\n            return true;\n        }\n        // Exist barrier\n        else {\n            return m_barrier_items_map[__uid].size() &gt;= m_barrier_count_map[__uid];\n        }\n    }\n\n    inline SyncCmdList&amp; barrierCmd(int __uid) { return m_barrier_items_map[__uid]; }\n\n    inline void reset(int __uid) {\n        if (m_barrier_count_map.find(__uid) != m_barrier_count_map.end()) {\n            m_barrier_items_map[__uid].clear();\n        }\n    }\n};\n\nclass SyncLockStruct {\n   private:\n    std::set&lt;int&gt; m_lock_set;\n    std::map&lt;int, InterChiplet::SyncCommand&gt; m_last_cmd_map;\n    std::map&lt;int, SyncCmdList&gt; m_lock_cmd_list;\n\n   public:\n    inline bool isLocked(int __uid) { return m_lock_set.find(__uid) != m_lock_set.end(); }\n\n    inline void lock(int __uid, const InterChiplet::SyncCommand&amp; __cmd) {\n        if (!isLocked(__uid)) {\n            m_lock_set.insert(__uid);\n            m_last_cmd_map[__uid] = __cmd;\n        }\n    }\n\n    inline void unlock(int __uid, const InterChiplet::SyncCommand&amp; __cmd) {\n        if (isLocked(__uid)) {\n            m_lock_set.erase(__uid);\n            m_last_cmd_map[__uid] = __cmd;\n        }\n    }\n\n    inline bool hasLastCmd(int __uid) {\n        return m_last_cmd_map.find(__uid) != m_last_cmd_map.end();\n    }\n\n    inline InterChiplet::SyncCommand getLastCmd(int __uid) {\n        if (hasLastCmd(__uid)) {\n            return m_last_cmd_map[__uid];\n        } else {\n            return InterChiplet::SyncCommand();\n        }\n    }\n\n    inline void insertLockCmd(int __uid, const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_lock_cmd_list.find(__uid) == m_lock_cmd_list.end()) {\n            m_lock_cmd_list[__uid] = SyncCmdList();\n        }\n        m_lock_cmd_list[__uid].push_back(__cmd);\n    }\n\n    inline bool hasLockCmd(int __uid) {\n        if (m_lock_cmd_list.find(__uid) == m_lock_cmd_list.end()) {\n            return false;\n        }\n        return m_lock_cmd_list[__uid].size() &gt; 0;\n    }\n\n    inline bool hasLockCmd(int __uid, const InterChiplet::AddrType&amp; __src) {\n        if (m_lock_cmd_list.find(__uid) == m_lock_cmd_list.end()) {\n            return false;\n        }\n        if (m_lock_cmd_list[__uid].size() == 0) {\n            return false;\n        }\n        SyncCmdList&amp; cmd_list = m_lock_cmd_list[__uid];\n        for (SyncCmdList::iterator it = cmd_list.begin(); it != cmd_list.end(); it++) {\n            if (it-&gt;m_src == __src) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    inline InterChiplet::SyncCommand popLockCmd(int __uid) {\n        if (m_lock_cmd_list.find(__uid) == m_lock_cmd_list.end()) {\n            return InterChiplet::SyncCommand();\n        }\n        if (m_lock_cmd_list[__uid].size() == 0) {\n            return InterChiplet::SyncCommand();\n        }\n        InterChiplet::SyncCommand command = m_lock_cmd_list[__uid].front();\n        m_lock_cmd_list[__uid].erase(m_lock_cmd_list[__uid].begin());\n        return command;\n    }\n\n    inline InterChiplet::SyncCommand popLockCmd(int __uid, const InterChiplet::AddrType&amp; __src) {\n        if (m_lock_cmd_list.find(__uid) == m_lock_cmd_list.end()) {\n            return InterChiplet::SyncCommand();\n        }\n        if (m_lock_cmd_list[__uid].size() == 0) {\n            return InterChiplet::SyncCommand();\n        }\n        SyncCmdList&amp; cmd_list = m_lock_cmd_list[__uid];\n        for (SyncCmdList::iterator it = cmd_list.begin(); it != cmd_list.end(); it++) {\n            if (it-&gt;m_src == __src) {\n                InterChiplet::SyncCommand cmd = *it;\n                cmd_list.erase(it);\n                return cmd;\n            }\n        }\n        return InterChiplet::SyncCommand();\n    }\n};\n\nclass SyncLaunchStruct {\n   private:\n    std::map&lt;InterChiplet::AddrType, SyncCmdList&gt; m_launch_cmd_list;\n    std::map&lt;InterChiplet::AddrType, SyncCmdList&gt; m_waitlaunch_cmd_list;\n\n   public:\n    inline bool hasMatchWaitlaunch(const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_waitlaunch_cmd_list.find(__cmd.m_dst) == m_waitlaunch_cmd_list.end()) {\n            return false;\n        }\n\n        SyncCmdList&amp; cmd_list = m_waitlaunch_cmd_list[__cmd.m_dst];\n\n        for (std::size_t i = 0; i &lt; cmd_list.size(); i++) {\n            InterChiplet::SyncCommand&amp; __waitlaunch_cmd = cmd_list[i];\n            if (UNSPECIFIED_ADDR(__waitlaunch_cmd.m_src)) {\n                if (__cmd.m_dst == __waitlaunch_cmd.m_dst) {\n                    return true;\n                }\n            } else {\n                if (__cmd.m_src == __waitlaunch_cmd.m_src &amp;&amp;\n                    __cmd.m_dst == __waitlaunch_cmd.m_dst) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    inline InterChiplet::SyncCommand popMatchWaitlaunch(const InterChiplet::SyncCommand&amp; __cmd) {\n        SyncCmdList&amp; cmd_list = m_waitlaunch_cmd_list[__cmd.m_dst];\n\n        for (std::size_t i = 0; i &lt; cmd_list.size(); i++) {\n            InterChiplet::SyncCommand&amp; __waitlaunch_cmd = cmd_list[i];\n            if (UNSPECIFIED_ADDR(__waitlaunch_cmd.m_src)) {\n                if (__cmd.m_dst == __waitlaunch_cmd.m_dst) {\n                    InterChiplet::SyncCommand match_cmd = cmd_list[i];\n                    cmd_list.erase(cmd_list.begin() + i);\n                    return match_cmd;\n                }\n            } else {\n                if (__cmd.m_src == __waitlaunch_cmd.m_src &amp;&amp;\n                    __cmd.m_dst == __waitlaunch_cmd.m_dst) {\n                    InterChiplet::SyncCommand match_cmd = cmd_list[i];\n                    cmd_list.erase(cmd_list.begin() + i);\n                    return match_cmd;\n                }\n            }\n        }\n        return InterChiplet::SyncCommand();\n    }\n\n    inline void insertWaitlaunch(InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_waitlaunch_cmd_list.find(__cmd.m_dst) == m_waitlaunch_cmd_list.end()) {\n            m_waitlaunch_cmd_list[__cmd.m_dst] = SyncCmdList();\n        }\n        m_waitlaunch_cmd_list[__cmd.m_dst].push_back(__cmd);\n    }\n\n    inline void insertWaitlaunch(const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_waitlaunch_cmd_list.find(__cmd.m_dst) == m_waitlaunch_cmd_list.end()) {\n            m_waitlaunch_cmd_list[__cmd.m_dst] = SyncCmdList();\n        }\n        m_waitlaunch_cmd_list[__cmd.m_dst].push_back(__cmd);\n    }\n\n    inline bool hasMatchLaunch(const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_launch_cmd_list.find(__cmd.m_dst) == m_launch_cmd_list.end()) {\n            return false;\n        }\n\n        SyncCmdList&amp; cmd_list = m_launch_cmd_list[__cmd.m_dst];\n\n        for (std::size_t i = 0; i &lt; cmd_list.size(); i++) {\n            InterChiplet::SyncCommand&amp; __launch_cmd = cmd_list[i];\n            if (UNSPECIFIED_ADDR(__cmd.m_src)) {\n                if (__cmd.m_dst == __launch_cmd.m_dst) {\n                    return true;\n                }\n            } else {\n                if (__cmd.m_src == __launch_cmd.m_src &amp;&amp; __cmd.m_dst == __launch_cmd.m_dst) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    inline InterChiplet::SyncCommand popMatchLaunch(const InterChiplet::SyncCommand&amp; __cmd) {\n        SyncCmdList&amp; cmd_list = m_launch_cmd_list[__cmd.m_dst];\n\n        for (std::size_t i = 0; i &lt; cmd_list.size(); i++) {\n            InterChiplet::SyncCommand&amp; __launch_cmd = cmd_list[i];\n            if (UNSPECIFIED_ADDR(__cmd.m_src)) {\n                if (__cmd.m_dst == __launch_cmd.m_dst) {\n                    InterChiplet::SyncCommand match_cmd = cmd_list[i];\n                    cmd_list.erase(cmd_list.begin() + i);\n                    return match_cmd;\n                }\n            } else {\n                if (__cmd.m_src == __launch_cmd.m_src &amp;&amp; __cmd.m_dst == __launch_cmd.m_dst) {\n                    InterChiplet::SyncCommand match_cmd = cmd_list[i];\n                    cmd_list.erase(cmd_list.begin() + i);\n                    return match_cmd;\n                }\n            }\n        }\n        return InterChiplet::SyncCommand();\n    }\n\n    inline void insertLaunch(InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_launch_cmd_list.find(__cmd.m_dst) == m_launch_cmd_list.end()) {\n            m_launch_cmd_list[__cmd.m_dst] = SyncCmdList();\n        }\n        m_launch_cmd_list[__cmd.m_dst].push_back(__cmd);\n    }\n\n    inline void insertLaunch(const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_launch_cmd_list.find(__cmd.m_dst) == m_launch_cmd_list.end()) {\n            m_launch_cmd_list[__cmd.m_dst] = SyncCmdList();\n        }\n        m_launch_cmd_list[__cmd.m_dst].push_back(__cmd);\n    }\n};\n\nclass SyncCommStruct {\n   private:\n    std::map&lt;InterChiplet::AddrType, SyncCmdList&gt; m_read_cmd_list;\n    std::map&lt;InterChiplet::AddrType, SyncCmdList&gt; m_write_cmd_list;\n\n   public:\n    inline bool hasMatchWrite(const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_write_cmd_list.find(__cmd.m_dst) == m_write_cmd_list.end()) {\n            return false;\n        }\n\n        SyncCmdList&amp; cmd_list = m_write_cmd_list[__cmd.m_dst];\n\n        for (std::size_t i = 0; i &lt; cmd_list.size(); i++) {\n            InterChiplet::SyncCommand&amp; __write_cmd = cmd_list[i];\n            if (__cmd.m_src == __write_cmd.m_src &amp;&amp; __cmd.m_dst == __write_cmd.m_dst &amp;&amp;\n                __cmd.m_nbytes == __write_cmd.m_nbytes) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    inline InterChiplet::SyncCommand popMatchWrite(const InterChiplet::SyncCommand&amp; __cmd) {\n        SyncCmdList&amp; cmd_list = m_write_cmd_list[__cmd.m_dst];\n\n        for (std::size_t i = 0; i &lt; cmd_list.size(); i++) {\n            InterChiplet::SyncCommand&amp; __write_cmd = cmd_list[i];\n            if (__cmd.m_src == __write_cmd.m_src &amp;&amp; __cmd.m_dst == __write_cmd.m_dst &amp;&amp;\n                __cmd.m_nbytes == __write_cmd.m_nbytes) {\n                InterChiplet::SyncCommand match_cmd = cmd_list[i];\n                cmd_list.erase(cmd_list.begin() + i);\n                return match_cmd;\n            }\n        }\n        return InterChiplet::SyncCommand();\n    }\n\n    inline void insertWrite(InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_write_cmd_list.find(__cmd.m_dst) == m_write_cmd_list.end()) {\n            m_write_cmd_list[__cmd.m_dst] = std::vector&lt;InterChiplet::SyncCommand&gt;();\n        }\n        m_write_cmd_list[__cmd.m_dst].push_back(__cmd);\n    }\n\n    inline void insertWrite(const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_write_cmd_list.find(__cmd.m_dst) == m_write_cmd_list.end()) {\n            m_write_cmd_list[__cmd.m_dst] = std::vector&lt;InterChiplet::SyncCommand&gt;();\n        }\n        m_write_cmd_list[__cmd.m_dst].push_back(__cmd);\n    }\n\n    inline bool hasMatchRead(const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_read_cmd_list.find(__cmd.m_dst) == m_read_cmd_list.end()) {\n            return false;\n        }\n\n        SyncCmdList&amp; cmd_list = m_read_cmd_list[__cmd.m_dst];\n\n        for (std::size_t i = 0; i &lt; cmd_list.size(); i++) {\n            InterChiplet::SyncCommand&amp; __read_cmd = cmd_list[i];\n            if (__cmd.m_src == __read_cmd.m_src &amp;&amp; __cmd.m_dst == __read_cmd.m_dst &amp;&amp;\n                __cmd.m_nbytes == __read_cmd.m_nbytes) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    inline InterChiplet::SyncCommand popMatchRead(const InterChiplet::SyncCommand&amp; __cmd) {\n        SyncCmdList&amp; cmd_list = m_read_cmd_list[__cmd.m_dst];\n\n        for (std::size_t i = 0; i &lt; cmd_list.size(); i++) {\n            InterChiplet::SyncCommand&amp; __read_cmd = cmd_list[i];\n            if (__cmd.m_src == __read_cmd.m_src &amp;&amp; __cmd.m_dst == __read_cmd.m_dst &amp;&amp;\n                __cmd.m_nbytes == __read_cmd.m_nbytes) {\n                InterChiplet::SyncCommand match_cmd = cmd_list[i];\n                cmd_list.erase(cmd_list.begin() + i);\n                return match_cmd;\n            }\n        }\n        return InterChiplet::SyncCommand();\n    }\n\n    inline void insertRead(InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_read_cmd_list.find(__cmd.m_dst) == m_read_cmd_list.end()) {\n            m_read_cmd_list[__cmd.m_dst] = std::vector&lt;InterChiplet::SyncCommand&gt;();\n        }\n        m_read_cmd_list[__cmd.m_dst].push_back(__cmd);\n    }\n\n    inline void insertRead(const InterChiplet::SyncCommand&amp; __cmd) {\n        if (m_read_cmd_list.find(__cmd.m_dst) == m_read_cmd_list.end()) {\n            m_read_cmd_list[__cmd.m_dst] = std::vector&lt;InterChiplet::SyncCommand&gt;();\n        }\n        m_read_cmd_list[__cmd.m_dst].push_back(__cmd);\n    }\n};\n\nclass SyncStruct {\n   public:\n    SyncStruct() {\n        if (pthread_mutex_init(&amp;m_mutex, NULL) &lt; 0) {\n            perror(\"pthread_mutex_init\");\n            exit(EXIT_FAILURE);\n        }\n    }\n\n    ~SyncStruct() { pthread_mutex_destroy(&amp;m_mutex); }\n\n   public:\n    pthread_mutex_t m_mutex;\n\n    NetworkBenchList m_bench_list;\n    NetworkDelayStruct m_delay_list;\n\n    SyncClockStruct m_cycle_struct;\n\n    SyncPipeStruct m_pipe_struct;\n    SyncBarrierStruct m_barrier_struct;\n    SyncLockStruct m_lock_struct;\n    SyncLaunchStruct m_launch_struct;\n\n    SyncCommStruct m_comm_struct;\n    SyncBarrierStruct m_barrier_timing_struct;\n    SyncLockStruct m_lock_timing_struct;\n};\nvoid handle_cycle_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n\nvoid handle_pipe_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n\nvoid handle_barrier_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n\nvoid handle_lock_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n\nvoid handle_unlock_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n\nvoid handle_launch_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n\nvoid handle_waitlaunch_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n\nvoid handle_read_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n\nvoid handle_write_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct);\n</code></pre>"},{"location":"apiProject1/cmdline__options_8h/","title":"File cmdline_options.h","text":"<p>FileList &gt; includes &gt; cmdline_options.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include \"CLI/CLI.hpp\"</code></li> </ul>"},{"location":"apiProject1/cmdline__options_8h/#classes","title":"Classes","text":"Type Name class CmdLineOptions Options from command line. <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/cmdline_options.h</code></p>"},{"location":"apiProject1/cmdline__options_8h_source/","title":"File cmdline_options.h","text":"<p>File List &gt; includes &gt; cmdline_options.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;iostream&gt;\n\n#include \"CLI/CLI.hpp\"\n\nclass CmdLineOptions {\n   public:\n    CmdLineOptions()\n        : m_bench(), m_cwd(), m_timeout_threshold(5), m_err_rate_threshold(0.005), m_debug(false) {}\n\n    int parse(int argc, const char* argv[]) {\n        CLI::App app{\"Lego Chiplet Simulator\"};\n        app.add_option(\"bench\", m_bench, \"Benchmark configuration file (.yml)\")\n            -&gt;required()\n            -&gt;check(CLI::ExistingFile);\n        app.add_option(\"-t,--timeout\", m_timeout_threshold, \"Time out threshold, in time of round.\")\n            -&gt;check(CLI::PositiveNumber);\n        app.add_option(\"-e,--error\", m_err_rate_threshold, \"Error rate when quit simulation.\");\n        app.add_option(\"--cwd\", m_cwd, \"Woring directory for simulation.\")\n            -&gt;check(CLI::ExistingPath);\n        app.add_flag(\"--debug\", m_debug, \"Print debug information.\");\n\n        try {\n            app.parse(argc, argv);\n        } catch (const CLI::ParseError&amp; e) {\n            int ret = app.exit(e);\n            exit(ret);\n        }\n\n        return 0;\n    }\n\n   public:\n    std::string m_bench;\n    std::string m_cwd;\n\n    long m_timeout_threshold;\n    double m_err_rate_threshold;\n\n    bool m_debug;\n};\n</code></pre>"},{"location":"apiProject1/global__define_8h/","title":"File global_define.h","text":"<p>FileList &gt; includes &gt; global_define.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"apiProject1/global__define_8h/#namespaces","title":"Namespaces","text":"Type Name namespace InterChiplet"},{"location":"apiProject1/global__define_8h/#classes","title":"Classes","text":"Type Name class SyncCommand Structure of synchronization command."},{"location":"apiProject1/global__define_8h/#macros","title":"Macros","text":"Type Name define DIM_X (addr) (addr[0]) define DIM_Y (addr) (addr[1]) define UNSPECIFIED_ADDR (addr) ((addr[0]) &lt; 0 &amp;&amp; (addr[1]) &lt; 0)"},{"location":"apiProject1/global__define_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiProject1/global__define_8h/#define-dim_x","title":"define DIM_X","text":"<pre><code>#define DIM_X (\n    addr\n) (addr[0])\n</code></pre>"},{"location":"apiProject1/global__define_8h/#define-dim_y","title":"define DIM_Y","text":"<pre><code>#define DIM_Y (\n    addr\n) (addr[1])\n</code></pre>"},{"location":"apiProject1/global__define_8h/#define-unspecified_addr","title":"define UNSPECIFIED_ADDR","text":"<pre><code>#define UNSPECIFIED_ADDR (\n    addr\n) ((addr[0]) &lt; 0 &amp;&amp; (addr[1]) &lt; 0)\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/global_define.h</code></p>"},{"location":"apiProject1/global__define_8h_source/","title":"File global_define.h","text":"<p>File List &gt; includes &gt; global_define.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace InterChiplet {\nenum SysCallID {\n    // SYSCALL_TEST_CHANGE = 500,        // Test\n    // SYSCALL_REG_FUNC = 503,           // Send register function to pin (depreciate)\n    // SYSCALL_CONNECT = 504,            // Setup connection.\n    // SYSCALL_DISCONNECT = 505,         // Stop connection.\n    // SYSCALL_GET_LOCAL_ADDR = 506,     // Get address of current processor.\n    // SYSCALL_CHECK_REMOTE_READ = 507,  // Check remote read\n\n    SYSCALL_LAUNCH = 501,        // Launch request.\n    SYSCALL_WAITLAUNCH = 502,    // Waiit launch request.\n    SYSCALL_BARRIER = 503,       // Enter barrier.\n    SYSCALL_LOCK = 504,          // Lock mutex.\n    SYSCALL_UNLOCK = 505,        // Unlock mutex.\n    SYSCALL_REMOTE_READ = 506,   // Read cross chiplet\n    SYSCALL_REMOTE_WRITE = 507,  // Write cross chiplet\n};\n\ntypedef unsigned long long TimeType;\n\ntypedef double InnerTimeType;\n\ntypedef std::vector&lt;long&gt; AddrType;\n\n#define DIM_X(addr) (addr[0])\n#define DIM_Y(addr) (addr[1])\n#define UNSPECIFIED_ADDR(addr) ((addr[0]) &lt; 0 &amp;&amp; (addr[1]) &lt; 0)\n\nenum SyncCommType {\n    SC_CYCLE,\n    SC_SEND,\n    SC_RECEIVE,\n    SC_BARRIER,\n    SC_LOCK,\n    SC_UNLOCK,\n    SC_LAUNCH,\n    SC_WAITLAUNCH,\n    SC_READ,\n    SC_WRITE,\n    SC_SYNC,\n    SC_RESULT,\n};\n\nenum SyncProtocolDesc {\n    SPD_ACK = 0x01,\n    SPD_PRE_SYNC = 0x02,\n    SPD_POST_SYNC = 0x04,\n    SPD_LAUNCH = 0x10000,\n    SPD_BARRIER = 0x20000,\n    SPD_LOCK = 0x40000,\n    SPD_UNLOCK = 0x80000,\n};\n\nclass SyncCommand {\n   public:\n    SyncCommType m_type;\n    InnerTimeType m_cycle;\n    double m_clock_rate;\n    AddrType m_src;\n    AddrType m_dst;\n    int m_nbytes;\n    long m_desc;\n\n    std::vector&lt;std::string&gt; m_res_list;\n\n    int m_stdin_fd;\n};\n}  // namespace InterChiplet\n</code></pre>"},{"location":"apiProject1/net__bench_8h/","title":"File net_bench.h","text":"<p>FileList &gt; includes &gt; net_bench.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include \"global_define.h\"</code></li> </ul>"},{"location":"apiProject1/net__bench_8h/#classes","title":"Classes","text":"Type Name class NetworkBenchItem Structure of one package in network. class NetworkBenchList List of network benchmark item."},{"location":"apiProject1/net__bench_8h/#macros","title":"Macros","text":"Type Name define PAC_PAYLOAD_BIT  512 define PAC_PAYLOAD_BYTE  (PAC_PAYLOAD_BIT / 8)"},{"location":"apiProject1/net__bench_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiProject1/net__bench_8h/#define-pac_payload_bit","title":"define PAC_PAYLOAD_BIT","text":"<pre><code>#define PAC_PAYLOAD_BIT 512\n</code></pre>"},{"location":"apiProject1/net__bench_8h/#define-pac_payload_byte","title":"define PAC_PAYLOAD_BYTE","text":"<pre><code>#define PAC_PAYLOAD_BYTE (PAC_PAYLOAD_BIT / 8)\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/net_bench.h</code></p>"},{"location":"apiProject1/net__bench_8h_source/","title":"File net_bench.h","text":"<p>File List &gt; includes &gt; net_bench.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;map&gt;\n\n#include \"global_define.h\"\n\n#define PAC_PAYLOAD_BIT 512\n#define PAC_PAYLOAD_BYTE (PAC_PAYLOAD_BIT / 8)\n\nclass NetworkBenchItem {\n   public:\n    InterChiplet::InnerTimeType m_src_cycle;\n    InterChiplet::InnerTimeType m_dst_cycle;\n    uint64_t m_id;\n    InterChiplet::AddrType m_src;\n    InterChiplet::AddrType m_dst;\n    int m_pac_size;\n    long m_desc;\n\n   public:\n    NetworkBenchItem() {}\n\n    NetworkBenchItem(const InterChiplet::SyncCommand&amp; __src_cmd,\n                     const InterChiplet::SyncCommand&amp; __dst_cmd)\n        : m_src_cycle(__src_cmd.m_cycle),\n          m_dst_cycle(__dst_cmd.m_cycle),\n          m_dst(__src_cmd.m_dst),\n          m_src(__src_cmd.m_src),\n          m_pac_size(1),\n          m_desc(__src_cmd.m_desc | __dst_cmd.m_desc) {\n        // Calculate the number of flit.\n        // One head flit is required any way.\n        m_pac_size = __src_cmd.m_nbytes / PAC_PAYLOAD_BYTE +\n                     ((__src_cmd.m_nbytes % PAC_PAYLOAD_BYTE) &gt; 0 ? 1 : 0) + 1;\n    }\n\n    NetworkBenchItem(const InterChiplet::SyncCommand&amp; __src_cmd)\n        : m_src_cycle(__src_cmd.m_cycle),\n          m_dst_cycle(__src_cmd.m_cycle),\n          m_dst(__src_cmd.m_dst),\n          m_src(__src_cmd.m_src),\n          m_pac_size(1),\n          m_desc(__src_cmd.m_desc) {\n        // Calculate the number of flit.\n        // One head flit is required any way.\n        m_pac_size = __src_cmd.m_nbytes / PAC_PAYLOAD_BYTE +\n                     ((__src_cmd.m_nbytes % PAC_PAYLOAD_BYTE) &gt; 0 ? 1 : 0) + 1;\n    }\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NetworkBenchItem&amp; __item) {\n        os &lt;&lt; __item.m_src_cycle &lt;&lt; \" \" &lt;&lt; __item.m_dst_cycle &lt;&lt; \" \" &lt;&lt; DIM_X(__item.m_src) &lt;&lt; \" \"\n           &lt;&lt; DIM_Y(__item.m_src) &lt;&lt; \" \" &lt;&lt; DIM_X(__item.m_dst) &lt;&lt; \" \" &lt;&lt; DIM_Y(__item.m_dst) &lt;&lt; \" \"\n           &lt;&lt; __item.m_pac_size &lt;&lt; \" \" &lt;&lt; __item.m_desc;\n        return os;\n    }\n\n    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; os, NetworkBenchItem&amp; __item) {\n        os &gt;&gt; __item.m_src_cycle &gt;&gt; __item.m_dst_cycle;\n        long src_x, src_y, dst_x, dst_y;\n        os &gt;&gt; src_x &gt;&gt; src_y &gt;&gt; dst_x &gt;&gt; dst_y;\n        __item.m_src.push_back(src_x);\n        __item.m_src.push_back(src_y);\n        __item.m_dst.push_back(dst_x);\n        __item.m_dst.push_back(dst_y);\n        os &gt;&gt; __item.m_pac_size &gt;&gt; __item.m_desc;\n        return os;\n    }\n};\n\nclass NetworkBenchList : public std::multimap&lt;InterChiplet::InnerTimeType, NetworkBenchItem&gt; {\n   public:\n    NetworkBenchList() : std::multimap&lt;InterChiplet::InnerTimeType, NetworkBenchItem&gt;() {}\n\n    void insert(const NetworkBenchItem&amp; __item) {\n        std::multimap&lt;InterChiplet::InnerTimeType, NetworkBenchItem&gt;::insert(\n            std::pair&lt;InterChiplet::InnerTimeType, NetworkBenchItem&gt;(__item.m_src_cycle, __item));\n    }\n\n    void dumpBench(const std::string&amp; __file_name, double __clock_rate) {\n        std::ofstream bench_of(__file_name, std::ios::out);\n        for (auto&amp; it : *this) {\n            bench_of &lt;&lt; static_cast&lt;InterChiplet::TimeType&gt;(it.second.m_src_cycle * __clock_rate)\n                     &lt;&lt; \" \"\n                     &lt;&lt; static_cast&lt;InterChiplet::TimeType&gt;(it.second.m_dst_cycle * __clock_rate)\n                     &lt;&lt; \" \" &lt;&lt; DIM_X(it.second.m_src) &lt;&lt; \" \" &lt;&lt; DIM_Y(it.second.m_src) &lt;&lt; \" \"\n                     &lt;&lt; DIM_X(it.second.m_dst) &lt;&lt; \" \" &lt;&lt; DIM_Y(it.second.m_dst) &lt;&lt; \" \"\n                     &lt;&lt; it.second.m_pac_size &lt;&lt; \" \" &lt;&lt; it.second.m_desc &lt;&lt; std::endl;\n        }\n        bench_of.flush();\n        bench_of.close();\n    }\n};\n</code></pre>"},{"location":"apiProject1/net__delay_8h/","title":"File net_delay.h","text":"<p>FileList &gt; includes &gt; net_delay.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include \"global_define.h\"</code></li> <li><code>#include \"spdlog/spdlog.h\"</code></li> </ul>"},{"location":"apiProject1/net__delay_8h/#classes","title":"Classes","text":"Type Name class NetworkDelayItem Structure presents delay of one package in network. class NetworkDelayMap Map for network delay information. class NetworkDelayStruct List of network delay item."},{"location":"apiProject1/net__delay_8h/#public-types","title":"Public Types","text":"Type Name typedef std::tuple&lt; InterChiplet::InnerTimeType, InterChiplet::InnerTimeType &gt; CmdDelayPair typedef std::multimap&lt; InterChiplet::InnerTimeType, NetworkDelayItem &gt; NetworkDelayOrder"},{"location":"apiProject1/net__delay_8h/#macros","title":"Macros","text":"Type Name define DST_DELAY (pair) std::get&lt;1&gt;(pair) define PAC_PAYLOAD_BIT  512 define PAC_PAYLOAD_BYTE  (PAC_PAYLOAD_BIT / 8) define SRC_DELAY (pair) std::get&lt;0&gt;(pair)"},{"location":"apiProject1/net__delay_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"apiProject1/net__delay_8h/#typedef-cmddelaypair","title":"typedef CmdDelayPair","text":"<pre><code>typedef std::tuple&lt;InterChiplet::InnerTimeType, InterChiplet::InnerTimeType&gt; CmdDelayPair;\n</code></pre>"},{"location":"apiProject1/net__delay_8h/#typedef-networkdelayorder","title":"typedef NetworkDelayOrder","text":"<pre><code>typedef std::multimap&lt;InterChiplet::InnerTimeType, NetworkDelayItem&gt; NetworkDelayOrder;\n</code></pre>"},{"location":"apiProject1/net__delay_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiProject1/net__delay_8h/#define-dst_delay","title":"define DST_DELAY","text":"<pre><code>#define DST_DELAY (\n    pair\n) std::get&lt;1&gt;(pair)\n</code></pre>"},{"location":"apiProject1/net__delay_8h/#define-pac_payload_bit","title":"define PAC_PAYLOAD_BIT","text":"<pre><code>#define PAC_PAYLOAD_BIT 512\n</code></pre>"},{"location":"apiProject1/net__delay_8h/#define-pac_payload_byte","title":"define PAC_PAYLOAD_BYTE","text":"<pre><code>#define PAC_PAYLOAD_BYTE (PAC_PAYLOAD_BIT / 8)\n</code></pre>"},{"location":"apiProject1/net__delay_8h/#define-src_delay","title":"define SRC_DELAY","text":"<pre><code>#define SRC_DELAY (\n    pair\n) std::get&lt;0&gt;(pair)\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/net_delay.h</code></p>"},{"location":"apiProject1/net__delay_8h_source/","title":"File net_delay.h","text":"<p>File List &gt; includes &gt; net_delay.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;fstream&gt;\n#include &lt;map&gt;\n\n#include \"global_define.h\"\n#include \"spdlog/spdlog.h\"\n\n#define PAC_PAYLOAD_BIT 512\n#define PAC_PAYLOAD_BYTE (PAC_PAYLOAD_BIT / 8)\n\nclass NetworkDelayItem {\n   public:\n    InterChiplet::InnerTimeType m_cycle;\n    uint64_t m_id;\n    InterChiplet::AddrType m_src;\n    InterChiplet::AddrType m_dst;\n    long m_desc;\n    std::vector&lt;InterChiplet::InnerTimeType&gt; m_delay_list;\n\n   public:\n    NetworkDelayItem() {}\n\n    NetworkDelayItem(InterChiplet::InnerTimeType __cycle, const InterChiplet::AddrType&amp; __src,\n                     const InterChiplet::AddrType&amp; __dst, long __desc,\n                     const std::vector&lt;InterChiplet::InnerTimeType&gt;&amp; __delay_list)\n        : m_cycle(__cycle), m_dst(__dst), m_src(__src), m_delay_list(__delay_list) {}\n\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const NetworkDelayItem&amp; __item) {\n        os &lt;&lt; __item.m_cycle &lt;&lt; \" \" &lt;&lt; DIM_X(__item.m_src) &lt;&lt; \" \" &lt;&lt; DIM_Y(__item.m_src) &lt;&lt; \" \"\n           &lt;&lt; DIM_Y(__item.m_dst) &lt;&lt; \" \" &lt;&lt; DIM_X(__item.m_dst) &lt;&lt; \" \" &lt;&lt; __item.m_desc &lt;&lt; \" \"\n           &lt;&lt; __item.m_delay_list.size();\n        for (auto&amp; delay : __item.m_delay_list) {\n            os &lt;&lt; \" \" &lt;&lt; delay;\n        }\n        return os;\n    }\n\n    friend std::istream&amp; operator&gt;&gt;(std::istream&amp; os, NetworkDelayItem&amp; __item) {\n        os &gt;&gt; __item.m_cycle;\n        long src_x, src_y, dst_x, dst_y;\n        os &gt;&gt; src_x &gt;&gt; src_y &gt;&gt; dst_x &gt;&gt; dst_y;\n        __item.m_src.push_back(src_x);\n        __item.m_src.push_back(src_y);\n        __item.m_dst.push_back(dst_x);\n        __item.m_dst.push_back(dst_y);\n        os &gt;&gt; __item.m_desc;\n        int delay_cnt = 0;\n        os &gt;&gt; delay_cnt;\n        for (int i = 0; i &lt; delay_cnt; i++) {\n            InterChiplet::TimeType delay;\n            os &gt;&gt; delay;\n            __item.m_delay_list.push_back(delay);\n        }\n        return os;\n    }\n};\n\ntypedef std::tuple&lt;InterChiplet::InnerTimeType, InterChiplet::InnerTimeType&gt; CmdDelayPair;\n#define SRC_DELAY(pair) std::get&lt;0&gt;(pair)\n#define DST_DELAY(pair) std::get&lt;1&gt;(pair)\ntypedef std::multimap&lt;InterChiplet::InnerTimeType, NetworkDelayItem&gt; NetworkDelayOrder;\n\nclass NetworkDelayMap : public std::map&lt;InterChiplet::AddrType, NetworkDelayOrder&gt; {\n   public:\n    void insert(const InterChiplet::AddrType&amp; __addr, InterChiplet::InnerTimeType __cycle,\n                const NetworkDelayItem&amp; __item) {\n        if (find(__addr) == end()) {\n            (*this)[__addr] = NetworkDelayOrder();\n        }\n        (*this)[__addr].insert(\n            std::pair&lt;InterChiplet::InnerTimeType, NetworkDelayItem&gt;(__cycle, __item));\n    }\n\n    bool hasAddr(const InterChiplet::AddrType&amp; __addr) {\n        // If there is no address, return false.\n        if (find(__addr) == end()) {\n            return false;\n        }\n        // If there is no delay information for the address, return false.\n        return at(__addr).size() &gt; 0;\n    }\n\n    bool hasAddr(const InterChiplet::AddrType&amp; __addr, const InterChiplet::AddrType&amp; __src,\n                 const InterChiplet::AddrType&amp; __dst) {\n        // If there is no address, return false.\n        if (find(__addr) == end()) {\n            return false;\n        }\n        // If there is no delay information for the address, return false.\n        for (NetworkDelayOrder::iterator it = (*this)[__addr].begin(); it != (*this)[__addr].end();\n             it++) {\n            if (it-&gt;second.m_src == __src &amp;&amp; it-&gt;second.m_dst == __dst) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    NetworkDelayItem front(const InterChiplet::AddrType&amp; __addr) {\n        // If there is no destination address, return empty.\n        if (find(__addr) == end()) {\n            return NetworkDelayItem();\n        }\n        // If there is no delay information for the address, return false.\n        if (at(__addr).size() == 0) {\n            return NetworkDelayItem();\n        }\n\n        return at(__addr).begin()-&gt;second;\n    }\n\n    NetworkDelayItem front(const InterChiplet::AddrType&amp; __addr,\n                           const InterChiplet::AddrType&amp; __src,\n                           const InterChiplet::AddrType&amp; __dst) {\n        // If there is no destination address, return empty.\n        if (find(__addr) == end()) {\n            return NetworkDelayItem();\n        }\n        // If there is no delay information for the address, return false.\n        for (NetworkDelayOrder::iterator it = (*this)[__addr].begin(); it != (*this)[__addr].end();\n             it++) {\n            if (it-&gt;second.m_src == __src &amp;&amp; it-&gt;second.m_dst == __dst) {\n                return it-&gt;second;\n            }\n        }\n        return NetworkDelayItem();\n    }\n\n    void pop(const InterChiplet::AddrType&amp; __addr) {\n        // If there is no destination address, do nothing.\n        if (find(__addr) == end()) {\n            return;\n        }\n        // If there is no delay information for the address, do nothing.\n        if (at(__addr).size() == 0) {\n            return;\n        }\n\n        at(__addr).erase(at(__addr).begin());\n    }\n\n    void pop(const InterChiplet::AddrType&amp; __addr, const InterChiplet::AddrType&amp; __src,\n             const InterChiplet::AddrType&amp; __dst) {\n        // If there is no destination address, do nothing.\n        if (find(__addr) == end()) {\n            return;\n        }\n        // If there is no delay information for the address, return false.\n        for (NetworkDelayOrder::iterator it = (*this)[__addr].begin(); it != (*this)[__addr].end();\n             it++) {\n            if (it-&gt;second.m_src == __src &amp;&amp; it-&gt;second.m_dst == __dst) {\n                (*this)[__addr].erase(it);\n                return;\n            }\n        }\n    }\n\n    bool checkOrderOfCommand(const InterChiplet::SyncCommand&amp; __cmd) {\n        // If the source does not exist, return false.\n        if (find(__cmd.m_src) == end()) {\n            return true;\n        }\n\n        // If the source has no packet, return false.\n        if ((*this)[__cmd.m_src].size() == 0) {\n            return true;\n        }\n\n        NetworkDelayItem&amp; delay_item = (*this)[__cmd.m_src].begin()-&gt;second;\n        // Return true if command matches the first item in delay information list.\n        if (delay_item.m_src == __cmd.m_src &amp;&amp; delay_item.m_dst == __cmd.m_dst &amp;&amp;\n            delay_item.m_desc == __cmd.m_desc) {\n            return true;\n        } else {\n            spdlog::warn(\"Delay info from {},{} to {},{} with flag {}.\", delay_item.m_src[0],\n                         delay_item.m_src[1], delay_item.m_dst[0], delay_item.m_dst[1],\n                         delay_item.m_desc);\n            spdlog::warn(\"Command    from {},{} to {},{} with flag {}.\", __cmd.m_src[0],\n                         __cmd.m_src[1], __cmd.m_dst[0], __cmd.m_dst[1], __cmd.m_desc);\n            return false;\n        }\n    }\n};\n\nclass NetworkDelayStruct {\n   public:\n    NetworkDelayStruct() : m_item_count(0) {}\n\n    int size() const { return m_item_count; }\n\n   public:\n    void loadDelayInfo(const std::string&amp; __file_name, double __clock_rate) {\n        std::ifstream bench_if(__file_name, std::ios::in);\n        m_item_count = 0;\n\n        while (bench_if) {\n            // Load item from file.\n            NetworkDelayItem item;\n            bench_if &gt;&gt; item;\n            if (!bench_if) break;\n            item.m_cycle = item.m_cycle / __clock_rate;\n            for (std::size_t i = 0; i &lt; item.m_delay_list.size(); i++) {\n                item.m_delay_list[i] = item.m_delay_list[i] / __clock_rate;\n            }\n            m_item_count += 1;\n\n            // Source map.\n            m_src_delay_map.insert(item.m_src, item.m_cycle, item);\n            // Ordering of barrier, launch, lock and unlock.\n            if (item.m_desc &amp; 0xF0000) {\n                InterChiplet::InnerTimeType end_cycle = item.m_cycle + item.m_delay_list[1];\n                if (item.m_desc &amp; InterChiplet::SPD_BARRIER) {\n                    m_barrier_delay_map.insert(item.m_dst, end_cycle, item);\n                } else if (item.m_desc &amp; InterChiplet::SPD_LAUNCH) {\n                    m_launch_delay_map.insert(item.m_dst, end_cycle, item);\n                } else if (item.m_desc &amp; InterChiplet::SPD_LOCK) {\n                    m_lock_delay_map.insert(item.m_dst, end_cycle, item);\n                } else if (item.m_desc &amp; InterChiplet::SPD_UNLOCK) {\n                    m_unlock_delay_map.insert(item.m_dst, end_cycle, item);\n                }\n            }\n        }\n    }\n\n    bool checkOrderOfCommand(const InterChiplet::SyncCommand&amp; __cmd) {\n        return m_src_delay_map.checkOrderOfCommand(__cmd);\n    }\n\n    void clearDelayInfo() {\n        // Launch delay list\n        m_src_delay_map.clear();\n        // Launch order.\n        m_launch_delay_map.clear();\n        // Barrier order.\n        m_barrier_delay_map.clear();\n        // Lock order.\n        m_lock_delay_map.clear();\n        // Unlock order.\n        m_unlock_delay_map.clear();\n    }\n\n   public:\n    inline bool hasLaunch(const InterChiplet::AddrType&amp; __dst) {\n        return m_launch_delay_map.hasAddr(__dst);\n    }\n\n    inline InterChiplet::AddrType frontLaunchSrc(const InterChiplet::AddrType&amp; __dst) {\n        return m_launch_delay_map.front(__dst).m_src;\n    }\n\n    inline void popLaunch(const InterChiplet::AddrType&amp; __dst) { m_launch_delay_map.pop(__dst); }\n\n    inline bool hasLock(const InterChiplet::AddrType&amp; __dst) {\n        return m_lock_delay_map.hasAddr(__dst);\n    }\n\n    inline InterChiplet::AddrType frontLockSrc(const InterChiplet::AddrType&amp; __dst) {\n        return m_lock_delay_map.front(__dst).m_src;\n    }\n\n    inline void popLock(const InterChiplet::AddrType&amp; __dst) { m_lock_delay_map.pop(__dst); }\n\n   public:\n    CmdDelayPair getEndCycle(const InterChiplet::SyncCommand&amp; __write_cmd,\n                             const InterChiplet::SyncCommand&amp; __read_cmd) {\n        if (!m_src_delay_map.hasAddr(__write_cmd.m_src, __write_cmd.m_src, __write_cmd.m_dst)) {\n            return getDefaultEndCycle(__write_cmd, __read_cmd);\n        }\n\n        NetworkDelayItem delay_info =\n            m_src_delay_map.front(__write_cmd.m_src, __write_cmd.m_src, __write_cmd.m_dst);\n\n        m_src_delay_map.pop(__write_cmd.m_src, __write_cmd.m_src, __write_cmd.m_dst);\n        // Launch/Barrier/Lock/Unlock communication.\n        if (__write_cmd.m_desc &amp; (InterChiplet::SPD_LAUNCH | InterChiplet::SPD_BARRIER |\n                                  InterChiplet::SPD_LOCK | InterChiplet::SPD_UNLOCK)) {\n            // Forward packet.\n            InterChiplet::InnerTimeType pac_delay_src = delay_info.m_delay_list[0];\n            InterChiplet::InnerTimeType pac_delay_dst = delay_info.m_delay_list[1];\n            InterChiplet::InnerTimeType write_end_time = __write_cmd.m_cycle + pac_delay_src;\n            InterChiplet::InnerTimeType read_end_time = __write_cmd.m_cycle + pac_delay_dst;\n            if (__read_cmd.m_cycle &gt; read_end_time) {\n                read_end_time = __read_cmd.m_cycle;\n            }\n            // Acknowledge packet.\n            InterChiplet::InnerTimeType ack_delay_src = delay_info.m_delay_list[2];\n            InterChiplet::InnerTimeType ack_delay_dst = delay_info.m_delay_list[3];\n            read_end_time = read_end_time + ack_delay_src;\n            write_end_time = read_end_time - ack_delay_src + ack_delay_dst;\n\n            return CmdDelayPair(write_end_time, read_end_time);\n        }\n        // Normal communication.\n        else {\n            // Forward packet.\n            InterChiplet::InnerTimeType pac_delay_src = delay_info.m_delay_list[0];\n            InterChiplet::InnerTimeType pac_delay_dst = delay_info.m_delay_list[1];\n            InterChiplet::InnerTimeType write_end_time = __write_cmd.m_cycle + pac_delay_src;\n            InterChiplet::InnerTimeType read_end_time = __write_cmd.m_cycle + pac_delay_dst;\n            if (__read_cmd.m_cycle &gt; read_end_time) {\n                read_end_time = __read_cmd.m_cycle;\n            }\n            return CmdDelayPair(write_end_time, read_end_time);\n        }\n    }\n\n    InterChiplet::InnerTimeType getBarrierCycle(\n        const std::vector&lt;InterChiplet::SyncCommand&gt;&amp; barrier_items) {\n        InterChiplet::InnerTimeType barrier_cycle = 0;\n        for (auto&amp; item : barrier_items) {\n            InterChiplet::InnerTimeType t_cycle = 0;\n            if (!m_src_delay_map.hasAddr(item.m_src, item.m_src, item.m_dst)) {\n                t_cycle = getDefaultEndCycle(item);\n            } else {\n                NetworkDelayItem delay_info =\n                    m_src_delay_map.front(item.m_src, item.m_src, item.m_dst);\n                t_cycle = delay_info.m_cycle + delay_info.m_delay_list[1];\n            }\n\n            if (t_cycle &gt; barrier_cycle) {\n                barrier_cycle = t_cycle;\n            }\n        }\n        return barrier_cycle;\n    }\n\n   public:\n    InterChiplet::InnerTimeType getDefaultEndCycle(const InterChiplet::SyncCommand&amp; write_cmd) {\n        // TODO: Get more accurate end cycle.\n        int pac_size = write_cmd.m_nbytes / PAC_PAYLOAD_BYTE +\n                       ((write_cmd.m_nbytes % PAC_PAYLOAD_BYTE) &gt; 0 ? 1 : 0) + 1;\n\n        return write_cmd.m_cycle + pac_size;\n    }\n    CmdDelayPair getDefaultEndCycle(const InterChiplet::SyncCommand&amp; write_cmd,\n                                    const InterChiplet::SyncCommand&amp; read_cmd) {\n        // TODO: Get more accurate end cycle.\n        int pac_size = write_cmd.m_nbytes / PAC_PAYLOAD_BYTE +\n                       ((write_cmd.m_nbytes % PAC_PAYLOAD_BYTE) &gt; 0 ? 1 : 0) + 1;\n\n        if (write_cmd.m_cycle &gt;= read_cmd.m_cycle) {\n            return CmdDelayPair(write_cmd.m_cycle + pac_size, write_cmd.m_cycle + pac_size);\n        } else {\n            return CmdDelayPair(read_cmd.m_cycle + pac_size, read_cmd.m_cycle + pac_size);\n        }\n    }\n\n   private:\n    int m_item_count;\n\n    NetworkDelayMap m_src_delay_map;\n    NetworkDelayMap m_launch_delay_map;\n    NetworkDelayMap m_barrier_delay_map;\n    NetworkDelayMap m_lock_delay_map;\n    NetworkDelayMap m_unlock_delay_map;\n};\n</code></pre>"},{"location":"apiProject1/pipe__comm_8h/","title":"File pipe_comm.h","text":"<p>FileList &gt; includes &gt; pipe_comm.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;fcntl.h&gt;</code></li> <li><code>#include &lt;unistd.h&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"global_define.h\"</code></li> <li><code>#include \"sync_protocol.h\"</code></li> </ul>"},{"location":"apiProject1/pipe__comm_8h/#namespaces","title":"Namespaces","text":"Type Name namespace InterChiplet"},{"location":"apiProject1/pipe__comm_8h/#classes","title":"Classes","text":"Type Name class PipeComm Pipe communication structure. class PipeCommUnit Structure for Single Pipe communication."},{"location":"apiProject1/pipe__comm_8h/#macros","title":"Macros","text":"Type Name define NSINTERCHIPLET_CMD_HEAD  \"[INTERCMD]\" define PIPE_COMMON_UNIT_CAPACITY  4096"},{"location":"apiProject1/pipe__comm_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiProject1/pipe__comm_8h/#define-nsinterchiplet_cmd_head","title":"define NSINTERCHIPLET_CMD_HEAD","text":"<pre><code>#define NSINTERCHIPLET_CMD_HEAD \"[INTERCMD]\"\n</code></pre>"},{"location":"apiProject1/pipe__comm_8h/#define-pipe_common_unit_capacity","title":"define PIPE_COMMON_UNIT_CAPACITY","text":"<pre><code>#define PIPE_COMMON_UNIT_CAPACITY 4096\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/pipe_comm.h</code></p>"},{"location":"apiProject1/pipe__comm_8h_source/","title":"File pipe_comm.h","text":"<p>File List &gt; includes &gt; pipe_comm.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\n#include &lt;cstring&gt;\n#include &lt;fstream&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;sstream&gt;\n\n#include \"global_define.h\"\n#include \"sync_protocol.h\"\n\n// #define PIPE_COMMON_DEBUG\n#define PIPE_COMMON_UNIT_CAPACITY 4096\n#define NSINTERCHIPLET_CMD_HEAD \"[INTERCMD]\"\n\nnamespace InterChiplet {\nclass PipeCommUnit {\n   public:\n    PipeCommUnit(const char *file_name, bool read) {\n        m_file_name = std::string(file_name);\n        m_file_id = open(file_name, read ? O_RDONLY : O_WRONLY);\n        if (m_file_id == -1) {\n            std::cerr &lt;&lt; \"Cannot open pipe file \" &lt;&lt; m_file_name &lt;&lt; \".\" &lt;&lt; std::endl;\n            exit(1);\n        } else {\n            std::cout &lt;&lt; \"Open pipe file \" &lt;&lt; m_file_name &lt;&lt; \".\" &lt;&lt; std::endl;\n        }\n\n        if (read) {\n            mp_buf = (uint8_t *)malloc(PIPE_COMMON_UNIT_CAPACITY);\n        }\n        m_size = 0;\n        m_read_ptr = 0;\n\n#ifdef PIPE_COMMON_DEBUG\n        std::string debug_file_name = m_file_name + \".hex\";\n        m_debug_fs.open(debug_file_name.c_str(), std::ios::out);\n        m_debug_col = 0;\n#endif\n    }\n\n    bool valid() const { return m_file_id &gt;= 0; }\n\n    int read_data(void *dst_buf, int nbyte) {\n        uint8_t *uint8_buf = (uint8_t *)dst_buf;\n        int dst_ptr = 0;\n        while (dst_ptr &lt; nbyte) {\n            int iter_nbyte = PIPE_COMMON_UNIT_CAPACITY;\n            if ((nbyte - dst_ptr) &lt; iter_nbyte) iter_nbyte = nbyte - dst_ptr;\n            iter_nbyte = read_data_iter(uint8_buf + dst_ptr, iter_nbyte);\n#ifdef PIPE_COMMON_DEBUG\n            std::cout &lt;&lt; \"[DEBUG read_data] \" &lt;&lt; dst_ptr &lt;&lt; \"\\t\" &lt;&lt; (void *)(uint8_buf + dst_ptr)\n                      &lt;&lt; \"\\t\" &lt;&lt; iter_nbyte &lt;&lt; std::endl;\n#endif\n            if (iter_nbyte &gt; 0) {\n                dst_ptr += iter_nbyte;\n            } else if (iter_nbyte == 0) {\n                std::cerr &lt;&lt; \"Read from \" &lt;&lt; m_file_name &lt;&lt; \" abort due to EOF.\" &lt;&lt; std::endl;\n                break;\n            } else {\n                std::cerr &lt;&lt; \"Read from \" &lt;&lt; m_file_name &lt;&lt; \" abort due to Error.\" &lt;&lt; std::endl;\n                break;\n            }\n        }\n\n        std::cout &lt;&lt; \"Read \" &lt;&lt; dst_ptr &lt;&lt; \" B from \" &lt;&lt; m_file_name &lt;&lt; \".\" &lt;&lt; std::endl;\n        return dst_ptr;\n    }\n\n    int write_data(void *src_buf, int nbyte) {\n        uint8_t *uint8_buf = (uint8_t *)src_buf;\n        int src_ptr = 0;\n        while (src_ptr &lt; nbyte) {\n            int iter_nbyte = PIPE_COMMON_UNIT_CAPACITY;\n            if ((nbyte - src_ptr) &lt; iter_nbyte) iter_nbyte = nbyte - src_ptr;\n            iter_nbyte = write(m_file_id, uint8_buf + src_ptr, iter_nbyte);\n#ifdef PIPE_COMMON_DEBUG\n            std::cout &lt;&lt; \"[DEBUG write_data] \" &lt;&lt; src_ptr &lt;&lt; \"\\t\" &lt;&lt; (void *)(uint8_buf + src_ptr)\n                      &lt;&lt; \"\\t\" &lt;&lt; iter_nbyte &lt;&lt; std::endl;\n#endif\n            if (iter_nbyte &gt; 0) {\n                src_ptr += iter_nbyte;\n            } else if (iter_nbyte == 0) {\n                std::cerr &lt;&lt; \"Write to \" &lt;&lt; m_file_name &lt;&lt; \" abort due to EOF.\" &lt;&lt; std::endl;\n                break;\n            } else {\n                std::cerr &lt;&lt; \"Write to \" &lt;&lt; m_file_name &lt;&lt; \" abort due to Error.\" &lt;&lt; std::endl;\n                break;\n            }\n        }\n\n#ifdef PIPE_COMMON_DEBUG\n        char byte_hex_l, byte_hex_h;\n        for (int i = 0; i &lt; nbyte; i++) {\n            uint8_t byte_value = uint8_buf[i];\n            uint8_t byte_low = byte_value % 16;\n            byte_hex_l = byte_low &lt; 10 ? byte_low + '0' : byte_low + 'A';\n            uint8_t byte_high = byte_value / 16;\n            byte_hex_h = byte_high &lt; 10 ? byte_high + '0' : byte_high + 'A';\n\n            m_debug_fs &lt;&lt; byte_hex_h &lt;&lt; byte_hex_l &lt;&lt; \" \";\n            if (m_debug_col == 15) {\n                m_debug_fs &lt;&lt; \"\\n\";\n                m_debug_col = 0;\n            } else {\n                m_debug_col += 1;\n            }\n        }\n        m_debug_fs.flush();\n#endif\n\n        std::cout &lt;&lt; \"Write \" &lt;&lt; src_ptr &lt;&lt; \" B to \" &lt;&lt; m_file_name &lt;&lt; \".\" &lt;&lt; std::endl;\n        return src_ptr;\n    }\n\n   private:\n    int read_data_iter(uint8_t *dst_buf, int nbyte) {\n        while ((m_size - m_read_ptr) &lt; nbyte) {\n            int left_size = m_size - m_read_ptr;\n            if (left_size &gt; 0 &amp;&amp; m_read_ptr &gt; 0) {\n                memcpy(mp_buf, mp_buf + m_read_ptr, left_size);\n                m_read_ptr = 0;\n                m_size = left_size;\n            } else if (left_size == 0 &amp;&amp; m_read_ptr &gt; 0) {\n                m_read_ptr = 0;\n                m_size = 0;\n            }\n\n            int read_size = read(m_file_id, mp_buf + m_size, PIPE_COMMON_UNIT_CAPACITY - m_size);\n#ifdef PIPE_COMMON_DEBUG\n            std::cerr &lt;&lt; \"[DEBUG read_data_iter] \" &lt;&lt; (void *)(mp_buf + m_size) &lt;&lt; \"\\t\"\n                      &lt;&lt; PIPE_COMMON_UNIT_CAPACITY - m_size &lt;&lt; \"\\t\" &lt;&lt; read_size &lt;&lt; std::endl;\n#endif\n            if (read_size &lt;= 0) {\n                return read_size;\n            } else {\n                m_size += read_size;\n            }\n        }\n\n        memcpy(dst_buf, mp_buf + m_read_ptr, nbyte);\n        m_read_ptr += nbyte;\n        return nbyte;\n    }\n\n   private:\n    std::string m_file_name;\n    int m_file_id;\n    uint8_t *mp_buf;\n    int m_read_ptr;\n    int m_size;\n#ifdef PIPE_COMMON_DEBUG\n    std::ofstream m_debug_fs;\n    int m_debug_col;\n#endif\n};\n\nclass PipeComm {\n   public:\n    PipeComm() : m_named_fifo_map() {}\n\n    int read_data(const char *file_name, void *buf, int nbyte) {\n        std::string file_name_str = std::string(file_name);\n        std::map&lt;std::string, PipeCommUnit *&gt;::iterator it = m_named_fifo_map.find(file_name_str);\n        if (it == m_named_fifo_map.end()) {\n            PipeCommUnit *recv_unit = new PipeCommUnit(file_name, true);\n            m_named_fifo_map[file_name_str] = recv_unit;\n            it = m_named_fifo_map.find(file_name_str);\n        }\n\n        return it-&gt;second-&gt;read_data(buf, nbyte);\n    }\n\n    int write_data(const char *file_name, void *buf, int nbyte) {\n        std::string file_name_str = std::string(file_name);\n        std::map&lt;std::string, PipeCommUnit *&gt;::iterator it = m_named_fifo_map.find(file_name_str);\n        if (it == m_named_fifo_map.end()) {\n            PipeCommUnit *recv_unit = new PipeCommUnit(file_name, false);\n            m_named_fifo_map[file_name_str] = recv_unit;\n            it = m_named_fifo_map.find(file_name_str);\n        }\n\n        return it-&gt;second-&gt;write_data(buf, nbyte);\n    }\n\n   private:\n    std::map&lt;std::string, PipeCommUnit *&gt; m_named_fifo_map;\n};\n}  // namespace InterChiplet\n</code></pre>"},{"location":"apiProject1/sync__protocol_8h/","title":"File sync_protocol.h","text":"<p>FileList &gt; includes &gt; sync_protocol.h</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;fcntl.h&gt;</code></li> <li><code>#include &lt;unistd.h&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;iostream&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include \"global_define.h\"</code></li> </ul>"},{"location":"apiProject1/sync__protocol_8h/#namespaces","title":"Namespaces","text":"Type Name namespace InterChiplet"},{"location":"apiProject1/sync__protocol_8h/#macros","title":"Macros","text":"Type Name define NSINTERCHIPLET_CMD_HEAD  \"[INTERCMD]\""},{"location":"apiProject1/sync__protocol_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiProject1/sync__protocol_8h/#define-nsinterchiplet_cmd_head","title":"define NSINTERCHIPLET_CMD_HEAD","text":"<pre><code>#define NSINTERCHIPLET_CMD_HEAD \"[INTERCMD]\"\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes/sync_protocol.h</code></p>"},{"location":"apiProject1/sync__protocol_8h_source/","title":"File sync_protocol.h","text":"<p>File List &gt; includes &gt; sync_protocol.h</p> <p>Go to the documentation of this file. </p> <pre><code>#pragma once\n\n#include &lt;fcntl.h&gt;\n#include &lt;unistd.h&gt;\n\n#include &lt;cstring&gt;\n#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n\n#include \"global_define.h\"\n\n#define NSINTERCHIPLET_CMD_HEAD \"[INTERCMD]\"\n\nnamespace InterChiplet {\ninline std::string pipeName(const AddrType&amp; __src, const AddrType&amp; __dst) {\n    std::stringstream ss;\n    ss &lt;&lt; \"./buffer\" &lt;&lt; DIM_X(__src) &lt;&lt; \"_\" &lt;&lt; DIM_Y(__src) &lt;&lt; \"_\" &lt;&lt; DIM_X(__dst) &lt;&lt; \"_\"\n       &lt;&lt; DIM_Y(__dst);\n    return ss.str();\n}\n\ninline SyncCommand parseCmd(const std::string&amp; __message) {\n    // Remove command head.\n    std::string message;\n    if (__message.substr(0, 10) == NSINTERCHIPLET_CMD_HEAD) {\n        message = __message.substr(11);\n    } else {\n        message = __message;\n    }\n\n    // Read command from message\n    std::stringstream ss(message);\n    std::string command;\n    ss &gt;&gt; command;\n\n    // Decode command to enumerate.\n    SyncCommand cmd;\n    cmd.m_type = command == \"CYCLE\"        ? SC_CYCLE\n                 : command == \"SEND\"       ? SC_SEND\n                 : command == \"RECEIVE\"    ? SC_RECEIVE\n                 : command == \"BARRIER\"    ? SC_BARRIER\n                 : command == \"LOCK\"       ? SC_LOCK\n                 : command == \"UNLOCK\"     ? SC_UNLOCK\n                 : command == \"LAUNCH\"     ? SC_LAUNCH\n                 : command == \"WAITLAUNCH\" ? SC_WAITLAUNCH\n                 : command == \"READ\"       ? SC_READ\n                 : command == \"WRITE\"      ? SC_WRITE\n                 : command == \"SYNC\"       ? SC_SYNC\n                 : command == \"RESULT\"     ? SC_RESULT\n                                           : SC_CYCLE;\n\n    // Read cycle.\n    if (cmd.m_type == SC_CYCLE || cmd.m_type == SC_READ || cmd.m_type == SC_WRITE ||\n        cmd.m_type == SC_SYNC) {\n        ss &gt;&gt; cmd.m_cycle;\n    } else {\n        cmd.m_cycle = 0;\n    }\n    // Read source address.\n    if (cmd.m_type == SC_SEND || cmd.m_type == SC_RECEIVE || cmd.m_type == SC_BARRIER ||\n        cmd.m_type == SC_LOCK || cmd.m_type == SC_UNLOCK || cmd.m_type == SC_LAUNCH ||\n        cmd.m_type == SC_WAITLAUNCH || cmd.m_type == SC_READ || cmd.m_type == SC_WRITE) {\n        long src_x, src_y;\n        ss &gt;&gt; src_x &gt;&gt; src_y;\n        cmd.m_src.push_back(src_x);\n        cmd.m_src.push_back(src_y);\n    } else {\n        cmd.m_src.push_back(-1);\n        cmd.m_src.push_back(-1);\n    }\n    // Read destination address.\n    if (cmd.m_type == SC_SEND || cmd.m_type == SC_RECEIVE || cmd.m_type == SC_LAUNCH ||\n        cmd.m_type == SC_WAITLAUNCH || cmd.m_type == SC_READ || cmd.m_type == SC_WRITE) {\n        long dst_x, dst_y;\n        ss &gt;&gt; dst_x &gt;&gt; dst_y;\n        cmd.m_dst.push_back(dst_x);\n        cmd.m_dst.push_back(dst_y);\n    }\n    // Read target address.\n    else if (cmd.m_type == SC_BARRIER || cmd.m_type == SC_LOCK || cmd.m_type == SC_UNLOCK) {\n        long dst_x;\n        ss &gt;&gt; dst_x;\n        cmd.m_dst.push_back(dst_x);\n        cmd.m_dst.push_back(0);\n    } else {\n        cmd.m_dst.push_back(-1);\n        cmd.m_dst.push_back(-1);\n    }\n    // Read number of bytes and descriptor.\n    if (cmd.m_type == SC_READ || cmd.m_type == SC_WRITE) {\n        ss &gt;&gt; cmd.m_nbytes &gt;&gt; cmd.m_desc;\n    }\n    // Read barrier count.\n    else if (cmd.m_type == SC_BARRIER) {\n        ss &gt;&gt; cmd.m_nbytes;\n        cmd.m_desc = 0;\n    } else {\n        cmd.m_nbytes = 0;\n        cmd.m_desc = 0;\n    }\n\n    // Read result\n    if (cmd.m_type == SC_RESULT) {\n        int res_cnt;\n        ss &gt;&gt; res_cnt;\n        for (int i = 0; i &lt; res_cnt; i++) {\n            std::string item;\n            ss &gt;&gt; item;\n            cmd.m_res_list.push_back(item);\n        }\n    } else {\n        cmd.m_res_list.clear();\n    }\n\n    return cmd;\n}\n\ninline SyncCommand parseCmd(int __fd_in = STDIN_FILENO) {\n    // Read message from input file descriptor.\n    char* message = new char[1024];\n    while (read(__fd_in, message, 1024) == 0);\n\n    // Split message from '\\n', ignore characters after '\\n'.\n    for (std::size_t i = 0; i &lt; strlen(message); i++) {\n        if (message[i] == '\\n') message[i + 1] = 0;\n    }\n    std::cout &lt;&lt; \"[RESPONSE]\" &lt;&lt; message;\n\n    // Parse command.\n    SyncCommand cmd = parseCmd(std::string(message));\n    delete message;\n\n    // Return message.\n    return cmd;\n}\n\ninline std::string dumpCmd(const SyncCommand&amp; __cmd) {\n    std::stringstream ss;\n    std::string type_str = __cmd.m_type == SC_CYCLE        ? \"CYCLE\"\n                           : __cmd.m_type == SC_SEND       ? \"SEND\"\n                           : __cmd.m_type == SC_RECEIVE    ? \"RECEIVE\"\n                           : __cmd.m_type == SC_BARRIER    ? \"BARRIER\"\n                           : __cmd.m_type == SC_LOCK       ? \"LOCK\"\n                           : __cmd.m_type == SC_UNLOCK     ? \"UNLOCK\"\n                           : __cmd.m_type == SC_LAUNCH     ? \"LAUNCH\"\n                           : __cmd.m_type == SC_WAITLAUNCH ? \"WAITLAUNCH\"\n                           : __cmd.m_type == SC_READ       ? \"READ\"\n                           : __cmd.m_type == SC_WRITE      ? \"WRITE\"\n                           : __cmd.m_type == SC_SYNC       ? \"SYNC\"\n                           : __cmd.m_type == SC_RESULT     ? \"RESULT\"\n                                                           : \"CYCLE\";\n    ss &lt;&lt; type_str &lt;&lt; \" command\";\n\n    // Write cycle\n    if (__cmd.m_type == SC_CYCLE || __cmd.m_type == SC_READ || __cmd.m_type == SC_WRITE ||\n        __cmd.m_type == SC_SYNC) {\n        ss &lt;&lt; \" at \" &lt;&lt; static_cast&lt;TimeType&gt;(__cmd.m_cycle) &lt;&lt; \" cycle\";\n    }\n    // Write source address.\n    if (__cmd.m_type == SC_SEND || __cmd.m_type == SC_RECEIVE || __cmd.m_type == SC_BARRIER ||\n        __cmd.m_type == SC_LOCK || __cmd.m_type == SC_UNLOCK || __cmd.m_type == SC_LAUNCH ||\n        __cmd.m_type == SC_WAITLAUNCH || __cmd.m_type == SC_READ || __cmd.m_type == SC_WRITE) {\n        ss &lt;&lt; \" from \" &lt;&lt; DIM_X(__cmd.m_src) &lt;&lt; \",\" &lt;&lt; DIM_Y(__cmd.m_src);\n    }\n    // Write destination address.\n    if (__cmd.m_type == SC_SEND || __cmd.m_type == SC_RECEIVE || __cmd.m_type == SC_LAUNCH ||\n        __cmd.m_type == SC_WAITLAUNCH || __cmd.m_type == SC_READ || __cmd.m_type == SC_WRITE) {\n        ss &lt;&lt; \" to \" &lt;&lt; DIM_X(__cmd.m_dst) &lt;&lt; \",\" &lt;&lt; DIM_Y(__cmd.m_dst);\n    }\n    // Write target address.\n    if (__cmd.m_type == SC_BARRIER || __cmd.m_type == SC_LOCK || __cmd.m_type == SC_UNLOCK) {\n        ss &lt;&lt; \" to \" &lt;&lt; DIM_X(__cmd.m_dst);\n    }\n    // Write Result.\n    if (__cmd.m_type == SC_RESULT) {\n        ss &lt;&lt; \":\";\n        for (auto&amp; item : __cmd.m_res_list) {\n            ss &lt;&lt; \" \" &lt;&lt; item;\n        }\n    }\n    ss &lt;&lt; \".\";\n    return ss.str();\n}\n\ninline void sendCycleCmd(TimeType __cycle) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" CYCLE \" &lt;&lt; __cycle &lt;&lt; std::endl;\n}\n\ninline void sendSendCmd(int __src_x, int __src_y, int __dst_x, int __dst_y) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" SEND \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y &lt;&lt; \" \" &lt;&lt; __dst_x\n              &lt;&lt; \" \" &lt;&lt; __dst_y &lt;&lt; std::endl;\n}\n\ninline void sendReceiveCmd(int __src_x, int __src_y, int __dst_x, int __dst_y) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" RECEIVE \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y &lt;&lt; \" \"\n              &lt;&lt; __dst_x &lt;&lt; \" \" &lt;&lt; __dst_y &lt;&lt; std::endl;\n}\n\ninline void sendBarrierCmd(int __src_x, int __src_y, int __uid, int __count) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" BARRIER \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y &lt;&lt; \" \" &lt;&lt; __uid\n              &lt;&lt; \" \" &lt;&lt; __count &lt;&lt; std::endl;\n}\n\ninline void sendLockCmd(int __src_x, int __src_y, int __uid) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" LOCK \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y &lt;&lt; \" \" &lt;&lt; __uid\n              &lt;&lt; std::endl;\n}\n\ninline void sendUnlockCmd(int __src_x, int __src_y, int __uid) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" UNLOCK \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y &lt;&lt; \" \" &lt;&lt; __uid\n              &lt;&lt; std::endl;\n}\n\ninline void sendLaunchCmd(int __src_x, int __src_y, int __dst_x, int __dst_y) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" LAUNCH \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y &lt;&lt; \" \"\n              &lt;&lt; __dst_x &lt;&lt; \" \" &lt;&lt; __dst_y &lt;&lt; std::endl;\n}\n\ninline void sendWaitlaunchCmd(int __src_x, int __src_y, int __dst_x, int __dst_y) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" WAITLAUNCH \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y &lt;&lt; \" \"\n              &lt;&lt; __dst_x &lt;&lt; \" \" &lt;&lt; __dst_y &lt;&lt; std::endl;\n}\n\ninline void sendReadCmd(TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y,\n                        int __nbyte, long __desc) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" READ \" &lt;&lt; __cycle &lt;&lt; \" \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y\n              &lt;&lt; \" \" &lt;&lt; __dst_x &lt;&lt; \" \" &lt;&lt; __dst_y &lt;&lt; \" \" &lt;&lt; __nbyte &lt;&lt; \" \" &lt;&lt; __desc &lt;&lt; std::endl;\n}\n\ninline void sendWriteCmd(TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y,\n                         int __nbyte, long __desc) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" WRITE \" &lt;&lt; __cycle &lt;&lt; \" \" &lt;&lt; __src_x &lt;&lt; \" \" &lt;&lt; __src_y\n              &lt;&lt; \" \" &lt;&lt; __dst_x &lt;&lt; \" \" &lt;&lt; __dst_y &lt;&lt; \" \" &lt;&lt; __nbyte &lt;&lt; \" \" &lt;&lt; __desc &lt;&lt; std::endl;\n}\n\ninline void sendSyncCmd(TimeType __cycle) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" SYNC \" &lt;&lt; __cycle &lt;&lt; std::endl;\n}\n\ninline void sendSyncCmd(int __fd, TimeType __cycle) {\n    std::stringstream ss;\n    ss &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" SYNC \" &lt;&lt; __cycle &lt;&lt; std::endl;\n    if (write(__fd, ss.str().c_str(), ss.str().size()) &lt; 0) {\n        perror(\"write\");\n        exit(EXIT_FAILURE);\n    };\n}\n\ninline void sendResultCmd() {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" RESULT \" &lt;&lt; 0 &lt;&lt; std::endl;\n}\n\ninline void sendResultCmd(const std::vector&lt;std::string&gt;&amp; __res_list) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" RESULT \" &lt;&lt; __res_list.size();\n    for (auto&amp; item : __res_list) {\n        std::cout &lt;&lt; \" \" &lt;&lt; item;\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\ninline void sendResultCmd(const std::vector&lt;long&gt;&amp; __res_list) {\n    std::cout &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" RESULT \" &lt;&lt; __res_list.size();\n    for (auto&amp; item : __res_list) {\n        std::cout &lt;&lt; \" \" &lt;&lt; item;\n    }\n    std::cout &lt;&lt; std::endl;\n}\n\ninline void sendResultCmd(int __fd) {\n    std::stringstream ss;\n    ss &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" RESULT \" &lt;&lt; 0 &lt;&lt; std::endl;\n    if (write(__fd, ss.str().c_str(), ss.str().size()) &lt; 0) {\n        perror(\"write\");\n        exit(EXIT_FAILURE);\n    };\n}\n\ninline void sendResultCmd(int __fd, const std::vector&lt;std::string&gt;&amp; __res_list) {\n    std::stringstream ss;\n    ss &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" RESULT \" &lt;&lt; __res_list.size();\n    for (auto&amp; item : __res_list) {\n        ss &lt;&lt; \" \" &lt;&lt; item;\n    }\n    ss &lt;&lt; std::endl;\n    if (write(__fd, ss.str().c_str(), ss.str().size()) &lt; 0) {\n        perror(\"write\");\n        exit(EXIT_FAILURE);\n    };\n}\n\ninline void sendResultCmd(int __fd, const std::vector&lt;long&gt;&amp; __res_list) {\n    std::stringstream ss;\n    ss &lt;&lt; NSINTERCHIPLET_CMD_HEAD &lt;&lt; \" RESULT \" &lt;&lt; __res_list.size();\n    for (auto&amp; item : __res_list) {\n        ss &lt;&lt; \" \" &lt;&lt; item;\n    }\n    ss &lt;&lt; std::endl;\n    if (write(__fd, ss.str().c_str(), ss.str().size()) &lt; 0) {\n        perror(\"write\");\n        exit(EXIT_FAILURE);\n    };\n}\n\ninline TimeType cycleSync(TimeType __cycle) {\n    // Send CYCLE command.\n    sendCycleCmd(__cycle);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n    // Only handle SYNC message, return cycle to receive SYNC command.\n    return resp_cmd.m_type == SC_SYNC ? resp_cmd.m_cycle : -1;\n}\n\ninline std::string sendSync(int __src_x, int __src_y, int __dst_x, int __dst_y) {\n    // Send SEND command.\n    sendSendCmd(__src_x, __src_y, __dst_x, __dst_y);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n    // Return Pipe name.\n    return resp_cmd.m_res_list[0];\n}\n\ninline std::string receiveSync(int __src_x, int __src_y, int __dst_x, int __dst_y) {\n    // Send RECEIVE command.\n    sendReceiveCmd(__src_x, __src_y, __dst_x, __dst_y);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n    // Return Pipe name.\n    return resp_cmd.m_res_list[0];\n}\n\ninline void launchSync(int __src_x, int __src_y, int __dst_x, int __dst_y) {\n    // Send LAUNCH command.\n    sendLaunchCmd(__src_x, __src_y, __dst_x, __dst_y);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n\n    return;\n}\n\ninline void waitlaunchSync(int* __src_x, int* __src_y, int __dst_x, int __dst_y) {\n    // Send LAUNCH command.\n    sendWaitlaunchCmd(*__src_x, *__src_y, __dst_x, __dst_y);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n    *__src_x = atoi(resp_cmd.m_res_list[0].c_str());\n    *__src_y = atoi(resp_cmd.m_res_list[1].c_str());\n\n    return;\n}\n\ninline void barrierSync(int __src_x, int __src_y, int __uid, int __count) {\n    // Send BARRIER command.\n    sendBarrierCmd(__src_x, __src_y, __uid, __count);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n\n    return;\n}\n\ninline void lockSync(int __src_x, int __src_y, int __uid) {\n    // Send UNLOCK command.\n    sendLockCmd(__src_x, __src_y, __uid);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n\n    return;\n}\n\ninline void unlockSync(int __src_x, int __src_y, int __uid) {\n    // Send UNLOCK command.\n    sendUnlockCmd(__src_x, __src_y, __uid);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n\n    return;\n}\n\ninline TimeType readSync(TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y,\n                         int __nbyte, long __desc) {\n    // Send READ command.\n    sendReadCmd(__cycle, __src_x, __src_y, __dst_x, __dst_y, __nbyte, __desc);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n    // Only handle SYNC message, return cycle to receive SYNC command.\n    return resp_cmd.m_type == SC_SYNC ? resp_cmd.m_cycle : -1;\n}\n\ninline TimeType writeSync(TimeType __cycle, int __src_x, int __src_y, int __dst_x, int __dst_y,\n                          int __nbyte, long __desc) {\n    // Send WRITE command.\n    sendWriteCmd(__cycle, __src_x, __src_y, __dst_x, __dst_y, __nbyte, __desc);\n    // Read message from stdin.\n    SyncCommand resp_cmd = parseCmd();\n    // Only handle SYNC message, return cycle to receive SYNC command.\n    return resp_cmd.m_type == SC_SYNC ? resp_cmd.m_cycle : -1;\n}\n}  // namespace InterChiplet\n</code></pre>"},{"location":"apiProject1/dir_b94c70d771af9f161858c2c4e7b3d1c5/","title":"Dir /data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/srcs","text":"<p>FileList &gt; interchiplet &gt; srcs</p>"},{"location":"apiProject1/dir_b94c70d771af9f161858c2c4e7b3d1c5/#files","title":"Files","text":"Type Name file apis_c.cpp file cmd_handler.cpp file interchiplet.cpp <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/srcs/</code></p>"},{"location":"apiProject1/apis__c_8cpp/","title":"File apis_c.cpp","text":"<p>FileList &gt; interchiplet &gt; srcs &gt; apis_c.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"apis_c.h\"</code></li> <li><code>#include \"global_define.h\"</code></li> </ul>"},{"location":"apiProject1/apis__c_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace InterChiplet <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/srcs/apis_c.cpp</code></p>"},{"location":"apiProject1/apis__c_8cpp_source/","title":"File apis_c.cpp","text":"<p>File List &gt; interchiplet &gt; srcs &gt; apis_c.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"apis_c.h\"\n\n#include \"global_define.h\"\n\nnamespace InterChiplet {\nsyscall_return_t barrier(int64_t __uid, int64_t __src_x, int64_t __src_y, int64_t __count) {\n    int ret_code = syscall(SYSCALL_BARRIER, __uid, __src_x, __src_y, __count);\n    return ret_code;\n}\n\nsyscall_return_t lock(int64_t __uid, int64_t __src_x, int64_t __src_y) {\n    int ret_code = syscall(SYSCALL_LOCK, __uid, __src_x, __src_y);\n    return ret_code;\n}\n\nsyscall_return_t unlock(int64_t __uid, int64_t __src_x, int64_t __src_y) {\n    int ret_code = syscall(SYSCALL_UNLOCK, __uid, __src_x, __src_y);\n    return ret_code;\n}\n\nsyscall_return_t launch(int64_t __dst_x, int64_t __dst_y, int64_t __src_x,\n                                int64_t __src_y) {\n    int ret_code = syscall(SYSCALL_LAUNCH, __dst_x, __dst_y, __src_x, __src_y);\n    return ret_code;\n}\n\nsyscall_return_t waitLaunch(int64_t __dst_x, int64_t __dst_y, int64_t* __src_x,\n                              int64_t* __src_y) {\n    int ret_code = syscall(SYSCALL_WAITLAUNCH, __dst_x, __dst_y, __src_x, __src_y);\n    return ret_code;\n}\n\nsyscall_return_t sendMessage(int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y,\n                             void* __addr, int64_t __nbyte) {\n    int ret_code =\n        syscall(SYSCALL_REMOTE_WRITE, __dst_x, __dst_y, __src_x, __src_y, __addr, __nbyte);\n    return ret_code;\n}\nsyscall_return_t receiveMessage(int64_t __dst_x, int64_t __dst_y, int64_t __src_x, int64_t __src_y,\n                                void* __addr, int64_t __nbyte) {\n    int ret_code =\n        syscall(SYSCALL_REMOTE_READ, __dst_x, __dst_y, __src_x, __src_y, __addr, __nbyte);\n    return ret_code;\n}\n}  // namespace InterChiplet\n</code></pre>"},{"location":"apiProject1/cmd__handler_8cpp/","title":"File cmd_handler.cpp","text":"<p>FileList &gt; interchiplet &gt; srcs &gt; cmd_handler.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include \"cmd_handler.h\"</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include \"spdlog/spdlog.h\"</code></li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#public-functions","title":"Public Functions","text":"Type Name void handle_barrier_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle BARRIER command. void handle_barrier_write_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WRITE command with barrier flag. void handle_cycle_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle CYCLE command. void handle_launch_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle LAUNCH command. void handle_lock_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle LOCK command. void handle_lock_write_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WRITE command with LOCK flag. void handle_pipe_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle PIPE command. void handle_read_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle READ command. void handle_unlock_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle UNLOCK command. void handle_unlock_write_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WRITE command with UNLOCK flag. void handle_waitlaunch_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WAITLAUNCH command. void handle_write_cmd (const InterChiplet::SyncCommand &amp; __cmd, SyncStruct * __sync_struct) Handle WRITE command."},{"location":"apiProject1/cmd__handler_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_barrier_cmd","title":"function handle_barrier_cmd","text":"<p>Handle BARRIER command. <pre><code>void handle_barrier_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_barrier_write_cmd","title":"function handle_barrier_write_cmd","text":"<p>Handle WRITE command with barrier flag. <pre><code>void handle_barrier_write_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_cycle_cmd","title":"function handle_cycle_cmd","text":"<p>Handle CYCLE command. <pre><code>void handle_cycle_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_launch_cmd","title":"function handle_launch_cmd","text":"<p>Handle LAUNCH command. <pre><code>void handle_launch_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_lock_cmd","title":"function handle_lock_cmd","text":"<p>Handle LOCK command. <pre><code>void handle_lock_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_lock_write_cmd","title":"function handle_lock_write_cmd","text":"<p>Handle WRITE command with LOCK flag. <pre><code>void handle_lock_write_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_pipe_cmd","title":"function handle_pipe_cmd","text":"<p>Handle PIPE command. <pre><code>void handle_pipe_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_read_cmd","title":"function handle_read_cmd","text":"<p>Handle READ command. <pre><code>void handle_read_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_unlock_cmd","title":"function handle_unlock_cmd","text":"<p>Handle UNLOCK command. <pre><code>void handle_unlock_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_unlock_write_cmd","title":"function handle_unlock_write_cmd","text":"<p>Handle WRITE command with UNLOCK flag. <pre><code>void handle_unlock_write_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_waitlaunch_cmd","title":"function handle_waitlaunch_cmd","text":"<p>Handle WAITLAUNCH command. <pre><code>void handle_waitlaunch_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul>"},{"location":"apiProject1/cmd__handler_8cpp/#function-handle_write_cmd","title":"function handle_write_cmd","text":"<p>Handle WRITE command. <pre><code>void handle_write_cmd (\n    const InterChiplet::SyncCommand &amp; __cmd,\n    SyncStruct * __sync_struct\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>__cmd</code> Command to handle. </li> <li><code>__sync_struct</code> Pointer to global synchronize structure. </li> </ul> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/srcs/cmd_handler.cpp</code></p>"},{"location":"apiProject1/cmd__handler_8cpp_source/","title":"File cmd_handler.cpp","text":"<p>File List &gt; interchiplet &gt; srcs &gt; cmd_handler.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include \"cmd_handler.h\"\n\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\n#include \"spdlog/spdlog.h\"\n\nvoid handle_cycle_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    // Update global cycle.\n    __sync_struct-&gt;m_cycle_struct.update(__cmd.m_cycle);\n    spdlog::debug(\"{}\", dumpCmd(__cmd));\n}\n\nvoid handle_pipe_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    // Create Pipe file.\n    std::string file_name = InterChiplet::pipeName(__cmd.m_src, __cmd.m_dst);\n    if (access(file_name.c_str(), F_OK) == -1) {\n        // Report error if FIFO file does not exist and mkfifo error.\n        if (mkfifo(file_name.c_str(), 0664) == -1) {\n            spdlog::error(\"{} Cannot create pipe file {}.\", dumpCmd(__cmd), file_name);\n        }\n        // Report success.\n        else {\n            // Register file name in pipe set.\n            __sync_struct-&gt;m_pipe_struct.insert(file_name);\n            spdlog::debug(\"{} Create pipe file {}.\", dumpCmd(__cmd), file_name);\n        }\n    }\n    // Reuse exist FIFO and reports.\n    else {\n        spdlog::debug(\"{} Reuse exist pipe file {}.\", dumpCmd(__cmd), file_name);\n    }\n\n    // Send RESULT command.\n    std::string resp_file_name = \"../\" + file_name;\n    InterChiplet::sendResultCmd(__cmd.m_stdin_fd, {resp_file_name});\n}\n\nvoid handle_barrier_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    int uid = DIM_X(__cmd.m_dst);\n    int count = __cmd.m_nbytes;\n\n    // Register BARRIER command.\n    __sync_struct-&gt;m_barrier_struct.insertBarrier(uid, count, __cmd);\n    // Barrier override.\n    if (__sync_struct-&gt;m_barrier_struct.overflow(uid)) {\n        // Send RESULT command to each barrier.\n        for (auto&amp; item : __sync_struct-&gt;m_barrier_struct.barrierCmd(uid)) {\n            InterChiplet::sendResultCmd(item.m_stdin_fd);\n        }\n        __sync_struct-&gt;m_barrier_struct.reset(uid);\n        spdlog::debug(\"{} Register BARRIER command. Barrier overflow.\", dumpCmd(__cmd));\n    }\n    // Wait further barrier commands.\n    else {\n        spdlog::debug(\"{} Register BARRIER command.\", dumpCmd(__cmd));\n    }\n}\n\nvoid handle_lock_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    // Get mutex ID.\n    int uid = DIM_X(__cmd.m_dst);\n\n    if (__sync_struct-&gt;m_lock_struct.isLocked(uid)) {\n        // If the mutex is locked, check whether the LOCK command comes from the same source.\n        if (__sync_struct-&gt;m_lock_struct.hasLastCmd(uid) &amp;&amp;\n            (__sync_struct-&gt;m_lock_struct.getLastCmd(uid).m_src == __cmd.m_src)) {\n            // If the LOCK command comes from the same source, ignore the LOCK command.\n            spdlog::debug(\"{} Mutex {} has been locked by the same source. Do nothing.\",\n                          dumpCmd(__cmd), uid);\n            // Send RESULT command to response UNLOCK command.\n            InterChiplet::sendResultCmd(__cmd.m_stdin_fd);\n        } else {\n            // Otherwise, pending the LOCK command until the mutex is unlocked.\n            __sync_struct-&gt;m_lock_struct.insertLockCmd(uid, __cmd);\n            spdlog::debug(\"{} Register LOCK command to wait UNLOCK command.\", dumpCmd(__cmd));\n        }\n    } else {\n        // If the mutex is not locked, whether this LOCK command can be response dependes on the\n        // order determined by the delay information.\n        if (__sync_struct-&gt;m_delay_list.hasLock(__cmd.m_dst)) {\n            // If the order of the mutex is determined by the delay information, check whether\n            // the source address of this LOCK command matches the order determined by the delay\n            // information.\n            if (__sync_struct-&gt;m_delay_list.frontLockSrc(__cmd.m_dst) == __cmd.m_src) {\n                // If the source address of this LOCK command matches the order determined by the\n                // delay information, lock the mutex.\n                __sync_struct-&gt;m_lock_struct.lock(uid, __cmd);\n                spdlog::debug(\"{} Lock mutex {}.\", dumpCmd(__cmd), uid);\n                // Send RESULT command to response the LOCK command.\n                InterChiplet::sendResultCmd(__cmd.m_stdin_fd);\n                // Pop one item from delay information.\n                __sync_struct-&gt;m_delay_list.popLock(__cmd.m_dst);\n            } else {\n                // If the source address of this LOCK command does not match the order determined\n                // by the delay informtion, pending this LOCK command until the correct order.\n                __sync_struct-&gt;m_lock_struct.insertLockCmd(uid, __cmd);\n                spdlog::debug(\"{} Register LOCK command to wait correct order.\", dumpCmd(__cmd));\n            }\n        } else {\n            // If the order of the mutex is not determined by the delay information, lock the mutex.\n            __sync_struct-&gt;m_lock_struct.lock(uid, __cmd);\n            spdlog::debug(\"{} Lock mutex {}.\", dumpCmd(__cmd), uid);\n            // Send RESULT command to response the LOCK command.\n            InterChiplet::sendResultCmd(__cmd.m_stdin_fd);\n        }\n    }\n}\n\nvoid handle_unlock_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    // Get mutex ID.\n    int uid = DIM_X(__cmd.m_dst);\n\n    if (__sync_struct-&gt;m_lock_struct.isLocked(uid)) {\n        // If the mutex is locked, unlock the mutex first.\n        __sync_struct-&gt;m_lock_struct.unlock(uid, __cmd);\n        spdlog::debug(\"{} Unlock mutex {}.\", dumpCmd(__cmd), uid);\n        // Send RESULT command to response UNLOCK command.\n        InterChiplet::sendResultCmd(__cmd.m_stdin_fd);\n\n        // Lock the mutex by pending LOCK command.\n        if (__sync_struct-&gt;m_delay_list.hasLock(__cmd.m_dst)) {\n            // If the order of the mutex is determined by the delay information, check whether\n            // there is any pending LOCK command matching the order determined by the delay\n            // information.\n            InterChiplet::AddrType order_src =\n                __sync_struct-&gt;m_delay_list.frontLockSrc(__cmd.m_dst);\n            if (__sync_struct-&gt;m_lock_struct.hasLockCmd(uid, order_src)) {\n                // If there is one pending LOCK command matching the order determined by the delay\n                // information. Lock the mutex by this pending LOCK command.\n                InterChiplet::SyncCommand lock_cmd =\n                    __sync_struct-&gt;m_lock_struct.popLockCmd(uid, order_src);\n                __sync_struct-&gt;m_lock_struct.lock(uid, lock_cmd);\n                spdlog::debug(\"\\t{} Lock mutex {}.\", dumpCmd(lock_cmd), uid);\n                // Send RESULT command to response the pending LOCK command.\n                InterChiplet::sendResultCmd(lock_cmd.m_stdin_fd);\n                // Pop one item from the delay information.\n                __sync_struct-&gt;m_delay_list.popLock(__cmd.m_dst);\n            }\n        } else {\n            // If the order of the mutex is not determined by the delay information, check whether\n            // there is any pending LOCK command.\n            if (__sync_struct-&gt;m_lock_struct.hasLockCmd(uid)) {\n                // If there is any pending LOCK command, lock the mutex by the first pending LOCK\n                // command.\n                InterChiplet::SyncCommand lock_cmd = __sync_struct-&gt;m_lock_struct.popLockCmd(uid);\n                __sync_struct-&gt;m_lock_struct.lock(uid, lock_cmd);\n                spdlog::debug(\"\\t{} Lock mutex {}.\", dumpCmd(lock_cmd), uid);\n                // Send RESULT command to response the pending LOCK command.\n                InterChiplet::sendResultCmd(lock_cmd.m_stdin_fd);\n            }\n        }\n    } else {\n        // If the mutex is unlocked, ignore the UNLOCK command.\n        spdlog::debug(\"{} Mutex {} has not locked. Do nothing.\", dumpCmd(__cmd), uid);\n        // Send RESULT command to response UNLOCK command.\n        InterChiplet::sendResultCmd(__cmd.m_stdin_fd);\n    }\n}\n\nvoid handle_launch_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    // Check launch order and remove item.\n    if (__sync_struct-&gt;m_delay_list.hasLaunch(__cmd.m_dst)) {\n        if (__sync_struct-&gt;m_delay_list.frontLaunchSrc(__cmd.m_dst) != __cmd.m_src) {\n            __sync_struct-&gt;m_launch_struct.insertLaunch(__cmd);\n            spdlog::debug(\"{} Register LAUNCH command to pair with WAITLAUNCH command.\",\n                          dumpCmd(__cmd));\n            return;\n        }\n    }\n\n    // Check for unconfirmed waitlaunch command.\n    bool has_waitlaunch_cmd = __sync_struct-&gt;m_launch_struct.hasMatchWaitlaunch(__cmd);\n    InterChiplet::SyncCommand waitlaunch_cmd =\n        __sync_struct-&gt;m_launch_struct.popMatchWaitlaunch(__cmd);\n\n    // If there is not waitlaunch command, waitlaunch command.\n    if (!has_waitlaunch_cmd) {\n        __sync_struct-&gt;m_launch_struct.insertLaunch(__cmd);\n        spdlog::debug(\"{} Register LAUNCH command to pair with WAITLAUNCH command.\",\n                      dumpCmd(__cmd));\n    }\n    // If there is waitlaunch command, response launch and waitlaunch command.\n    else {\n        __sync_struct-&gt;m_delay_list.popLaunch(__cmd.m_dst);\n        spdlog::debug(\"{} Pair with WAITLAUNCH command.\", dumpCmd(__cmd));\n        // Send SYNC to response LAUNCH command.\n        InterChiplet::sendResultCmd(__cmd.m_stdin_fd);\n        // Send LAUNCH to response WAITLAUNCH command.\n        InterChiplet::sendResultCmd(waitlaunch_cmd.m_stdin_fd,\n                                    {DIM_X(__cmd.m_src), DIM_Y(__cmd.m_src)});\n    }\n}\n\nvoid handle_waitlaunch_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    InterChiplet::SyncCommand cmd = __cmd;\n\n    // Check launch order and remove item.\n    if (__sync_struct-&gt;m_delay_list.hasLaunch(cmd.m_dst)) {\n        cmd.m_src = __sync_struct-&gt;m_delay_list.frontLaunchSrc(cmd.m_dst);\n    }\n\n    // Check for unconfirmed waitlaunch command.\n    bool has_launch_cmd = __sync_struct-&gt;m_launch_struct.hasMatchLaunch(cmd);\n    InterChiplet::SyncCommand launch_cmd = __sync_struct-&gt;m_launch_struct.popMatchLaunch(cmd);\n\n    // If there is not waitlaunch command, waitlaunch command.\n    if (!has_launch_cmd) {\n        __sync_struct-&gt;m_launch_struct.insertWaitlaunch(__cmd);\n        spdlog::debug(\"{} Register WAITLAUNCH command to pair with LAUNCH command.\", dumpCmd(cmd));\n    } else {\n        __sync_struct-&gt;m_delay_list.popLaunch(cmd.m_dst);\n        spdlog::debug(\"{} Pair with LAUNCH command from {},{} to {},{}.\", dumpCmd(cmd),\n                      DIM_X(launch_cmd.m_src), DIM_Y(launch_cmd.m_src), DIM_X(launch_cmd.m_dst),\n                      DIM_Y(launch_cmd.m_dst));\n        // Send RESULT to response LAUNCH command.\n        InterChiplet::sendResultCmd(launch_cmd.m_stdin_fd);\n        // Send RESULT to response WAITLAUNCH command.\n        InterChiplet::sendResultCmd(cmd.m_stdin_fd,\n                                    {DIM_X(launch_cmd.m_src), DIM_Y(launch_cmd.m_src)});\n    }\n}\n\nvoid handle_read_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    // Check for paired write command.\n    bool has_write_cmd = __sync_struct-&gt;m_comm_struct.hasMatchWrite(__cmd);\n    InterChiplet::SyncCommand write_cmd = __sync_struct-&gt;m_comm_struct.popMatchWrite(__cmd);\n\n    if (!has_write_cmd) {\n        // If there is no paired write command, add this command to read command queue to wait.\n        __sync_struct-&gt;m_comm_struct.insertRead(__cmd);\n        spdlog::debug(\"{} Register READ command to pair with WRITE command.\", dumpCmd(__cmd));\n    } else {\n        // Insert event to benchmark list.\n        NetworkBenchItem bench_item(write_cmd, __cmd);\n        __sync_struct-&gt;m_bench_list.insert(bench_item);\n\n        // If there is a paired write command, get the end cycle of transaction.\n        CmdDelayPair end_cycle = __sync_struct-&gt;m_delay_list.getEndCycle(write_cmd, __cmd);\n        spdlog::debug(\"{} Pair with WRITE command. Transation ends at [{},{}] cycle.\",\n                      dumpCmd(__cmd), static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle)),\n                      static_cast&lt;InterChiplet::TimeType&gt;(DST_DELAY(end_cycle)));\n        // Send synchronize command to response READ command.\n        InterChiplet::sendSyncCmd(__cmd.m_stdin_fd, static_cast&lt;InterChiplet::TimeType&gt;(\n                                                        DST_DELAY(end_cycle) * __cmd.m_clock_rate));\n        // Send synchronize command to response WRITE command.\n        InterChiplet::sendSyncCmd(\n            write_cmd.m_stdin_fd,\n            static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle) * write_cmd.m_clock_rate));\n    }\n}\n\nvoid handle_barrier_write_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    int uid = DIM_X(__cmd.m_dst);\n    int count = __cmd.m_desc &amp; 0xFFFF;\n\n    // Insert event to benchmark list.\n    NetworkBenchItem bench_item(__cmd);\n    __sync_struct-&gt;m_bench_list.insert(bench_item);\n\n    // Register BARRIER command.\n    __sync_struct-&gt;m_barrier_timing_struct.insertBarrier(uid, count, __cmd);\n    // Barrier override.\n    if (__sync_struct-&gt;m_barrier_timing_struct.overflow(uid)) {\n        // Get barrier overflow time.\n        InterChiplet::InnerTimeType barrier_cycle = __sync_struct-&gt;m_delay_list.getBarrierCycle(\n            __sync_struct-&gt;m_barrier_timing_struct.barrierCmd(uid));\n        spdlog::debug(\"{} Barrier overflow at {} cycle.\", dumpCmd(__cmd),\n                      static_cast&lt;InterChiplet::TimeType&gt;(barrier_cycle));\n\n        // Generate a command as read command.\n        InterChiplet::SyncCommand sync_cmd = __cmd;\n        sync_cmd.m_cycle = barrier_cycle;\n\n        // Send synchronization command to all barrier items.\n        for (auto&amp; item : __sync_struct-&gt;m_barrier_timing_struct.barrierCmd(uid)) {\n            CmdDelayPair end_cycle = __sync_struct-&gt;m_delay_list.getEndCycle(item, sync_cmd);\n            spdlog::debug(\"\\t{} Transaction ends at {} cycle.\", dumpCmd(item),\n                          static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle)));\n            // Send synchronization comand to response WRITE command.\n            InterChiplet::sendSyncCmd(\n                item.m_stdin_fd,\n                static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle) * item.m_clock_rate));\n        }\n        __sync_struct-&gt;m_barrier_timing_struct.reset(uid);\n    }\n    // Wait further barrier commands.\n    else {\n        spdlog::debug(\"{} Register WRITE command with BARRIER flag.\", dumpCmd(__cmd));\n    }\n}\n\nvoid handle_lock_write_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    // Get mutex ID.\n    int uid = DIM_X(__cmd.m_dst);\n\n    // Insert event to benchmark list.\n    NetworkBenchItem bench_item(__cmd);\n    __sync_struct-&gt;m_bench_list.insert(bench_item);\n\n    if (__sync_struct-&gt;m_lock_timing_struct.isLocked(uid)) {\n        // If the mutex is locked, check whether the WRITE(LOCK) command comes from the same source.\n        if (__sync_struct-&gt;m_lock_timing_struct.hasLastCmd(uid) &amp;&amp;\n            (__sync_struct-&gt;m_lock_timing_struct.getLastCmd(uid).m_src == __cmd.m_src)) {\n            // If the WRITE(LOCK) command comes from the same source, ignore the LOCK command.\n            // Response this WRITE(LOCK) command immediately when it is received by destination.\n            CmdDelayPair end_cycle = __sync_struct-&gt;m_delay_list.getEndCycle(__cmd, __cmd);\n            spdlog::debug(\"{} Transaction ends at {} cycle.\", dumpCmd(__cmd),\n                          static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle)));\n            // Send SYNC comand with end cycle to response WRITE command.\n            InterChiplet::sendSyncCmd(\n                __cmd.m_stdin_fd,\n                static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle) * __cmd.m_clock_rate));\n        } else {\n            // Otherwise, pending the LOCK command until the mutex is unlocked.\n            __sync_struct-&gt;m_lock_timing_struct.insertLockCmd(uid, __cmd);\n            spdlog::debug(\"{} Register WRITE command with LOCK flag.\", dumpCmd(__cmd));\n        }\n    } else {\n        // The order of mutex is handled by LOCK/UNLOCK command. WRITE(LOCK) command can lock the\n        // mutex directly.\n\n        // Get the last command. If there is no last command, use this WRITE(LOCK) command as the\n        // last command.\n        InterChiplet::SyncCommand last_cmd = __cmd;\n        if (__sync_struct-&gt;m_lock_timing_struct.hasLastCmd(uid)) {\n            last_cmd = __sync_struct-&gt;m_lock_timing_struct.getLastCmd(uid);\n        }\n        // Response this WRITE(LOCK) command after it is received by the destination and the\n        // destination finished the last command.\n        CmdDelayPair end_cycle = __sync_struct-&gt;m_delay_list.getEndCycle(__cmd, last_cmd);\n\n        // Calculate the end cycle of mutex.\n        InterChiplet::SyncCommand sync_cmd = __cmd;\n        sync_cmd.m_cycle = DST_DELAY(end_cycle);\n\n        // Lock the mutex\n        __sync_struct-&gt;m_lock_timing_struct.lock(uid, sync_cmd);\n        spdlog::debug(\"{} Transaction ends at {} cycle.\", dumpCmd(__cmd),\n                      static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle)));\n        // Send SYNC comand with end cycle to response WRITE command.\n        InterChiplet::sendSyncCmd(__cmd.m_stdin_fd, static_cast&lt;InterChiplet::TimeType&gt;(\n                                                        SRC_DELAY(end_cycle) * __cmd.m_clock_rate));\n    }\n}\n\nvoid handle_unlock_write_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    // Get mutex ID.\n    int uid = DIM_X(__cmd.m_dst);\n\n    // Insert event to benchmark list.\n    NetworkBenchItem bench_item(__cmd);\n    __sync_struct-&gt;m_bench_list.insert(bench_item);\n\n    if (__sync_struct-&gt;m_lock_timing_struct.isLocked(uid)) {\n        // If the mutex is locked, unlock the mutex first.\n\n        // Get the last command. If there is no last command, use this WRITE(UNLOCK) command as the\n        // last command.\n        InterChiplet::SyncCommand last_cmd = __cmd;\n        if (__sync_struct-&gt;m_lock_timing_struct.hasLastCmd(uid)) {\n            last_cmd = __sync_struct-&gt;m_lock_timing_struct.getLastCmd(uid);\n        }\n        // Response this WRITE(UNLOCK) command after it is received by the destination and the\n        // destination finished the last command.\n        CmdDelayPair end_cycle = __sync_struct-&gt;m_delay_list.getEndCycle(__cmd, last_cmd);\n\n        // Calculate the end cycle of mutex.\n        InterChiplet::SyncCommand sync_cmd = __cmd;\n        sync_cmd.m_cycle = DST_DELAY(end_cycle);\n\n        // unlock the mutex.\n        __sync_struct-&gt;m_lock_timing_struct.unlock(uid, sync_cmd);\n        spdlog::debug(\"{} Transaction ends at {} cycle.\", dumpCmd(__cmd),\n                      static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle)));\n        // Send SYNC comand with end cycle to response WRITE command.\n        InterChiplet::sendSyncCmd(__cmd.m_stdin_fd, static_cast&lt;InterChiplet::TimeType&gt;(\n                                                        SRC_DELAY(end_cycle) * __cmd.m_clock_rate));\n\n        // Lock the mutex by pending LOCK command.\n        // The order of the mutex is handled by LOCK/UNLOCK commands. WRITE(UNLOCK) only need to\n        // handle the reorder of one UNLOCK command with pending LOCK commands.\n        // Check whether there is any pending LOCK command.\n        if (__sync_struct-&gt;m_lock_timing_struct.hasLockCmd(uid)) {\n            // If there is any pending LOCK command, lock the mutex by the first pending LOCK\n            // command.\n            InterChiplet::SyncCommand lock_cmd =\n                __sync_struct-&gt;m_lock_timing_struct.popLockCmd(uid);\n            // Response this WRITE(LOCK) command after it is received by the destination and the\n            // destination finished the WRITE(UNLOCK) command.\n            CmdDelayPair end_cycle = __sync_struct-&gt;m_delay_list.getEndCycle(lock_cmd, sync_cmd);\n\n            // Calculate the end cycle of mutex.\n            InterChiplet::SyncCommand sync_cmd = lock_cmd;\n            sync_cmd.m_cycle = DST_DELAY(end_cycle);\n\n            // lock the mutex.\n            __sync_struct-&gt;m_lock_timing_struct.lock(uid, sync_cmd);\n            spdlog::debug(\"\\t{} Transaction ends at {} cycle.\", dumpCmd(lock_cmd),\n                          static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle)));\n            // Send SYNC comand with end cycle to response pending LOCK command.\n            InterChiplet::sendSyncCmd(\n                lock_cmd.m_stdin_fd,\n                static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle) * lock_cmd.m_clock_rate));\n        }\n    } else {\n        // If the mutex is unlocked, ignore the UNLOCK command.\n        // Response this WRITE(UNLOCK) command immediately when it is received by destination.\n        CmdDelayPair end_cycle = __sync_struct-&gt;m_delay_list.getEndCycle(__cmd, __cmd);\n        spdlog::debug(\"{} Transaction ends at {} cycle.\", dumpCmd(__cmd),\n                      static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle)));\n        // Send SYNC comand with end cycle to response WRITE command.\n        InterChiplet::sendSyncCmd(__cmd.m_stdin_fd, static_cast&lt;InterChiplet::TimeType&gt;(\n                                                        SRC_DELAY(end_cycle) * __cmd.m_clock_rate));\n    }\n}\n\nvoid handle_write_cmd(const InterChiplet::SyncCommand&amp; __cmd, SyncStruct* __sync_struct) {\n    if (__cmd.m_desc &amp; InterChiplet::SPD_BARRIER) {\n        // Special handle WRITE cmmand after BARRIER. WRITE(BARRIER)\n        return handle_barrier_write_cmd(__cmd, __sync_struct);\n    } else if (__cmd.m_desc &amp; InterChiplet::SPD_LOCK) {\n        // Special handle WRITE cmmand after LOCK. WRITE(LOCK)\n        return handle_lock_write_cmd(__cmd, __sync_struct);\n    } else if (__cmd.m_desc &amp; InterChiplet::SPD_UNLOCK) {\n        // Special handle WRITE cmmand after UNLOCK. WRITE(UNLOCK)\n        return handle_unlock_write_cmd(__cmd, __sync_struct);\n    }\n\n    // Check for paired read command.\n    bool has_read_cmd = __sync_struct-&gt;m_comm_struct.hasMatchRead(__cmd);\n    InterChiplet::SyncCommand read_cmd = __sync_struct-&gt;m_comm_struct.popMatchRead(__cmd);\n\n    if (!has_read_cmd) {\n        // If there is no paired read command, add this command to write command queue to wait.\n        __sync_struct-&gt;m_comm_struct.insertWrite(__cmd);\n        spdlog::debug(\"{} Register WRITE command to pair with READ command.\", dumpCmd(__cmd));\n    } else {\n        // Insert event to benchmark list.\n        NetworkBenchItem bench_item(__cmd, read_cmd);\n        __sync_struct-&gt;m_bench_list.insert(bench_item);\n\n        // If there is a paired read command, get the end cycle of transaction.\n        CmdDelayPair end_cycle = __sync_struct-&gt;m_delay_list.getEndCycle(__cmd, read_cmd);\n        spdlog::debug(\"{} Pair with READ command. Transation ends at [{},{}] cycle.\",\n                      dumpCmd(__cmd), static_cast&lt;InterChiplet::TimeType&gt;(SRC_DELAY(end_cycle)),\n                      static_cast&lt;InterChiplet::TimeType&gt;(DST_DELAY(end_cycle)));\n\n        // Send synchronize command to response WRITE command.\n        InterChiplet::sendSyncCmd(__cmd.m_stdin_fd, static_cast&lt;InterChiplet::TimeType&gt;(\n                                                        SRC_DELAY(end_cycle) * __cmd.m_clock_rate));\n        // Send synchronize command to response READ command.\n        InterChiplet::sendSyncCmd(\n            read_cmd.m_stdin_fd,\n            static_cast&lt;InterChiplet::TimeType&gt;(DST_DELAY(end_cycle) * read_cmd.m_clock_rate));\n    }\n}\n</code></pre>"},{"location":"apiProject1/interchiplet_8cpp/","title":"File interchiplet.cpp","text":"<p>FileList &gt; interchiplet &gt; srcs &gt; interchiplet.cpp</p> <p>Go to the source code of this file.</p> <ul> <li><code>#include &lt;fcntl.h&gt;</code></li> <li><code>#include &lt;poll.h&gt;</code></li> <li><code>#include &lt;sys/stat.h&gt;</code></li> <li><code>#include &lt;sys/time.h&gt;</code></li> <li><code>#include &lt;sys/types.h&gt;</code></li> <li><code>#include &lt;sys/wait.h&gt;</code></li> <li><code>#include &lt;ctime&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"benchmark_yaml.h\"</code></li> <li><code>#include \"cmd_handler.h\"</code></li> <li><code>#include \"cmdline_options.h\"</code></li> <li><code>#include \"spdlog/spdlog.h\"</code></li> </ul>"},{"location":"apiProject1/interchiplet_8cpp/#classes","title":"Classes","text":"Type Name class ProcessStruct Data structure of process configuration."},{"location":"apiProject1/interchiplet_8cpp/#public-functions","title":"Public Functions","text":"Type Name InterChiplet::InnerTimeType __loop_phase_one (int __round, const std::vector&lt; ProcessConfig &gt; &amp; __proc_phase1_cfg_list, const std::vector&lt; ProcessConfig &gt; &amp; __proc_phase2_cfg_list)  void __loop_phase_two (int __round, const std::vector&lt; ProcessConfig &gt; &amp; __proc_cfg_list)  void * bridge_thread (void * __args_ptr)  int main (int argc, const char * argv)  void parse_command (char * __pipe_buf, ProcessStruct * __proc_struct, int __stdin_fd)"},{"location":"apiProject1/interchiplet_8cpp/#macros","title":"Macros","text":"Type Name define PIPE_BUF_SIZE  1024"},{"location":"apiProject1/interchiplet_8cpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"apiProject1/interchiplet_8cpp/#function-__loop_phase_one","title":"function __loop_phase_one","text":"<pre><code>InterChiplet::InnerTimeType __loop_phase_one (\n    int __round,\n    const std::vector&lt; ProcessConfig &gt; &amp; __proc_phase1_cfg_list,\n    const std::vector&lt; ProcessConfig &gt; &amp; __proc_phase2_cfg_list\n) \n</code></pre>"},{"location":"apiProject1/interchiplet_8cpp/#function-__loop_phase_two","title":"function __loop_phase_two","text":"<pre><code>void __loop_phase_two (\n    int __round,\n    const std::vector&lt; ProcessConfig &gt; &amp; __proc_cfg_list\n) \n</code></pre>"},{"location":"apiProject1/interchiplet_8cpp/#function-bridge_thread","title":"function bridge_thread","text":"<pre><code>void * bridge_thread (\n    void * __args_ptr\n) \n</code></pre>"},{"location":"apiProject1/interchiplet_8cpp/#function-main","title":"function main","text":"<pre><code>int main (\n    int argc,\n    const char * argv\n) \n</code></pre>"},{"location":"apiProject1/interchiplet_8cpp/#function-parse_command","title":"function parse_command","text":"<pre><code>void parse_command (\n    char * __pipe_buf,\n    ProcessStruct * __proc_struct,\n    int __stdin_fd\n) \n</code></pre>"},{"location":"apiProject1/interchiplet_8cpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"apiProject1/interchiplet_8cpp/#define-pipe_buf_size","title":"define PIPE_BUF_SIZE","text":"<pre><code>#define PIPE_BUF_SIZE 1024\n</code></pre> <p>The documentation for this class was generated from the following file <code>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/srcs/interchiplet.cpp</code></p>"},{"location":"apiProject1/interchiplet_8cpp_source/","title":"File interchiplet.cpp","text":"<p>File List &gt; interchiplet &gt; srcs &gt; interchiplet.cpp</p> <p>Go to the documentation of this file. </p> <pre><code>#include &lt;fcntl.h&gt;\n#include &lt;poll.h&gt;\n#include &lt;sys/stat.h&gt;\n#include &lt;sys/time.h&gt;\n#include &lt;sys/types.h&gt;\n#include &lt;sys/wait.h&gt;\n\n#include &lt;ctime&gt;\n#include &lt;vector&gt;\n\n#include \"benchmark_yaml.h\"\n#include \"cmd_handler.h\"\n#include \"cmdline_options.h\"\n#include \"spdlog/spdlog.h\"\n\nclass ProcessStruct {\n   public:\n    ProcessStruct(const ProcessConfig&amp; __config)\n        : m_command(__config.m_command),\n          m_args(__config.m_args),\n          m_log_file(__config.m_log_file),\n          m_to_stdout(__config.m_to_stdout),\n          m_clock_rate(__config.m_clock_rate),\n          m_pre_copy(__config.m_pre_copy),\n          m_unfinished_line(),\n          m_thread_id(),\n          m_pid(-1),\n          m_pid2(-1),\n          m_sync_struct(NULL) {}\n\n   public:\n    // Configuration.\n    std::string m_command;\n    std::vector&lt;std::string&gt; m_args;\n    std::string m_log_file;\n    bool m_to_stdout;\n    double m_clock_rate;\n    std::string m_pre_copy;\n\n    std::string m_unfinished_line;\n\n    // Indentify\n    int m_round;\n    int m_phase;\n    int m_thread;\n\n    pthread_t m_thread_id;\n    int m_pid;\n    int m_pid2;\n\n    SyncStruct* m_sync_struct;\n};\n\nvoid parse_command(char* __pipe_buf, ProcessStruct* __proc_struct, int __stdin_fd) {\n    // Split line by '\\n'\n    std::string line = std::string(__pipe_buf);\n    std::vector&lt;std::string&gt; lines;\n\n    int start_idx = 0;\n    for (std::size_t i = 0; i &lt; line.size(); i++) {\n        if (line[i] == '\\n') {\n            std::string l = line.substr(start_idx, i + 1 - start_idx);\n            start_idx = i + 1;\n            lines.push_back(l);\n        }\n    }\n    if (start_idx &lt; line.size()) {\n        std::string l = line.substr(start_idx, line.size() - start_idx);\n        lines.push_back(l);\n    }\n\n    // Unfinished line.\n    if (__proc_struct-&gt;m_unfinished_line.size() &gt; 0) {\n        lines[0] = __proc_struct-&gt;m_unfinished_line + lines[0];\n        __proc_struct-&gt;m_unfinished_line = \"\";\n    }\n    if (lines[lines.size() - 1].find('\\n') == -1) {\n        __proc_struct-&gt;m_unfinished_line = lines[lines.size() - 1];\n        lines.pop_back();\n    }\n\n    // Get line start with [INTERCMD]\n    for (std::size_t i = 0; i &lt; lines.size(); i++) {\n        std::string l = lines[i];\n        if (l.substr(0, 10) == \"[INTERCMD]\") {\n            InterChiplet::SyncCommand cmd = InterChiplet::parseCmd(l);\n            cmd.m_stdin_fd = __stdin_fd;\n            cmd.m_clock_rate = __proc_struct-&gt;m_clock_rate;\n            cmd.m_cycle = cmd.m_cycle / __proc_struct-&gt;m_clock_rate;\n\n            pthread_mutex_lock(&amp;__proc_struct-&gt;m_sync_struct-&gt;m_mutex);\n\n            // Check order and clear delay infomation.\n            if (cmd.m_type == InterChiplet::SC_BARRIER || cmd.m_type == InterChiplet::SC_SEND ||\n                cmd.m_type == InterChiplet::SC_LOCK || cmd.m_type == InterChiplet::SC_UNLOCK ||\n                cmd.m_type == InterChiplet::SC_LAUNCH) {\n                InterChiplet::SyncCommand write_cmd = cmd;\n                if (cmd.m_type == InterChiplet::SC_BARRIER) {\n                    write_cmd.m_desc |= InterChiplet::SPD_BARRIER;\n                    write_cmd.m_desc |= write_cmd.m_nbytes;\n                } else if (cmd.m_type == InterChiplet::SC_LOCK) {\n                    write_cmd.m_desc |= InterChiplet::SPD_LOCK;\n                } else if (cmd.m_type == InterChiplet::SC_UNLOCK) {\n                    write_cmd.m_desc |= InterChiplet::SPD_UNLOCK;\n                } else if (cmd.m_type == InterChiplet::SC_LAUNCH) {\n                    write_cmd.m_desc |= InterChiplet::SPD_LAUNCH;\n                }\n                if (!__proc_struct-&gt;m_sync_struct-&gt;m_delay_list.checkOrderOfCommand(write_cmd)) {\n                    spdlog::warn(\"Command order has changed. Delay information is canncelled.\");\n                    __proc_struct-&gt;m_sync_struct-&gt;m_delay_list.clearDelayInfo();\n                }\n            }\n\n            // Call functions to handle corresponding command.\n            switch (cmd.m_type) {\n                case InterChiplet::SC_CYCLE:\n                    handle_cycle_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                case InterChiplet::SC_BARRIER:\n                    handle_barrier_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                case InterChiplet::SC_SEND:\n                case InterChiplet::SC_RECEIVE:\n                    handle_pipe_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                case InterChiplet::SC_LOCK:\n                    handle_lock_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                case InterChiplet::SC_UNLOCK:\n                    handle_unlock_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                case InterChiplet::SC_LAUNCH:\n                    handle_launch_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                case InterChiplet::SC_WAITLAUNCH:\n                    handle_waitlaunch_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                case InterChiplet::SC_READ:\n                    handle_read_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                case InterChiplet::SC_WRITE:\n                    handle_write_cmd(cmd, __proc_struct-&gt;m_sync_struct);\n                    break;\n                default:\n                    break;\n            }\n\n            pthread_mutex_unlock(&amp;__proc_struct-&gt;m_sync_struct-&gt;m_mutex);\n        }\n    }\n}\n\n#define PIPE_BUF_SIZE 1024\n\nvoid* bridge_thread(void* __args_ptr) {\n    ProcessStruct* proc_struct = (ProcessStruct*)__args_ptr;\n\n    int pipe_stdin[2];   // Pipe to send data to child process\n    int pipe_stdout[2];  // Pipe to receive data from child process\n    int pipe_stderr[2];  // Pipe to receive data from child process\n\n    // Create pipes\n    if (pipe(pipe_stdin) == -1 || pipe(pipe_stdout) == -1 || pipe(pipe_stderr) == -1) {\n        perror(\"pipe\");\n        exit(EXIT_FAILURE);\n    }\n\n    // Create sub directory for subprocess.\n    char* sub_dir_path = new char[128];\n    sprintf(sub_dir_path, \"./proc_r%d_p%d_t%d\", proc_struct-&gt;m_round, proc_struct-&gt;m_phase,\n            proc_struct-&gt;m_thread);\n    if (access(sub_dir_path, F_OK) == -1) {\n        mkdir(sub_dir_path, 0775);\n    }\n\n    // Fork a child process\n    pid_t pid = fork();\n    if (pid == -1) {\n        perror(\"fork\");\n        exit(EXIT_FAILURE);\n    }\n\n    if (pid == 0) {  // Child process\n        // Close unnecessary pipe ends\n        close(pipe_stdin[1]);\n        close(pipe_stdout[0]);\n        close(pipe_stderr[0]);\n\n        // Redirect stdin and stdout to pipes\n        dup2(pipe_stdin[0], STDIN_FILENO);\n        dup2(pipe_stdout[1], STDOUT_FILENO);\n        dup2(pipe_stderr[1], STDERR_FILENO);\n\n        // Change directory to sub-process.\n        if (chdir(sub_dir_path) &lt; 0) {\n            perror(\"chdir\");\n        }\n        // TODO: Copy necessary configuration file.\n        if (!proc_struct-&gt;m_pre_copy.empty()) {\n            std::string cp_cmd = std::string(\"cp \") + proc_struct-&gt;m_pre_copy + \" .\";\n            if (system(cp_cmd.c_str()) != 0) {\n                perror(\"system\");\n            }\n        }\n\n        std::cout &lt;&lt; \"CWD: \" &lt;&lt; get_current_dir_name() &lt;&lt; std::endl;\n\n        // Build arguments.\n        int argc = proc_struct-&gt;m_args.size();\n        char** args_list = new char*[argc + 2];\n        args_list[0] = new char[proc_struct-&gt;m_command.size() + 1];\n        strcpy(args_list[0], proc_struct-&gt;m_command.c_str());\n        args_list[0][proc_struct-&gt;m_command.size()] = '\\0';\n        for (int i = 0; i &lt; argc; i++) {\n            int arg_len = proc_struct-&gt;m_args[i].size();\n            args_list[i + 1] = new char[arg_len + 1];\n            strcpy(args_list[i + 1], proc_struct-&gt;m_args[i].c_str());\n            args_list[i + 1][arg_len] = '\\0';\n        }\n        args_list[argc + 1] = NULL;\n\n        // Execute the child program\n        std::cout &lt;&lt; \"Exec: \";\n        for (int i = 0; i &lt; proc_struct-&gt;m_args.size() + 1; i++) {\n            std::cout &lt;&lt; \" \" &lt;&lt; args_list[i];\n        }\n        std::cout &lt;&lt; std::endl;\n        execvp(args_list[0], args_list);\n\n        // If execl fails, it means the child process couldn't be started\n        perror(\"execvp\");\n        exit(EXIT_FAILURE);\n    } else {  // Parent process\n        spdlog::info(\"Start simulation process {}. Command: {}\", pid, proc_struct-&gt;m_command);\n        proc_struct-&gt;m_pid2 = pid;\n\n        // Close unnecessary pipe ends\n        close(pipe_stdin[0]);\n        close(pipe_stdout[1]);\n        close(pipe_stderr[1]);\n        int stdin_fd = pipe_stdin[1];\n        int stdout_fd = pipe_stdout[0];\n        int stderr_fd = pipe_stderr[0];\n\n        pollfd fd_list[2] = {{fd : stdout_fd, events : POLL_IN},\n                             {fd : stderr_fd, events : POLL_IN}};\n\n        // Move log to subfolder.\n        std::ofstream log_file(std::string(sub_dir_path) + \"/\" + proc_struct-&gt;m_log_file);\n\n        // Write execution start time to log file.\n        std::time_t t = std::time(0);\n        std::tm* now = std::localtime(&amp;t);\n        log_file &lt;&lt; \"Execution starts at \" &lt;&lt; (now-&gt;tm_year + 1900) &lt;&lt; \"-\" &lt;&lt; (now-&gt;tm_mon + 1)\n                 &lt;&lt; \"-\" &lt;&lt; now-&gt;tm_mday &lt;&lt; \"  \" &lt;&lt; (now-&gt;tm_hour) &lt;&lt; \":\" &lt;&lt; (now-&gt;tm_min) &lt;&lt; \":\"\n                 &lt;&lt; (now-&gt;tm_sec) &lt;&lt; std::endl;\n\n        char* pipe_buf = new char[PIPE_BUF_SIZE + 1];\n        bool to_stdout = proc_struct-&gt;m_to_stdout;\n        int res = 0;\n        while (true) {\n            int res = poll(fd_list, 2, 1000);\n            if (res == -1) {\n                perror(\"poll\");\n                break;\n            }\n\n            bool has_stdout = false;\n            if (fd_list[0].revents &amp; POLL_IN) {\n                has_stdout = true;\n                int res = read(stdout_fd, pipe_buf, PIPE_BUF_SIZE);\n                if (res &lt;= 0) break;\n                pipe_buf[res] = '\\0';\n                // log redirection.\n                log_file.write(pipe_buf, res).flush();\n                if (to_stdout) {\n                    std::cout.write(pipe_buf, res);\n                    std::cout.flush();\n                }\n                // Parse command in pipe_buf\n                parse_command(pipe_buf, proc_struct, stdin_fd);\n            }\n            if (fd_list[1].revents &amp; POLL_IN) {\n                has_stdout = true;\n                int res = read(stderr_fd, pipe_buf, PIPE_BUF_SIZE);\n                if (res &lt;= 0) break;\n                pipe_buf[res] = '\\0';\n                // log redirection.\n                log_file.write(pipe_buf, res).flush();\n                if (to_stdout) {\n                    std::cerr.write(pipe_buf, res);\n                    std::cerr.flush();\n                }\n                // Parse command in pipe_buf\n                parse_command(pipe_buf, proc_struct, stdin_fd);\n            }\n\n            // Check the status of child process and quit.\n            int status;\n            if (!has_stdout &amp;&amp; (waitpid(pid, &amp;status, WNOHANG) &gt; 0)) {\n                // Optionally handle child process termination status\n                if (status == 0) {\n                    spdlog::info(\"Simulation process {} terminate with status = {}.\",\n                                 proc_struct-&gt;m_pid2, status);\n                } else {\n                    spdlog::error(\"Simulation process {} terminate with status = {}.\",\n                                  proc_struct-&gt;m_pid2, status);\n                }\n                break;\n            }\n        }\n\n        delete pipe_buf;\n    }\n\n    return 0;\n}\n\nInterChiplet::InnerTimeType __loop_phase_one(\n    int __round, const std::vector&lt;ProcessConfig&gt;&amp; __proc_phase1_cfg_list,\n    const std::vector&lt;ProcessConfig&gt;&amp; __proc_phase2_cfg_list) {\n    // Create synchronize data structure.\n    SyncStruct* g_sync_structure = new SyncStruct();\n\n    // Load delay record.\n    g_sync_structure-&gt;m_delay_list.loadDelayInfo(\"delayInfo.txt\",\n                                                 __proc_phase2_cfg_list[0].m_clock_rate);\n    spdlog::info(\"Load {} delay records.\", g_sync_structure-&gt;m_delay_list.size());\n\n    // Create multi-thread.\n    int thread_i = 0;\n    std::vector&lt;ProcessStruct*&gt; proc_struct_list;\n    for (auto&amp; proc_cfg : __proc_phase1_cfg_list) {\n        ProcessStruct* proc_struct = new ProcessStruct(proc_cfg);\n        proc_struct-&gt;m_round = __round;\n        proc_struct-&gt;m_phase = 1;\n        proc_struct-&gt;m_thread = thread_i;\n        proc_struct-&gt;m_sync_struct = g_sync_structure;\n        int res =\n            pthread_create(&amp;(proc_struct-&gt;m_thread_id), NULL, bridge_thread, (void*)proc_struct);\n        if (res &lt; 0) {\n            perror(\"pthread_create\");\n            exit(EXIT_FAILURE);\n        }\n\n        proc_struct_list.push_back(proc_struct);\n        thread_i++;\n    }\n\n    // Wait threads to finish.\n    for (auto&amp; proc_struct : proc_struct_list) {\n        pthread_join(proc_struct-&gt;m_thread_id, NULL);\n        delete proc_struct;\n    }\n    spdlog::info(\"All process has exit.\");\n\n    // Remove file.\n    for (auto&amp; pipe_name : g_sync_structure-&gt;m_pipe_struct.pipeSet()) {\n        remove(pipe_name.c_str());\n    }\n\n    // Dump benchmark record.\n    g_sync_structure-&gt;m_bench_list.dumpBench(\"bench.txt\", __proc_phase2_cfg_list[0].m_clock_rate);\n    spdlog::info(\"Dump {} bench records.\", g_sync_structure-&gt;m_bench_list.size());\n\n    // Destory global synchronize structure, and return total cycle.\n    InterChiplet::InnerTimeType res_cycle = g_sync_structure-&gt;m_cycle_struct.cycle();\n    delete g_sync_structure;\n    return res_cycle;\n}\n\nvoid __loop_phase_two(int __round, const std::vector&lt;ProcessConfig&gt;&amp; __proc_cfg_list) {\n    // Create synchronize data structure.\n    SyncStruct* g_sync_structure = new SyncStruct();\n\n    // Create multi-thread.\n    int thread_i = 0;\n    std::vector&lt;ProcessStruct*&gt; proc_struct_list;\n    for (auto&amp; proc_cfg : __proc_cfg_list) {\n        ProcessStruct* proc_struct = new ProcessStruct(proc_cfg);\n        proc_struct-&gt;m_round = __round;\n        proc_struct-&gt;m_phase = 2;\n        proc_struct-&gt;m_thread = thread_i;\n        thread_i++;\n        proc_struct-&gt;m_sync_struct = g_sync_structure;\n        int res =\n            pthread_create(&amp;(proc_struct-&gt;m_thread_id), NULL, bridge_thread, (void*)proc_struct);\n        if (res &lt; 0) {\n            perror(\"pthread_create\");\n            exit(EXIT_FAILURE);\n        }\n\n        proc_struct_list.push_back(proc_struct);\n        thread_i++;\n    }\n\n    // Wait threads to finish.\n    for (auto&amp; proc_struct : proc_struct_list) {\n        pthread_join(proc_struct-&gt;m_thread_id, NULL);\n        delete proc_struct;\n    }\n    spdlog::info(\"All process has exit.\");\n\n    // Destory global synchronize structure.\n    delete g_sync_structure;\n}\n\nint main(int argc, const char* argv[]) {\n    // Parse command line.\n    CmdLineOptions options;\n    if (options.parse(argc, argv) != 0) {\n        return 0;\n    };\n\n    // Initializate logging\n    if (options.m_debug) {\n        spdlog::set_level(spdlog::level::debug);\n    }\n    spdlog::info(\"==== LegoSim Chiplet Simulator ====\");\n\n    // Change working directory if --cwd is specified.\n    if (options.m_cwd != \"\") {\n        if (access(options.m_cwd.c_str(), F_OK) == 0) {\n            if (chdir(options.m_cwd.c_str()) &lt; 0) {\n                perror(\"chdir\");\n            }\n            spdlog::info(\"Change working directory {}.\", get_current_dir_name());\n        }\n    }\n\n    // Check exist of benchmark configuration yaml.\n    if (access(options.m_bench.c_str(), F_OK) &lt; 0) {\n        spdlog::error(\"Cannot find benchmark {}.\", options.m_bench);\n        exit(EXIT_FAILURE);\n    }\n\n    // Load benchmark configuration.\n    BenchmarkConfig configs(options.m_bench);\n    spdlog::info(\"Load benchmark configuration from {}.\", options.m_bench);\n\n    // Get start time of simulation.\n    struct timeval simstart, simend, roundstart, roundend;\n    gettimeofday(&amp;simstart, 0);\n\n    InterChiplet::InnerTimeType sim_cycle = 0;\n    for (int round = 1; round &lt;= options.m_timeout_threshold; round++) {\n        // Get start time of one round.\n        gettimeofday(&amp;roundstart, 0);\n        spdlog::info(\"**** Round {} Phase 1 ****\", round);\n        InterChiplet::InnerTimeType round_cycle =\n            __loop_phase_one(round, configs.m_phase1_proc_cfg_list, configs.m_phase2_proc_cfg_list);\n\n        // Get simulation cycle.\n        // If simulation cycle this round is close to the previous one, quit iteration.\n        spdlog::info(\"Benchmark elapses {} cycle.\",\n                     static_cast&lt;InterChiplet::TimeType&gt;(round_cycle));\n        if (round &gt; 1) {\n            // Calculate error of simulation cycle.\n            double err_rate = ((double)round_cycle - (double)sim_cycle) / (double)round_cycle;\n            err_rate = err_rate &lt; 0 ? -err_rate : err_rate;\n            spdlog::info(\"Difference related to pervious round is {}%.\", err_rate * 100);\n            // If difference is small enough, quit loop.\n            if (err_rate &lt; options.m_err_rate_threshold) {\n                spdlog::info(\"Quit simulation because simulation cycle has converged.\");\n                sim_cycle = round_cycle;\n                break;\n            }\n        }\n        sim_cycle = round_cycle;\n\n        spdlog::info(\"**** Round {} Phase 2 ***\", round);\n        __loop_phase_two(round, configs.m_phase2_proc_cfg_list);\n\n        // Get end time of one round.\n        gettimeofday(&amp;roundend, 0);\n        unsigned long elaped_sec = roundend.tv_sec - roundstart.tv_sec;\n        spdlog::info(\"Round {} elapses {}d {}h {}m {}s.\", round, elaped_sec / 3600 / 24,\n                     (elaped_sec / 3600) % 24, (elaped_sec / 60) % 60, elaped_sec % 60);\n    }\n\n    // Get end time of simulation.\n    spdlog::info(\"**** End of Simulation ****\");\n    gettimeofday(&amp;simend, 0);\n    unsigned long elaped_sec = simend.tv_sec - simstart.tv_sec;\n    spdlog::info(\"Benchmark elapses {} cycle.\", static_cast&lt;InterChiplet::TimeType&gt;(sim_cycle));\n    spdlog::info(\"Simulation elapseds {}d {}h {}m {}s.\", elaped_sec / 3600 / 24,\n                 (elaped_sec / 3600) % 24, (elaped_sec / 60) % 60, elaped_sec % 60);\n}\n</code></pre>"},{"location":"apiProject1/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace InterChiplet </li> </ul>"},{"location":"apiProject1/classes/","title":"Class Index","text":""},{"location":"apiProject1/classes/#b","title":"b","text":"<ul> <li>BenchmarkConfig</li> </ul>"},{"location":"apiProject1/classes/#c","title":"c","text":"<ul> <li>CmdLineOptions</li> </ul>"},{"location":"apiProject1/classes/#n","title":"n","text":"<ul> <li>NetworkBenchItem</li> <li>NetworkBenchList</li> <li>NetworkDelayItem</li> <li>NetworkDelayMap</li> <li>NetworkDelayStruct</li> </ul>"},{"location":"apiProject1/classes/#p","title":"p","text":"<ul> <li>PipeComm (InterChiplet)</li> <li>PipeCommUnit (InterChiplet)</li> <li>ProcessConfig</li> <li>ProcessStruct</li> </ul>"},{"location":"apiProject1/classes/#s","title":"s","text":"<ul> <li>SyncCommand (InterChiplet)</li> <li>SyncBarrierStruct</li> <li>SyncClockStruct</li> <li>SyncCommStruct</li> <li>SyncLaunchStruct</li> <li>SyncLockStruct</li> <li>SyncPipeStruct</li> <li>SyncStruct</li> </ul>"},{"location":"apiProject1/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class BenchmarkConfig Benchmark configuration structure. </li> <li>class CmdLineOptions Options from command line. </li> <li>class InterChiplet::PipeComm Pipe communication structure. </li> <li>class InterChiplet::PipeCommUnit Structure for Single Pipe communication. </li> <li>class InterChiplet::SyncCommand Structure of synchronization command. </li> <li>class NetworkBenchItem Structure of one package in network. </li> <li>class NetworkDelayItem Structure presents delay of one package in network. </li> <li>class NetworkDelayStruct List of network delay item. </li> <li>class ProcessConfig Data structure to configure one simulation process. </li> <li>class ProcessStruct Data structure of process configuration. </li> <li>class SyncBarrierStruct Structure for Barrier synchronization. </li> <li>class SyncClockStruct Structure for Clock synchronization. </li> <li>class SyncCommStruct Structure for Communication synchronization. </li> <li>class SyncLaunchStruct Structure for Launch and Wait-launch synchronization. </li> <li>class SyncLockStruct Structure for Lock and Unlock synchronization. </li> <li>class SyncPipeStruct Structure for Pipe synchronization. </li> <li>class SyncStruct Data structure of synchronize operation. </li> <li>class std::multimap&lt; InterChiplet::InnerTimeType, NetworkBenchItem &gt; </li> <li>class NetworkBenchList List of network benchmark item. </li> <li>class std::map&lt; InterChiplet::AddrType, NetworkDelayOrder &gt; </li> <li>class NetworkDelayMap Map for network delay information. </li> </ul>"},{"location":"apiProject1/modules/","title":"Modules","text":"<p>Here is a list of all modules:</p> <ul> <li>Benchmark_yaml YAML configuration file interface. </li> <li>Cmd_handler_func Functions to handle commands. </li> <li>Cmd_handler_struct Structures for Command handler. </li> <li>APIs for CPU APIs for CPU. </li> <li>Apis_for_cuda APIs for CUDA. </li> <li>Cmdline Command line parser. </li> <li>Net_bench Network benchmark interface. </li> <li>Net_delay Network latency information interface. </li> <li>Pipe_comm Pipe communication interface. </li> <li>Sync_proto Synchronization protocol interface. </li> </ul>"},{"location":"apiProject1/pages/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p>"},{"location":"apiProject1/class_members/","title":"Class Members","text":""},{"location":"apiProject1/class_members/#b","title":"b","text":"<ul> <li>BenchmarkConfig (BenchmarkConfig)</li> <li>barrierCmd (SyncBarrierStruct)</li> </ul>"},{"location":"apiProject1/class_members/#c","title":"c","text":"<ul> <li>CmdLineOptions (CmdLineOptions)</li> <li>checkOrderOfCommand (NetworkDelayMap, NetworkDelayStruct)</li> <li>clearDelayInfo (NetworkDelayStruct)</li> <li>cycle (SyncClockStruct)</li> </ul>"},{"location":"apiProject1/class_members/#d","title":"d","text":"<ul> <li>dumpBench (NetworkBenchList)</li> </ul>"},{"location":"apiProject1/class_members/#e","title":"e","text":"<ul> <li>extend_env_var (BenchmarkConfig)</li> <li>extend_env_var_proc (BenchmarkConfig)</li> <li>extend_env_var_string (BenchmarkConfig)</li> </ul>"},{"location":"apiProject1/class_members/#f","title":"f","text":"<ul> <li>front (NetworkDelayMap)</li> <li>frontLaunchSrc (NetworkDelayStruct)</li> <li>frontLockSrc (NetworkDelayStruct)</li> </ul>"},{"location":"apiProject1/class_members/#g","title":"g","text":"<ul> <li>getBarrierCycle (NetworkDelayStruct)</li> <li>getDefaultEndCycle (NetworkDelayStruct)</li> <li>getEndCycle (NetworkDelayStruct)</li> <li>getLastCmd (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_members/#h","title":"h","text":"<ul> <li>hasAddr (NetworkDelayMap)</li> <li>hasLaunch (NetworkDelayStruct)</li> <li>hasLock (NetworkDelayStruct)</li> <li>hasMatchRead (SyncCommStruct)</li> <li>hasMatchWrite (SyncCommStruct)</li> <li>hasMatchLaunch (SyncLaunchStruct)</li> <li>hasMatchWaitlaunch (SyncLaunchStruct)</li> <li>hasLastCmd (SyncLockStruct)</li> <li>hasLockCmd (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_members/#i","title":"i","text":"<ul> <li>insert (NetworkBenchList, NetworkDelayMap, SyncPipeStruct)</li> <li>insertBarrier (SyncBarrierStruct)</li> <li>insertRead (SyncCommStruct)</li> <li>insertWrite (SyncCommStruct)</li> <li>insertLaunch (SyncLaunchStruct)</li> <li>insertWaitlaunch (SyncLaunchStruct)</li> <li>insertLockCmd (SyncLockStruct)</li> <li>isLocked (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_members/#l","title":"l","text":"<ul> <li>loadDelayInfo (NetworkDelayStruct)</li> <li>lock (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_members/#m","title":"m","text":"<ul> <li>m_benchmark_root (BenchmarkConfig)</li> <li>m_phase1_proc_cfg_list (BenchmarkConfig)</li> <li>m_phase2_proc_cfg_list (BenchmarkConfig)</li> <li>m_simulator_root (BenchmarkConfig)</li> <li>m_bench (CmdLineOptions)</li> <li>m_cwd (CmdLineOptions)</li> <li>m_debug (CmdLineOptions)</li> <li>m_err_rate_threshold (CmdLineOptions)</li> <li>m_timeout_threshold (CmdLineOptions)</li> <li>m_named_fifo_map (InterChiplet::PipeComm)</li> <li>m_file_id (InterChiplet::PipeCommUnit)</li> <li>m_file_name (InterChiplet::PipeCommUnit)</li> <li>m_read_ptr (InterChiplet::PipeCommUnit)</li> <li>m_size (InterChiplet::PipeCommUnit)</li> <li>mp_buf (InterChiplet::PipeCommUnit)</li> <li>m_clock_rate (InterChiplet::SyncCommand, ProcessConfig, ProcessStruct)</li> <li>m_cycle (InterChiplet::SyncCommand, NetworkDelayItem, SyncClockStruct)</li> <li>m_desc (InterChiplet::SyncCommand, NetworkBenchItem, NetworkDelayItem)</li> <li>m_dst (InterChiplet::SyncCommand, NetworkBenchItem, NetworkDelayItem)</li> <li>m_nbytes (InterChiplet::SyncCommand)</li> <li>m_res_list (InterChiplet::SyncCommand)</li> <li>m_src (InterChiplet::SyncCommand, NetworkBenchItem, NetworkDelayItem)</li> <li>m_stdin_fd (InterChiplet::SyncCommand)</li> <li>m_type (InterChiplet::SyncCommand)</li> <li>m_dst_cycle (NetworkBenchItem)</li> <li>m_id (NetworkBenchItem, NetworkDelayItem)</li> <li>m_pac_size (NetworkBenchItem)</li> <li>m_src_cycle (NetworkBenchItem)</li> <li>m_delay_list (NetworkDelayItem, SyncStruct)</li> <li>m_barrier_delay_map (NetworkDelayStruct)</li> <li>m_item_count (NetworkDelayStruct)</li> <li>m_launch_delay_map (NetworkDelayStruct)</li> <li>m_lock_delay_map (NetworkDelayStruct)</li> <li>m_src_delay_map (NetworkDelayStruct)</li> <li>m_unlock_delay_map (NetworkDelayStruct)</li> <li>m_args (ProcessConfig, ProcessStruct)</li> <li>m_command (ProcessConfig, ProcessStruct)</li> <li>m_log_file (ProcessConfig, ProcessStruct)</li> <li>m_pre_copy (ProcessConfig, ProcessStruct)</li> <li>m_to_stdout (ProcessConfig, ProcessStruct)</li> <li>m_phase (ProcessStruct)</li> <li>m_pid (ProcessStruct)</li> <li>m_pid2 (ProcessStruct)</li> <li>m_round (ProcessStruct)</li> <li>m_sync_struct (ProcessStruct)</li> <li>m_thread (ProcessStruct)</li> <li>m_thread_id (ProcessStruct)</li> <li>m_unfinished_line (ProcessStruct)</li> <li>m_barrier_count_map (SyncBarrierStruct)</li> <li>m_barrier_items_map (SyncBarrierStruct)</li> <li>m_read_cmd_list (SyncCommStruct)</li> <li>m_write_cmd_list (SyncCommStruct)</li> <li>m_launch_cmd_list (SyncLaunchStruct)</li> <li>m_waitlaunch_cmd_list (SyncLaunchStruct)</li> <li>m_last_cmd_map (SyncLockStruct)</li> <li>m_lock_cmd_list (SyncLockStruct)</li> <li>m_lock_set (SyncLockStruct)</li> <li>m_pipe_set (SyncPipeStruct)</li> <li>m_barrier_struct (SyncStruct)</li> <li>m_barrier_timing_struct (SyncStruct)</li> <li>m_bench_list (SyncStruct)</li> <li>m_comm_struct (SyncStruct)</li> <li>m_cycle_struct (SyncStruct)</li> <li>m_launch_struct (SyncStruct)</li> <li>m_lock_struct (SyncStruct)</li> <li>m_lock_timing_struct (SyncStruct)</li> <li>m_mutex (SyncStruct)</li> <li>m_pipe_struct (SyncStruct)</li> </ul>"},{"location":"apiProject1/class_members/#n","title":"n","text":"<ul> <li>NetworkBenchItem (NetworkBenchItem)</li> <li>NetworkBenchList (NetworkBenchList)</li> <li>NetworkDelayItem (NetworkDelayItem)</li> <li>NetworkDelayStruct (NetworkDelayStruct)</li> </ul>"},{"location":"apiProject1/class_members/#o","title":"o","text":"<ul> <li>overflow (SyncBarrierStruct)</li> </ul>"},{"location":"apiProject1/class_members/#p","title":"p","text":"<ul> <li>parse (CmdLineOptions)</li> <li>PipeComm (InterChiplet::PipeComm)</li> <li>PipeCommUnit (InterChiplet::PipeCommUnit)</li> <li>pop (NetworkDelayMap)</li> <li>popLaunch (NetworkDelayStruct)</li> <li>popLock (NetworkDelayStruct)</li> <li>ProcessConfig (ProcessConfig)</li> <li>ProcessStruct (ProcessStruct)</li> <li>popMatchRead (SyncCommStruct)</li> <li>popMatchWrite (SyncCommStruct)</li> <li>popMatchLaunch (SyncLaunchStruct)</li> <li>popMatchWaitlaunch (SyncLaunchStruct)</li> <li>popLockCmd (SyncLockStruct)</li> <li>pipeSet (SyncPipeStruct)</li> </ul>"},{"location":"apiProject1/class_members/#r","title":"r","text":"<ul> <li>read_data (InterChiplet::PipeComm, InterChiplet::PipeCommUnit)</li> <li>read_data_iter (InterChiplet::PipeCommUnit)</li> <li>reset (SyncBarrierStruct)</li> </ul>"},{"location":"apiProject1/class_members/#s","title":"s","text":"<ul> <li>size (NetworkDelayStruct)</li> <li>SyncClockStruct (SyncClockStruct)</li> <li>SyncStruct (SyncStruct)</li> </ul>"},{"location":"apiProject1/class_members/#u","title":"u","text":"<ul> <li>update (SyncClockStruct)</li> <li>unlock (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_members/#v","title":"v","text":"<ul> <li>valid (InterChiplet::PipeCommUnit)</li> </ul>"},{"location":"apiProject1/class_members/#w","title":"w","text":"<ul> <li>write_data (InterChiplet::PipeComm, InterChiplet::PipeCommUnit)</li> </ul>"},{"location":"apiProject1/class_members/#y","title":"y","text":"<ul> <li>yaml_parse (BenchmarkConfig)</li> <li>yaml_parse_phase (BenchmarkConfig)</li> <li>yaml_parse_process (BenchmarkConfig)</li> </ul>"},{"location":"apiProject1/class_members/#_1","title":"~","text":"<ul> <li>~SyncStruct (SyncStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/","title":"Class Member Functions","text":""},{"location":"apiProject1/class_member_functions/#b","title":"b","text":"<ul> <li>BenchmarkConfig (BenchmarkConfig)</li> <li>barrierCmd (SyncBarrierStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#c","title":"c","text":"<ul> <li>CmdLineOptions (CmdLineOptions)</li> <li>checkOrderOfCommand (NetworkDelayMap, NetworkDelayStruct)</li> <li>clearDelayInfo (NetworkDelayStruct)</li> <li>cycle (SyncClockStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#d","title":"d","text":"<ul> <li>dumpBench (NetworkBenchList)</li> </ul>"},{"location":"apiProject1/class_member_functions/#e","title":"e","text":"<ul> <li>extend_env_var (BenchmarkConfig)</li> <li>extend_env_var_proc (BenchmarkConfig)</li> <li>extend_env_var_string (BenchmarkConfig)</li> </ul>"},{"location":"apiProject1/class_member_functions/#f","title":"f","text":"<ul> <li>front (NetworkDelayMap)</li> <li>frontLaunchSrc (NetworkDelayStruct)</li> <li>frontLockSrc (NetworkDelayStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#g","title":"g","text":"<ul> <li>getBarrierCycle (NetworkDelayStruct)</li> <li>getDefaultEndCycle (NetworkDelayStruct)</li> <li>getEndCycle (NetworkDelayStruct)</li> <li>getLastCmd (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#h","title":"h","text":"<ul> <li>hasAddr (NetworkDelayMap)</li> <li>hasLaunch (NetworkDelayStruct)</li> <li>hasLock (NetworkDelayStruct)</li> <li>hasMatchRead (SyncCommStruct)</li> <li>hasMatchWrite (SyncCommStruct)</li> <li>hasMatchLaunch (SyncLaunchStruct)</li> <li>hasMatchWaitlaunch (SyncLaunchStruct)</li> <li>hasLastCmd (SyncLockStruct)</li> <li>hasLockCmd (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#i","title":"i","text":"<ul> <li>insert (NetworkBenchList, NetworkDelayMap, SyncPipeStruct)</li> <li>insertBarrier (SyncBarrierStruct)</li> <li>insertRead (SyncCommStruct)</li> <li>insertWrite (SyncCommStruct)</li> <li>insertLaunch (SyncLaunchStruct)</li> <li>insertWaitlaunch (SyncLaunchStruct)</li> <li>insertLockCmd (SyncLockStruct)</li> <li>isLocked (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#l","title":"l","text":"<ul> <li>loadDelayInfo (NetworkDelayStruct)</li> <li>lock (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#n","title":"n","text":"<ul> <li>NetworkBenchItem (NetworkBenchItem)</li> <li>NetworkBenchList (NetworkBenchList)</li> <li>NetworkDelayItem (NetworkDelayItem)</li> <li>NetworkDelayStruct (NetworkDelayStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#o","title":"o","text":"<ul> <li>overflow (SyncBarrierStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#p","title":"p","text":"<ul> <li>parse (CmdLineOptions)</li> <li>PipeComm (InterChiplet::PipeComm)</li> <li>PipeCommUnit (InterChiplet::PipeCommUnit)</li> <li>pop (NetworkDelayMap)</li> <li>popLaunch (NetworkDelayStruct)</li> <li>popLock (NetworkDelayStruct)</li> <li>ProcessConfig (ProcessConfig)</li> <li>ProcessStruct (ProcessStruct)</li> <li>popMatchRead (SyncCommStruct)</li> <li>popMatchWrite (SyncCommStruct)</li> <li>popMatchLaunch (SyncLaunchStruct)</li> <li>popMatchWaitlaunch (SyncLaunchStruct)</li> <li>popLockCmd (SyncLockStruct)</li> <li>pipeSet (SyncPipeStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#r","title":"r","text":"<ul> <li>read_data (InterChiplet::PipeComm, InterChiplet::PipeCommUnit)</li> <li>read_data_iter (InterChiplet::PipeCommUnit)</li> <li>reset (SyncBarrierStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#s","title":"s","text":"<ul> <li>size (NetworkDelayStruct)</li> <li>SyncClockStruct (SyncClockStruct)</li> <li>SyncStruct (SyncStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#u","title":"u","text":"<ul> <li>update (SyncClockStruct)</li> <li>unlock (SyncLockStruct)</li> </ul>"},{"location":"apiProject1/class_member_functions/#v","title":"v","text":"<ul> <li>valid (InterChiplet::PipeCommUnit)</li> </ul>"},{"location":"apiProject1/class_member_functions/#w","title":"w","text":"<ul> <li>write_data (InterChiplet::PipeComm, InterChiplet::PipeCommUnit)</li> </ul>"},{"location":"apiProject1/class_member_functions/#y","title":"y","text":"<ul> <li>yaml_parse (BenchmarkConfig)</li> <li>yaml_parse_phase (BenchmarkConfig)</li> <li>yaml_parse_process (BenchmarkConfig)</li> </ul>"},{"location":"apiProject1/class_member_functions/#_1","title":"~","text":"<ul> <li>~SyncStruct (SyncStruct)</li> </ul>"},{"location":"apiProject1/class_member_variables/","title":"Class Member Variables","text":""},{"location":"apiProject1/class_member_variables/#m","title":"m","text":"<ul> <li>m_benchmark_root (BenchmarkConfig)</li> <li>m_phase1_proc_cfg_list (BenchmarkConfig)</li> <li>m_phase2_proc_cfg_list (BenchmarkConfig)</li> <li>m_simulator_root (BenchmarkConfig)</li> <li>m_bench (CmdLineOptions)</li> <li>m_cwd (CmdLineOptions)</li> <li>m_debug (CmdLineOptions)</li> <li>m_err_rate_threshold (CmdLineOptions)</li> <li>m_timeout_threshold (CmdLineOptions)</li> <li>m_named_fifo_map (InterChiplet::PipeComm)</li> <li>m_file_id (InterChiplet::PipeCommUnit)</li> <li>m_file_name (InterChiplet::PipeCommUnit)</li> <li>m_read_ptr (InterChiplet::PipeCommUnit)</li> <li>m_size (InterChiplet::PipeCommUnit)</li> <li>mp_buf (InterChiplet::PipeCommUnit)</li> <li>m_clock_rate (InterChiplet::SyncCommand, ProcessConfig, ProcessStruct)</li> <li>m_cycle (InterChiplet::SyncCommand, NetworkDelayItem, SyncClockStruct)</li> <li>m_desc (InterChiplet::SyncCommand, NetworkBenchItem, NetworkDelayItem)</li> <li>m_dst (InterChiplet::SyncCommand, NetworkBenchItem, NetworkDelayItem)</li> <li>m_nbytes (InterChiplet::SyncCommand)</li> <li>m_res_list (InterChiplet::SyncCommand)</li> <li>m_src (InterChiplet::SyncCommand, NetworkBenchItem, NetworkDelayItem)</li> <li>m_stdin_fd (InterChiplet::SyncCommand)</li> <li>m_type (InterChiplet::SyncCommand)</li> <li>m_dst_cycle (NetworkBenchItem)</li> <li>m_id (NetworkBenchItem, NetworkDelayItem)</li> <li>m_pac_size (NetworkBenchItem)</li> <li>m_src_cycle (NetworkBenchItem)</li> <li>m_delay_list (NetworkDelayItem, SyncStruct)</li> <li>m_barrier_delay_map (NetworkDelayStruct)</li> <li>m_item_count (NetworkDelayStruct)</li> <li>m_launch_delay_map (NetworkDelayStruct)</li> <li>m_lock_delay_map (NetworkDelayStruct)</li> <li>m_src_delay_map (NetworkDelayStruct)</li> <li>m_unlock_delay_map (NetworkDelayStruct)</li> <li>m_args (ProcessConfig, ProcessStruct)</li> <li>m_command (ProcessConfig, ProcessStruct)</li> <li>m_log_file (ProcessConfig, ProcessStruct)</li> <li>m_pre_copy (ProcessConfig, ProcessStruct)</li> <li>m_to_stdout (ProcessConfig, ProcessStruct)</li> <li>m_phase (ProcessStruct)</li> <li>m_pid (ProcessStruct)</li> <li>m_pid2 (ProcessStruct)</li> <li>m_round (ProcessStruct)</li> <li>m_sync_struct (ProcessStruct)</li> <li>m_thread (ProcessStruct)</li> <li>m_thread_id (ProcessStruct)</li> <li>m_unfinished_line (ProcessStruct)</li> <li>m_barrier_count_map (SyncBarrierStruct)</li> <li>m_barrier_items_map (SyncBarrierStruct)</li> <li>m_read_cmd_list (SyncCommStruct)</li> <li>m_write_cmd_list (SyncCommStruct)</li> <li>m_launch_cmd_list (SyncLaunchStruct)</li> <li>m_waitlaunch_cmd_list (SyncLaunchStruct)</li> <li>m_last_cmd_map (SyncLockStruct)</li> <li>m_lock_cmd_list (SyncLockStruct)</li> <li>m_lock_set (SyncLockStruct)</li> <li>m_pipe_set (SyncPipeStruct)</li> <li>m_barrier_struct (SyncStruct)</li> <li>m_barrier_timing_struct (SyncStruct)</li> <li>m_bench_list (SyncStruct)</li> <li>m_comm_struct (SyncStruct)</li> <li>m_cycle_struct (SyncStruct)</li> <li>m_launch_struct (SyncStruct)</li> <li>m_lock_struct (SyncStruct)</li> <li>m_lock_timing_struct (SyncStruct)</li> <li>m_mutex (SyncStruct)</li> <li>m_pipe_struct (SyncStruct)</li> </ul>"},{"location":"apiProject1/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"apiProject1/class_member_enums/","title":"Class Member Enums","text":""},{"location":"apiProject1/namespace_members/","title":"Namespace Members","text":""},{"location":"apiProject1/namespace_members/#a","title":"a","text":"<ul> <li>AddrType (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#b","title":"b","text":"<ul> <li>barrier (InterChiplet)</li> <li>barrierSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#c","title":"c","text":"<ul> <li>cycleSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#d","title":"d","text":"<ul> <li>dumpCmd (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#i","title":"i","text":"<ul> <li>InnerTimeType (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#l","title":"l","text":"<ul> <li>launch (InterChiplet)</li> <li>launchSync (InterChiplet)</li> <li>lock (InterChiplet)</li> <li>lockSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#p","title":"p","text":"<ul> <li>parseCmd (InterChiplet)</li> <li>pipeName (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#r","title":"r","text":"<ul> <li>readSync (InterChiplet)</li> <li>receiveMessage (InterChiplet)</li> <li>receiveSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#s","title":"s","text":"<ul> <li>SyncCommType (InterChiplet)</li> <li>SyncProtocolDesc (InterChiplet)</li> <li>SysCallID (InterChiplet)</li> <li>sendBarrierCmd (InterChiplet)</li> <li>sendCycleCmd (InterChiplet)</li> <li>sendLaunchCmd (InterChiplet)</li> <li>sendLockCmd (InterChiplet)</li> <li>sendMessage (InterChiplet)</li> <li>sendReadCmd (InterChiplet)</li> <li>sendReceiveCmd (InterChiplet)</li> <li>sendResultCmd (InterChiplet)</li> <li>sendSendCmd (InterChiplet)</li> <li>sendSync (InterChiplet)</li> <li>sendSyncCmd (InterChiplet)</li> <li>sendUnlockCmd (InterChiplet)</li> <li>sendWaitlaunchCmd (InterChiplet)</li> <li>sendWriteCmd (InterChiplet)</li> <li>syscall_return_t (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#t","title":"t","text":"<ul> <li>TimeType (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#u","title":"u","text":"<ul> <li>unlock (InterChiplet)</li> <li>unlockSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_members/#w","title":"w","text":"<ul> <li>waitLaunch (InterChiplet)</li> <li>waitlaunchSync (InterChiplet)</li> <li>writeSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"apiProject1/namespace_member_functions/#b","title":"b","text":"<ul> <li>barrier (InterChiplet)</li> <li>barrierSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/#c","title":"c","text":"<ul> <li>cycleSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/#d","title":"d","text":"<ul> <li>dumpCmd (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/#l","title":"l","text":"<ul> <li>launch (InterChiplet)</li> <li>launchSync (InterChiplet)</li> <li>lock (InterChiplet)</li> <li>lockSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/#p","title":"p","text":"<ul> <li>parseCmd (InterChiplet)</li> <li>pipeName (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/#r","title":"r","text":"<ul> <li>readSync (InterChiplet)</li> <li>receiveMessage (InterChiplet)</li> <li>receiveSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/#s","title":"s","text":"<ul> <li>sendBarrierCmd (InterChiplet)</li> <li>sendCycleCmd (InterChiplet)</li> <li>sendLaunchCmd (InterChiplet)</li> <li>sendLockCmd (InterChiplet)</li> <li>sendMessage (InterChiplet)</li> <li>sendReadCmd (InterChiplet)</li> <li>sendReceiveCmd (InterChiplet)</li> <li>sendResultCmd (InterChiplet)</li> <li>sendSendCmd (InterChiplet)</li> <li>sendSync (InterChiplet)</li> <li>sendSyncCmd (InterChiplet)</li> <li>sendUnlockCmd (InterChiplet)</li> <li>sendWaitlaunchCmd (InterChiplet)</li> <li>sendWriteCmd (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/#u","title":"u","text":"<ul> <li>unlock (InterChiplet)</li> <li>unlockSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_functions/#w","title":"w","text":"<ul> <li>waitLaunch (InterChiplet)</li> <li>waitlaunchSync (InterChiplet)</li> <li>writeSync (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"apiProject1/namespace_member_variables/#s","title":"s","text":"<ul> <li>syscall_return_t (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"apiProject1/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>AddrType (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>InnerTimeType (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>TimeType (InterChiplet)</li> </ul>"},{"location":"apiProject1/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"apiProject1/namespace_member_enums/#s","title":"s","text":"<ul> <li>SyncCommType (InterChiplet)</li> <li>SyncProtocolDesc (InterChiplet)</li> <li>SysCallID (InterChiplet)</li> </ul>"},{"location":"apiProject1/functions/","title":"Functions","text":""},{"location":"apiProject1/functions/#b","title":"b","text":"<ul> <li>barrier (apis_cu.h)</li> <li>bridge_thread (interchiplet.cpp)</li> </ul>"},{"location":"apiProject1/functions/#h","title":"h","text":"<ul> <li>handle_barrier_cmd (cmd_handler.h)</li> <li>handle_cycle_cmd (cmd_handler.h)</li> <li>handle_launch_cmd (cmd_handler.h)</li> <li>handle_lock_cmd (cmd_handler.h)</li> <li>handle_pipe_cmd (cmd_handler.h)</li> <li>handle_read_cmd (cmd_handler.h)</li> <li>handle_unlock_cmd (cmd_handler.h)</li> <li>handle_waitlaunch_cmd (cmd_handler.h)</li> <li>handle_write_cmd (cmd_handler.h)</li> <li>handle_barrier_write_cmd (cmd_handler.cpp)</li> <li>handle_lock_write_cmd (cmd_handler.cpp)</li> <li>handle_unlock_write_cmd (cmd_handler.cpp)</li> </ul>"},{"location":"apiProject1/functions/#l","title":"l","text":"<ul> <li>launch (apis_cu.h)</li> <li>lock (apis_cu.h)</li> </ul>"},{"location":"apiProject1/functions/#m","title":"m","text":"<ul> <li>main (interchiplet.cpp)</li> </ul>"},{"location":"apiProject1/functions/#p","title":"p","text":"<ul> <li>parse_command (interchiplet.cpp)</li> </ul>"},{"location":"apiProject1/functions/#r","title":"r","text":"<ul> <li>receiveMessage (apis_cu.h)</li> </ul>"},{"location":"apiProject1/functions/#s","title":"s","text":"<ul> <li>sendMessage (apis_cu.h)</li> </ul>"},{"location":"apiProject1/functions/#u","title":"u","text":"<ul> <li>unlock (apis_cu.h)</li> </ul>"},{"location":"apiProject1/functions/#w","title":"w","text":"<ul> <li>waitLaunch (apis_cu.h)</li> </ul>"},{"location":"apiProject1/functions/#_","title":"_","text":"<ul> <li>__loop_phase_one (interchiplet.cpp)</li> <li>__loop_phase_two (interchiplet.cpp)</li> </ul>"},{"location":"apiProject1/macros/","title":"Macros","text":""},{"location":"apiProject1/macros/#d","title":"d","text":"<ul> <li>DIM_X (global_define.h)</li> <li>DIM_Y (global_define.h)</li> <li>DST_DELAY (net_delay.h)</li> </ul>"},{"location":"apiProject1/macros/#n","title":"n","text":"<ul> <li>NSINTERCHIPLET_CMD_HEAD (pipe_comm.h, sync_protocol.h)</li> </ul>"},{"location":"apiProject1/macros/#p","title":"p","text":"<ul> <li>PAC_PAYLOAD_BIT (net_bench.h, net_delay.h)</li> <li>PAC_PAYLOAD_BYTE (net_bench.h, net_delay.h)</li> <li>PIPE_COMMON_UNIT_CAPACITY (pipe_comm.h)</li> <li>PIPE_BUF_SIZE (interchiplet.cpp)</li> </ul>"},{"location":"apiProject1/macros/#s","title":"s","text":"<ul> <li>SRC_DELAY (net_delay.h)</li> </ul>"},{"location":"apiProject1/macros/#u","title":"u","text":"<ul> <li>UNSPECIFIED_ADDR (global_define.h)</li> </ul>"},{"location":"apiProject1/variables/","title":"Variables","text":""},{"location":"apiProject1/variables/#c","title":"c","text":"<ul> <li>CmdDelayPair (net_delay.h)</li> </ul>"},{"location":"apiProject1/variables/#n","title":"n","text":"<ul> <li>NetworkDelayOrder (net_delay.h)</li> </ul>"},{"location":"apiProject1/variables/#s","title":"s","text":"<ul> <li>SyncCmdList (cmd_handler.h)</li> </ul>"},{"location":"apiProject1/links/","title":"links","text":"<ul> <li>Related Pages</li> <li>Modules<ul> <li>Benchmark_yaml</li> <li>Cmd_handler_func</li> <li>Cmd_handler_struct</li> <li>APIs for CPU</li> <li>Apis_for_cuda</li> <li>Cmdline</li> <li>Net_bench</li> <li>Net_delay</li> <li>Pipe_comm</li> <li>Sync_proto</li> </ul> </li> <li>Class List<ul> <li>class BenchmarkConfig</li> <li>class CmdLineOptions</li> <li>namespace InterChiplet</li> <li>class InterChiplet::PipeComm</li> <li>class InterChiplet::PipeCommUnit</li> <li>class InterChiplet::SyncCommand</li> <li>class NetworkBenchItem</li> <li>class NetworkBenchList</li> <li>class NetworkDelayItem</li> <li>class NetworkDelayMap</li> <li>class NetworkDelayStruct</li> <li>class ProcessConfig</li> <li>class ProcessStruct</li> <li>class SyncBarrierStruct</li> <li>class SyncClockStruct</li> <li>class SyncCommStruct</li> <li>class SyncLaunchStruct</li> <li>class SyncLockStruct</li> <li>class SyncPipeStruct</li> <li>class SyncStruct</li> </ul> </li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files<ul> <li>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet</li> <li>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/includes<ul> <li>apis_c.h</li> <li>apis_c.h source</li> <li>apis_cu.h</li> <li>apis_cu.h source</li> <li>benchmark_yaml.h</li> <li>benchmark_yaml.h source</li> <li>cmd_handler.h</li> <li>cmd_handler.h source</li> <li>cmdline_options.h</li> <li>cmdline_options.h source</li> <li>global_define.h</li> <li>global_define.h source</li> <li>net_bench.h</li> <li>net_bench.h source</li> <li>net_delay.h</li> <li>net_delay.h source</li> <li>pipe_comm.h</li> <li>pipe_comm.h source</li> <li>sync_protocol.h</li> <li>sync_protocol.h source</li> </ul> </li> <li>/data_sda/junwan02/legosim/Chiplet_Heterogeneous_newVersion/interchiplet/srcs<ul> <li>apis_c.cpp</li> <li>apis_c.cpp source</li> <li>cmd_handler.cpp</li> <li>cmd_handler.cpp source</li> <li>interchiplet.cpp</li> <li>interchiplet.cpp source</li> </ul> </li> </ul> </li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}