diff --git a/libcuda/Makefile b/libcuda/Makefile
index c8ff2e3..9e51848 100644
--- a/libcuda/Makefile
+++ b/libcuda/Makefile
@@ -85,7 +85,7 @@ endif
 
 PROG     =cuda
 
-CXX_SRCS =  cuda_runtime_api.cc
+CXX_SRCS =  cuda_runtime_api.cc cuda_runtime_api_2.cc
 LEX_SRCS = cuobjdump.l
 YACC_SRCS = cuobjdump.y
 CXXFLAGS += -DCUDART_VERSION=$(CUDART_VERSION)
@@ -108,7 +108,7 @@ lib$(PROG).a: $(OBJS)
 	ar rcs $(OUTPUT_DIR)/lib$(PROG).a $(OBJS)
 
 $(OUTPUT_DIR)/%.o: %.cc
-	$(CPP) $(CXXFLAGS) -I./ -I$(OUTPUT_DIR) -I$(CUDA_INSTALL_PATH)/include  -c $< -o $@
+	$(CPP) $(CXXFLAGS) -I./ -I$(OUTPUT_DIR) -I$(CUDA_INSTALL_PATH)/include -I$(SIMULATOR_ROOT)/interchiplet/includes -c $< -o $@
 
 $(OUTPUT_DIR)/%.o: %.c
 	$(CPP) $(CCFLAGS) -I./ -I$(OUTPUT_DIR) -I$(CUDA_INSTALL_PATH)/include  -c $< -o $@
diff --git a/libcuda/cuda_runtime_api.cc b/libcuda/cuda_runtime_api.cc
index fd05f55..b06d333 100644
--- a/libcuda/cuda_runtime_api.cc
+++ b/libcuda/cuda_runtime_api.cc
@@ -606,10 +606,10 @@ void **cudaRegisterFatBinaryInternal(void *fatCubin,
     int pos = app_binary_path.find("python");
     if (pos == std::string::npos) {
       // Not pytorch app : checking cuda version
-      int app_cuda_version = get_app_cuda_version();
-      assert(
-          app_cuda_version == CUDART_VERSION / 1000 &&
-          "The app must be compiled with same major version as the simulator.");
+      //int app_cuda_version = get_app_cuda_version();
+      //assert(
+      //    app_cuda_version == CUDART_VERSION / 1000 &&
+      //    "The app must be compiled with same major version as the simulator.");
     }
 
     // int app_cuda_version = get_app_cuda_version();
diff --git a/src/gpgpu-sim/gpu-sim.cc b/src/gpgpu-sim/gpu-sim.cc
index 1650688..0eaa4c8 100644
--- a/src/gpgpu-sim/gpu-sim.cc
+++ b/src/gpgpu-sim/gpu-sim.cc
@@ -81,6 +81,10 @@ class gpgpu_sim_wrapper {};
 #define MAX(a, b) (((a) > (b)) ? (a) : (b))
 
 bool g_interactive_debugger_enabled = false;
+// TODO: directly forward GPU cycle.
+bool g_chiplet_directly_set_cycle = false;
+unsigned long long g_chiplet_directly_set_cycle_val = 0;
+bool g_chiplet_jump_deadlock_detect = false;
 
 tr1_hash_map<new_addr_type, unsigned> address_random_interleaving;
 
@@ -1854,6 +1858,14 @@ void gpgpu_sim::cycle() {
       raise(SIGTRAP);  // Debug breakpoint
     }
     gpu_sim_cycle++;
+    // TODO: quick forward cycle.
+    if (g_chiplet_directly_set_cycle)
+    {
+      std::cout << "Directly set cycle to " << g_chiplet_directly_set_cycle_val << std::endl;
+      gpu_sim_cycle = g_chiplet_directly_set_cycle_val;
+      g_chiplet_jump_deadlock_detect = true;
+      g_chiplet_directly_set_cycle = false;
+    }
 
     if (g_interactive_debugger_enabled) gpgpu_debug();
 
@@ -1956,7 +1968,10 @@ void gpgpu_sim::cycle() {
 
     if (!(gpu_sim_cycle % 50000)) {
       // deadlock detection
-      if (m_config.gpu_deadlock_detect && gpu_sim_insn == last_gpu_sim_insn) {
+      if (g_chiplet_jump_deadlock_detect) {
+        g_chiplet_jump_deadlock_detect = false;
+        last_gpu_sim_insn = gpu_sim_insn;
+      } else if (m_config.gpu_deadlock_detect && gpu_sim_insn == last_gpu_sim_insn) {
         gpu_deadlock = true;
       } else {
         last_gpu_sim_insn = gpu_sim_insn;
@@ -2051,3 +2066,10 @@ const shader_core_config *gpgpu_sim::getShaderCoreConfig() {
 const memory_config *gpgpu_sim::getMemoryConfig() { return m_memory_config; }
 
 simt_core_cluster *gpgpu_sim::getSIMTCluster() { return *m_cluster; }
+
+// Directly set cycle
+void gpgpu_sim::chiplet_direct_set_cycle(long long int end_time)
+{
+  g_chiplet_directly_set_cycle_val = end_time;
+  g_chiplet_directly_set_cycle = true;
+}
diff --git a/src/gpgpu-sim/gpu-sim.h b/src/gpgpu-sim/gpu-sim.h
index 2e6820d..5c0ce40 100644
--- a/src/gpgpu-sim/gpu-sim.h
+++ b/src/gpgpu-sim/gpu-sim.h
@@ -565,6 +565,9 @@ class gpgpu_sim : public gpgpu_t {
   // backward pointer
   class gpgpu_context *gpgpu_ctx;
 
+  // Directly set gpu cycle.
+  void chiplet_direct_set_cycle(long long int end_time);
+
  private:
   // clocks
   void reinit_clock_domains(void);
