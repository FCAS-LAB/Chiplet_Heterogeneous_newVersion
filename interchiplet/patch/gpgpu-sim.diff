diff --git a/src/cuda-sim/instructions.cc b/src/cuda-sim/instructions.cc
index 8936fa8..dfd8a82 100644
--- a/src/cuda-sim/instructions.cc
+++ b/src/cuda-sim/instructions.cc
@@ -43,7 +43,9 @@ class ptx_recognizer;
 #include <cmath>
 #include <map>
 #include <sstream>
+#include <iostream>
 #include <string>
+#include <vector>
 #include "../abstract_hardware_model.h"
 #include "../gpgpu-sim/gpu-sim.h"
 #include "../gpgpu-sim/shader.h"
@@ -52,6 +54,8 @@ class ptx_recognizer;
 #include "ptx.tab.h"
 #include "ptx_loader.h"
 
+#include "../../../interchiplet/includes/intercomm.h"
+
 // Jin: include device runtime for CDP
 #include "cuda_device_runtime.h"
 
@@ -1073,8 +1077,148 @@ void add_impl(const ptx_instruction *pI, ptx_thread_info *thread) {
   thread->set_operand_value(dst, data, i_type, thread, pI, overflow, carry);
 }
 
-void addc_impl(const ptx_instruction *pI, ptx_thread_info *thread) {
-  inst_not_implemented(pI);
+nsInterchiplet::PipeComm global_pipe_comm;
+
+int readFile(int dst_x, int dst_y ,int src_x, int src_y, int* data, int dataNum)
+{
+  std::cerr << "Enter GPGPUSim readFile" << std::endl;
+  nsInterchiplet::readSync(0, src_x, src_y, dst_x, dst_y, dataNum * sizeof(int));
+  char * fileName = new char[100];
+  sprintf(fileName,"./buffer%d_%d_%d_%d",src_x,src_y,dst_x,dst_y);
+
+  global_pipe_comm.read_data(fileName, data, dataNum * sizeof(int));
+  delete fileName;
+  return 1;
+}
+// gdb attach pid
+// | tee
+// 管道读写数据之前需要同步？  
+void passMessage(int dst_x, int dst_y,int src_x, int src_y , int* data, int dataNum)  //
+{
+  std::cerr << "Enter GPGPUSim passMessage" << std::endl;
+  nsInterchiplet::writeSync(0, src_x, src_y, dst_x, dst_y, dataNum * sizeof(int));
+  char * fileName = new char[100];
+  sprintf(fileName,"./buffer%d_%d_%d_%d",src_x,src_y,dst_x,dst_y);
+
+  global_pipe_comm.write_data(fileName, data, dataNum * sizeof(int));
+  delete fileName;
+}
+
+std::vector<uint32_t> syscall_op_list;
+void decode_space(memory_space_t &space, ptx_thread_info *thread,
+                  const operand_info &op, memory_space *&mem, addr_t &addr);
+
+//void decode_space(memory_space_t &space, ptx_thread_info *thread,
+//                  const operand_info &op, memory_space *&mem, addr_t &addr);
+
+void addc_impl( const ptx_instruction *pI, ptx_thread_info *thread ) 
+{ 
+	ptx_reg_t src1_data, src2_data, data;
+
+  const operand_info &dst  = pI->dst();
+  const operand_info &src1 = pI->src1();
+  const operand_info &src2 = pI->src2();
+  unsigned i_type = pI->get_type();
+  src1_data = thread->get_operand_value(src1, dst, i_type, thread, 1);
+  src2_data = thread->get_operand_value(src2, dst, i_type, thread, 1);
+  /**
+   * 传入的两个参数为src1_data.u64和src2_data.u64
+   *
+   * src1_data.u64是一个9位数, abcdefghi。ad表示src的x坐标，cd表示src的y坐标，ef表示dst的x坐标，gh表示dst的y坐标，i表是读请求还是写请求
+   * src2_data.u64是一个int型，在写请求中表示要写的数据，在读请求中表示请求的数据号
+   *
+   */
+  //std::cout<<"Step 1\n";
+
+  int data1 = src1_data.u64;
+  int data2 = src2_data.u64;
+  data.u64 = 0;
+
+  if (data2 == 0)
+  {
+    syscall_op_list.push_back(data1);
+    thread->set_operand_value(dst, data, i_type, thread, pI, 0, 0  );
+    std::cerr << "Add Syscall parameter " << data1 << std::endl;
+  }
+  else if (data2 == 1)
+  {
+    if (data1 == 1) // send message
+    {
+      int dst_x = syscall_op_list[0];
+      int dst_y = syscall_op_list[1];
+      int src_x = syscall_op_list[2];
+      int src_y = syscall_op_list[3];
+      uint64_t data_ptr = (uint64_t)syscall_op_list[4] + ((uint64_t)syscall_op_list[5] << 32);
+      int* data = (int*)data_ptr;
+      int dataSize = syscall_op_list[6];
+
+      char* filename= new char[64];
+      sprintf(filename,"./bench.%d.%d",src_x,src_y);
+      std::fstream toController(filename,std::ios::app);
+      long long unsigned int timeNow = thread->get_gpu()->gpu_sim_cycle+thread->get_gpu()->gpu_tot_sim_cycle;
+
+      if(!toController.is_open())
+      {
+        std::cout<<"Can not pass message to controller\n\n\n\n\n\n";
+        return;
+      }
+      else
+      {
+        toController<<timeNow<<" ";
+        toController<<src_x<<" ";
+        toController<<src_y<<" ";
+        toController<<dst_x<<" ";
+        toController<<dst_y<<" ";
+	      toController<<5<<"\n";
+      }
+      toController.close();
+
+      // read data from D2D.
+      int* interdata = new int[dataSize];
+      passMessage(dst_x,dst_y,src_x,src_y,interdata,dataSize);
+
+      // write data to GPU memory.
+      memory_space_t space;
+      space.set_type(global_space); // TODO: how to accept other space?
+      memory_space *mem = NULL;
+      addr_t addr = data_ptr;
+      decode_space(space, thread, dst, mem, addr);
+      mem->write(addr, dataSize, interdata, thread, pI);
+      delete interdata;
+
+      syscall_op_list.clear();
+    }
+    else if (data1 == 2) // send message
+    {
+      int dst_x = syscall_op_list[0];
+      int dst_y = syscall_op_list[1];
+      int src_x = syscall_op_list[2];
+      int src_y = syscall_op_list[3];
+      uint64_t data_ptr = (uint64_t)syscall_op_list[4] + ((uint64_t)syscall_op_list[5] << 32);
+      int* data = (int*)data_ptr;
+      int dataSize = syscall_op_list[6];
+
+      // read data from GPU memory.
+      int* interdata = new int[dataSize];
+      memory_space_t space;
+      space.set_type(global_space); // TODO: how to accept other space?
+      memory_space *mem = NULL;
+      addr_t addr = data_ptr;
+      decode_space(space, thread, src1, mem, addr);
+      mem->read(addr, dataSize, interdata);
+
+      // send data to D2D.
+    	readFile(dst_x,dst_y,src_x,src_y,interdata,dataSize);
+      delete interdata;
+
+      syscall_op_list.clear();
+    }
+    else
+    {
+      data.u64 = -1;
+    }
+  }
+  thread->set_operand_value(dst, data, i_type, thread, pI, 0, 0  );
 }
 
 void and_impl(const ptx_instruction *pI, ptx_thread_info *thread) {
